# -*- coding: utf-8 -*-
"""Model 3105 v1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_yGYg8r5mT7Ln8PS8JZaDGnN0NTElI_y
"""

gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)

"""**Initialization**


1.   langchain_community
2.   pandas
3.   json
4.   os
5.   sys

"""

pip install langchain_community

pip install -U langchain langchain-openai

pip install fasttext

!pip install snorkel

from langchain.output_parsers import StructuredOutputParser, ResponseSchema
from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate
from langchain.llms import OpenAI
from langchain.chat_models import ChatOpenAI
from langchain.tools import tool
from langchain.agents import initialize_agent, AgentType
from langchain.memory import ConversationBufferMemory
from langchain.chains import SequentialChain

import pandas as pd
import numpy as np
import json
import sys
import os
import random

############
## OPENAI ##
############

os.environ["OPENAI_API_KEY"] = "sk-SggkFnSnWfZSBSKV6In0nS7NDOPWO-XNIBEsZ7VBwBT3BlbkFJw8YfDZ0BYSFawnTHgAkRn0qFf0DtuRdk9i1adYh4YA"

###############
## LANGCHAIN ##
###############

os.environ["LANGCHAIN_TRACING_V2"]="true"
os.environ["LANGCHAIN_ENDPOINT"]="https://api.smith.langchain.com"
os.environ["LANGCHAIN_API_KEY"]="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"

"""

---

**FASTEXT INITIAL SETUP**"""

import fasttext
import fasttext.util
import os

# Path to save the model
model_path = 'cc.fr.300.bin'
compressed_model_path = 'cc.fr.300.bin.gz'

# Check if the model already exists
if not os.path.isfile(model_path):
    # If it doesn't exist, download the compressed version
    if not os.path.isfile(compressed_model_path):
        fasttext.util.download_model('fr', if_exists='ignore')  # This downloads the compressed .bin.gz file

# Load the model
ft = fasttext.load_model(model_path)

# Optionally, you can reduce the dimensions to make it even lighter
# This significantly reduces memory usage
reduced_dim = 100  # You can choose 100 or even lower like 50
fasttext.util.reduce_model(ft, reduced_dim)

import fasttext
import fasttext.util
import os

# Define the path where the model is stored
MODEL_PATH = "cc.fr.300.bin"  # Change this to the correct location if needed

# Load the FastText model if it exists
if os.path.exists(MODEL_PATH):
    ft = fasttext.load_model(MODEL_PATH)
    print("FastText model loaded successfully from local file.")
else:
    print(f"Error: Model file '{MODEL_PATH}' not found. Please check the path.")
    exit()

## AI MODEL ##
llm = ChatOpenAI(model_name="gpt-4-turbo",temperature=0)

Step4_xls = pd.read_excel(f"Step4_xls.xlsx")

# 0) Starting from your raw df with columns:
#    ACCOUNT_ID, CLEANED_TEXT, AMOUNT, DATE, NAF_CODE, MERCHANT, …

# 1) Parse dates
Step4_xls["DATE"] = pd.to_datetime(Step4_xls["DATE"], dayfirst=True)

# 2) Group by account & cleaned text, but keep the mode NAF_CODE
grouped = Step4_xls.groupby(["CLEANED_TEXT"])

Step4_xls["AMOUNT"] = (
    Step4_xls["AMOUNT"]
    .str.replace(r"\s+", "", regex=True)    # remove any spaces
    .str.replace(r"\.", "", regex=True)     # remove any dots used as thousand sep
    .str.replace(",", ".", regex=False)     # convert decimal comma to point
    .astype(float)                          # cast to float
)

agg_df = grouped.agg(
    # Numeric time‐series stats
    amt_count       = ("AMOUNT", "count"),
    amt_sum         = ("AMOUNT", "sum"),
    amt_mean        = ("AMOUNT", "mean"),
    amt_std         = ("AMOUNT", "std"),
    amt_median      = ("AMOUNT", "median"),
    amt_min         = ("AMOUNT", "min"),
    amt_max         = ("AMOUNT", "max"),
    amt_cv          = ("AMOUNT", lambda x: x.std()/x.mean() if x.mean() else 0),
    mean_delta_days = ("DATE", lambda x: np.diff(np.sort(x)).astype("timedelta64[D]").astype(int).mean()
                                             if len(x)>1 else 0),
    # Carry forward a single NAF_CODE per group
    NAF_CODE        = ("NAF_CODE", lambda x: x.mode().iat[0] if not x.mode().empty else None),
    # Keep one representative merchant if needed
    MERCHANT        = ("MERCHANT", lambda x: x.mode().iat[0] if not x.mode().empty else ""),
).reset_index()

agg_df["group_id"] = np.arange(len(agg_df))

agg_df.head()

agg_df.to_excel("ParseDatacCLEANEDTEXT_xls.xlsx", sheet_name="MySheet", index=False)

# Group by MERCHANT this time
merchant_grouped = Step4_xls.groupby(["MERCHANT"])

# Perform aggregation, keeping the mode of CLEANED_TEXT
merchant_agg_df = merchant_grouped.agg(
    # Keep the same numeric aggregations as before
    amt_count       = ("AMOUNT", "count"),
    amt_sum         = ("AMOUNT", "sum"),
    amt_mean        = ("AMOUNT", "mean"),
    amt_std         = ("AMOUNT", "std"),
    amt_median      = ("AMOUNT", "median"),
    amt_min         = ("AMOUNT", "min"),
    amt_max         = ("AMOUNT", "max"),
    amt_cv          = ("AMOUNT", lambda x: x.std()/x.mean() if x.mean() else 0),
    mean_delta_days = ("DATE", lambda x: np.diff(np.sort(x)).astype("timedelta64[D]").astype(int).mean()
                                      if len(x)>1 else 0),

    # Keep one representative CLEANED_TEXT per merchant group
    CLEANED_TEXT    = ("CLEANED_TEXT", lambda x: x.mode().iat[0] if not x.mode().empty else ""),

    # You might also want to keep the mode NAF_CODE as before
    NAF_CODE        = ("NAF_CODE", lambda x: x.mode().iat[0] if not x.mode().empty else None),
).reset_index()

merchant_agg_df["merchant_group_id"] = np.arange(len(merchant_agg_df))

merchant_agg_df.to_excel("ParseDatacMERCHANT_xls.xlsx", sheet_name="MySheet", index=False)

merchant_agg_df.head()

"""---

# Salary
"""

#5# THIRD APPROACH FOR SIMULTANEOUS INCOME STREAM POSSIBILITY

"""
Complete Multi-Income Classification System
Single file version for Google Colab
"""

import numpy as np
import pandas as pd
from snorkel.labeling import LabelingFunction, PandasLFApplier
from snorkel.labeling.model import LabelModel
from snorkel.labeling import LFAnalysis
from dataclasses import dataclass
from typing import Optional, Dict, List, Set
from enum import Enum

# ===========================
# CONSTANTS AND ENUMS
# ===========================

# Binary labels for classification
POSITIVE = 1
NEGATIVE = 0
ABSTAIN = -1

class IncomeSource(Enum):
    FULL_TIME = "full_time"
    PART_TIME = "part_time"
    FREELANCE = "freelance"
    SELF_EMPLOYED = "self_employed"
    RETIRED = "retired"

class PaymentFrequency(Enum):
    WEEKLY = "weekly"
    BIWEEKLY = "biweekly"
    MONTHLY = "monthly"
    IRREGULAR = "irregular"

# ===========================
# USER PROFILE CLASS
# ===========================

@dataclass
class UserProfile:
    income_sources: Set[IncomeSource]  # Multiple income sources
    monthly_income_range: str  # "under_1500", "1500_4000", "4000_plus"
    primary_income_source: Optional[IncomeSource] = None  # Main income source
    payment_frequencies: Optional[Dict[IncomeSource, PaymentFrequency]] = None

    def __post_init__(self):
        """Determine which classifiers to use and calculate thresholds"""
        self.needs_salary_classifier = any(source in [IncomeSource.FULL_TIME, IncomeSource.PART_TIME]
                                         for source in self.income_sources)
        self.needs_work_income_classifier = any(source in [IncomeSource.FREELANCE, IncomeSource.SELF_EMPLOYED]
                                              for source in self.income_sources)
        self.needs_pension_classifier = IncomeSource.RETIRED in self.income_sources

        # Set primary if not specified
        if not self.primary_income_source and self.income_sources:
            self.primary_income_source = next(iter(self.income_sources))

        # Initialize payment frequencies if not provided
        if not self.payment_frequencies:
            self.payment_frequencies = {}

        # Calculate thresholds for each needed classifier
        self.salary_thresholds = self._calculate_salary_thresholds() if self.needs_salary_classifier else {}
        self.work_income_thresholds = self._calculate_work_income_thresholds() if self.needs_work_income_classifier else {}
        self.pension_thresholds = self._calculate_pension_thresholds() if self.needs_pension_classifier else {}

    def get_active_classifiers(self) -> List[str]:
        """Return list of classifiers that should be run"""
        classifiers = []
        if self.needs_salary_classifier:
            classifiers.append("salary")
        if self.needs_work_income_classifier:
            classifiers.append("work_income")
        if self.needs_pension_classifier:
            classifiers.append("pension")
        return classifiers

    def _calculate_salary_thresholds(self) -> Dict[str, float]:
        """Calculate thresholds specifically for salary detection (EUR)"""
        if not self.needs_salary_classifier:
            return {}

        # Check what type of employment for salary
        has_full_time = IncomeSource.FULL_TIME in self.income_sources
        has_part_time = IncomeSource.PART_TIME in self.income_sources

        base_thresholds = {
            'weekly_min': 150,      # ~€600/month minimum
            'biweekly_min': 300,    # ~€600/month minimum
            'monthly_min': 600,     # €600/month minimum
            'max_cv': 0.2           # Lower CV for salary (more consistent)
        }

        # Adjust based on full-time vs part-time (prioritize full-time if both)
        if has_full_time:
            base_thresholds.update({
                'weekly_min': 250,     # ~€1000/month
                'biweekly_min': 500,   # ~€1000/month
                'monthly_min': 1000,   # €1000/month
                'max_cv': 0.15         # Very consistent for full-time
            })
        elif has_part_time:
            base_thresholds.update({
                'weekly_min': 120,     # ~€480/month
                'biweekly_min': 240,   # ~€480/month
                'monthly_min': 480,    # €480/month
                'max_cv': 0.25         # Slightly more variable
            })

        # Adjust based on income range
        self._adjust_thresholds_by_income(base_thresholds)

        return base_thresholds

    def _calculate_work_income_thresholds(self) -> Dict[str, float]:
        """Calculate thresholds specifically for work income detection (EUR)"""
        if not self.needs_work_income_classifier:
            return {}

        # Check what type of work income
        has_freelance = IncomeSource.FREELANCE in self.income_sources
        has_self_employed = IncomeSource.SELF_EMPLOYED in self.income_sources
        is_primary_work_income = self.primary_income_source in [IncomeSource.FREELANCE, IncomeSource.SELF_EMPLOYED]

        base_thresholds = {
            'minimum_amount': 200,   # Minimum per transaction
            'monthly_equivalent': 500,  # Minimum monthly equivalent
            'max_cv': 0.6,          # Much higher CV tolerance
            'min_transactions': 2    # Minimum number of transactions
        }

        # If it's primary income, use higher thresholds
        if is_primary_work_income:
            if has_freelance:
                base_thresholds.update({
                    'minimum_amount': 300,     # Projects tend to be larger
                    'monthly_equivalent': 800,
                    'max_cv': 0.7              # Very variable project income
                })
            elif has_self_employed:
                base_thresholds.update({
                    'minimum_amount': 250,     # Business income
                    'monthly_equivalent': 600,
                    'max_cv': 0.6              # Somewhat more regular than freelance
                })
        else:
            # Side hustle - lower thresholds
            base_thresholds.update({
                'minimum_amount': 100,     # Side projects can be smaller
                'monthly_equivalent': 200,  # Lower monthly equivalent for side income
                'max_cv': 0.8              # Very flexible for side income
            })

        # Adjust based on income range
        self._adjust_thresholds_by_income(base_thresholds)

        return base_thresholds

    def _calculate_pension_thresholds(self) -> Dict[str, float]:
        """Calculate thresholds specifically for pension detection (EUR)"""
        if not self.needs_pension_classifier:
            return {}

        is_primary_pension = self.primary_income_source == IncomeSource.RETIRED

        base_thresholds = {
            'monthly_min': 300,     # Minimum pension amount
            'monthly_max': 3000,    # Maximum reasonable pension
            'max_cv': 0.05,         # Very low variability (pensions are very consistent)
            'frequency_tolerance': 2  # Days tolerance for monthly payments (28-32 days)
        }

        # If pension is not primary (i.e., has other income), might be smaller pension
        if not is_primary_pension:
            base_thresholds.update({
                'monthly_min': 200,     # Smaller pensions possible
                'max_cv': 0.1           # Slightly more flexible
            })

        # Adjust based on income range
        if self.monthly_income_range == "under_1500":
            base_thresholds.update({
                'monthly_min': 200,
                'monthly_max': 1500
            })
        elif self.monthly_income_range == "1500_4000":
            base_thresholds.update({
                'monthly_min': 300 if is_primary_pension else 200,
                'monthly_max': 4000
            })
        elif self.monthly_income_range == "4000_plus":
            base_thresholds.update({
                'monthly_min': 500 if is_primary_pension else 300,
                'monthly_max': 6000
            })

        return base_thresholds

    def _adjust_thresholds_by_income(self, thresholds: Dict[str, float]):
        """Apply income range adjustments to thresholds"""
        if self.monthly_income_range == "under_1500":
            for key in thresholds:
                if 'min' in key or 'amount' in key or 'equivalent' in key:
                    thresholds[key] *= 0.7
        elif self.monthly_income_range == "4000_plus":
            for key in thresholds:
                if 'min' in key or 'amount' in key or 'equivalent' in key:
                    thresholds[key] *= 1.4

# ===========================
# DETECTOR CLASSES
# ===========================

class SalaryDetector:
    """Detector specifically for traditional salary (full-time/part-time employees)"""

    def __init__(self, user_profile: UserProfile):
        self.user_profile = user_profile
        self.thresholds = user_profile.salary_thresholds
        self.salary_anchors = [
            "salaire", "paie", "remuneration", "salary", "wages", "payroll",
            "employeur", "entreprise", "virement", "direct deposit", "dd",
            "net pay", "gross pay", "mensuel", "hebdomadaire"
        ]

    def create_salary_labeling_functions(self):
        """Create labeling functions for salary detection"""

        def lf_salary_regular_payments(x):
            """Detect regular salary payments with consistent amounts"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return ABSTAIN

            # Check for regular payment patterns
            is_weekly = 6 <= x.mean_delta_days <= 8
            is_biweekly = 13 <= x.mean_delta_days <= 16
            is_monthly = 26 <= x.mean_delta_days <= 32

            # Must be consistent (low variability)
            is_consistent = x.amt_cv < self.thresholds['max_cv']

            if not is_consistent:
                return ABSTAIN

            # Check amount thresholds by frequency
            if is_weekly and x.amt_mean >= self.thresholds['weekly_min']:
                return POSITIVE
            elif is_biweekly and x.amt_mean >= self.thresholds['biweekly_min']:
                return POSITIVE
            elif is_monthly and x.amt_mean >= self.thresholds['monthly_min']:
                return POSITIVE

            return ABSTAIN

        def lf_salary_text_indicators(x):
            """Detect salary based on text indicators"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Strong salary indicators
            if any(anchor in text_lower for anchor in self.salary_anchors):
                if x.amt_mean >= self.thresholds['monthly_min'] * 0.5:  # Lower threshold with text confirmation
                    return POSITIVE

            return ABSTAIN

        def lf_salary_expected_frequency(x):
            """Use user's stated payment frequency for salary detection"""
            if not self.user_profile.payment_frequencies or x.amt_mean <= 0:
                return ABSTAIN

            # Check if any employment source has a stated frequency
            relevant_sources = [source for source in self.user_profile.income_sources
                              if source in [IncomeSource.FULL_TIME, IncomeSource.PART_TIME]]

            if not relevant_sources:
                return ABSTAIN

            # Check frequencies for relevant sources
            for source in relevant_sources:
                if source in self.user_profile.payment_frequencies:
                    freq = self.user_profile.payment_frequencies[source]

                    # Must match user's stated frequency and be consistent
                    if freq == PaymentFrequency.WEEKLY and 6 <= x.mean_delta_days <= 8:
                        if x.amt_mean >= self.thresholds['weekly_min'] and x.amt_cv < 0.2:
                            return POSITIVE
                    elif freq == PaymentFrequency.BIWEEKLY and 13 <= x.mean_delta_days <= 16:
                        if x.amt_mean >= self.thresholds['biweekly_min'] and x.amt_cv < 0.2:
                            return POSITIVE
                    elif freq == PaymentFrequency.MONTHLY and 26 <= x.mean_delta_days <= 32:
                        if x.amt_mean >= self.thresholds['monthly_min'] and x.amt_cv < 0.2:
                            return POSITIVE

            return ABSTAIN

        def lf_not_salary_irregular(x):
            """Negative LF: Highly irregular payments are not salary"""
            if x.amt_cv > 0.5 or x.amt_count == 1:
                return NEGATIVE
            return ABSTAIN

        def lf_not_salary_very_small(x):
            """Negative LF: Very small amounts are not salary"""
            if x.amt_mean < 100:  # Less than €100 is unlikely to be salary
                return NEGATIVE
            return ABSTAIN

        return [
            LabelingFunction(name="lf_salary_regular_payments", f=lf_salary_regular_payments),
            LabelingFunction(name="lf_salary_text_indicators", f=lf_salary_text_indicators),
            LabelingFunction(name="lf_salary_expected_frequency", f=lf_salary_expected_frequency),
            LabelingFunction(name="lf_not_salary_irregular", f=lf_not_salary_irregular),
            LabelingFunction(name="lf_not_salary_very_small", f=lf_not_salary_very_small),
        ]

class WorkIncomeDetector:
    """Detector specifically for freelance/self-employed work income"""

    def __init__(self, user_profile: UserProfile):
        self.user_profile = user_profile
        self.thresholds = user_profile.work_income_thresholds
        self.work_income_anchors = [
            "facture", "invoice", "freelance", "consulting", "honoraires",
            "prestation", "service", "project", "client", "contrat",
            "independent", "contractor", "self employed", "business",
            "payment", "fees", "commission"
        ]

    def create_work_income_labeling_functions(self):
        """Create labeling functions for work income detection"""

        def lf_work_income_amount_threshold(x):
            """Detect work income based on amount patterns"""
            if x.amt_mean <= 0 or x.amt_count < self.thresholds['min_transactions']:
                return ABSTAIN

            # Check if amounts are reasonable for work income
            if x.amt_mean >= self.thresholds['minimum_amount']:
                # Allow higher variability than salary
                if x.amt_cv <= self.thresholds['max_cv']:
                    return POSITIVE

            return ABSTAIN

        def lf_work_income_text_indicators(x):
            """Detect work income based on text indicators"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Strong work income indicators
            if any(anchor in text_lower for anchor in self.work_income_anchors):
                if x.amt_mean >= self.thresholds['minimum_amount'] * 0.5:  # Lower threshold with text confirmation
                    return POSITIVE

            return ABSTAIN

        def lf_work_income_monthly_equivalent(x):
            """Check if irregular payments meet monthly equivalent threshold"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return ABSTAIN

            # Calculate approximate monthly equivalent based on frequency
            if x.mean_delta_days > 0:
                monthly_equivalent = (x.amt_mean * 30) / x.mean_delta_days
                if monthly_equivalent >= self.thresholds['monthly_equivalent']:
                    return POSITIVE

            return ABSTAIN

        def lf_work_income_project_patterns(x):
            """Detect project-based income patterns"""
            if x.amt_mean <= 0:
                return ABSTAIN

            # Freelance/project work often has:
            # - Larger amounts (€500+)
            # - Less frequent but substantial payments
            # - Moderate variability

            if (x.amt_mean >= 500 and
                x.amt_cv >= 0.2 and x.amt_cv <= 0.8 and  # Some variability expected
                x.amt_count >= 2):
                return POSITIVE

            return ABSTAIN

        def lf_not_work_income_too_regular(x):
            """Negative LF: Very regular payments might be salary, not freelance income"""
            # If payments are very regular AND consistent, might be salary instead
            is_very_regular = (26 <= x.mean_delta_days <= 32 or
                             13 <= x.mean_delta_days <= 16 or
                             6 <= x.mean_delta_days <= 8)
            is_very_consistent = x.amt_cv < 0.1

            if is_very_regular and is_very_consistent:
                return NEGATIVE

            return ABSTAIN

        def lf_not_work_income_too_small(x):
            """Negative LF: Very small amounts unlikely to be professional work income"""
            if x.amt_mean < 50:  # Less than €50 is unlikely to be professional work
                return NEGATIVE
            return ABSTAIN

        return [
            LabelingFunction(name="lf_work_income_amount_threshold", f=lf_work_income_amount_threshold),
            LabelingFunction(name="lf_work_income_text_indicators", f=lf_work_income_text_indicators),
            LabelingFunction(name="lf_work_income_monthly_equivalent", f=lf_work_income_monthly_equivalent),
            LabelingFunction(name="lf_work_income_project_patterns", f=lf_work_income_project_patterns),
            LabelingFunction(name="lf_not_work_income_too_regular", f=lf_not_work_income_too_regular),
            LabelingFunction(name="lf_not_work_income_too_small", f=lf_not_work_income_too_small),
        ]

class PensionDetector:
    """Detector specifically for pension/retirement income"""

    def __init__(self, user_profile: UserProfile):
        self.user_profile = user_profile
        self.thresholds = user_profile.pension_thresholds
        self.pension_anchors = [
            "pension", "retraite", "retirement", "pensionskasse", "rente",
            "social security", "securite sociale", "agirc", "arrco",
            "complementaire", "cnav", "carsat", "msa", "cipav",
            "malakoff", "ag2r", "klesia", "pro btp", "ircantec",
            "pension fund", "retirement fund", "annuity", "survivor"
        ]

    def create_pension_labeling_functions(self):
        """Create labeling functions for pension detection"""

        def lf_pension_regular_monthly(x):
            """Detect regular monthly pension payments"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return ABSTAIN

            # More flexible monthly pattern (24-35 days)
            is_monthly = 24 <= x.mean_delta_days <= 35

            # More flexible consistency (pensions can have small variations)
            is_consistent = x.amt_cv <= 0.15  # Increased from 0.05

            # More flexible pension range
            in_pension_range = x.amt_mean >= 200  # Just minimum check

            if is_monthly and is_consistent and in_pension_range:
                return POSITIVE

            return ABSTAIN

        def lf_pension_text_indicators(x):
            """Detect pension based on text indicators"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Strong pension indicators
            if any(anchor in text_lower for anchor in self.pension_anchors):
                # Lower amount threshold when we have strong text confirmation
                if x.amt_mean >= self.thresholds['monthly_min'] * 0.5:
                    return POSITIVE

            return ABSTAIN

        def lf_pension_ultra_consistent(x):
            """Detect ultra-consistent payments typical of pensions"""
            if x.amt_mean <= 0 or x.amt_count < 2:  # Reduced from 3 to 2
                return ABSTAIN

            # More flexible consistency threshold
            is_consistent = x.amt_cv <= 0.1  # Increased from 0.02
            is_reasonable_amount = x.amt_mean >= 150  # Reduced threshold
            is_monthly_ish = 20 <= x.mean_delta_days <= 40  # More flexible range

            if is_consistent and is_reasonable_amount and is_monthly_ish:
                return POSITIVE

            return ABSTAIN

        def lf_pension_expected_range(x):
            """Check if payment matches user's expected pension range"""
            if x.amt_mean <= 0:
                return ABSTAIN

            # More flexible thresholds
            min_threshold = max(150, self.thresholds['monthly_min'] * 0.5)  # At least €150
            max_threshold = self.thresholds['monthly_max'] * 1.5  # More flexible upper bound

            in_range = min_threshold <= x.amt_mean <= max_threshold
            is_consistent = x.amt_cv <= 0.2  # More flexible consistency
            is_regular = 20 <= x.mean_delta_days <= 40  # Broader monthly range

            if in_range and is_consistent and is_regular:
                return POSITIVE

            return ABSTAIN

        def lf_not_pension_too_variable(x):
            """Negative LF: Variable amounts are not pensions"""
            if x.amt_cv > 0.15:  # More than 15% variation unlikely for pension
                return NEGATIVE
            return ABSTAIN

        def lf_not_pension_wrong_frequency(x):
            """Negative LF: Non-monthly patterns are not typical pensions"""
            # Weekly or bi-weekly patterns are not typical for pensions
            is_weekly = 6 <= x.mean_delta_days <= 8
            is_biweekly = 13 <= x.mean_delta_days <= 16

            if is_weekly or is_biweekly:
                return NEGATIVE

            return ABSTAIN

        def lf_not_pension_too_high(x):
            """Negative LF: Extremely high amounts unlikely to be standard pension"""
            if x.amt_mean > 5000:  # Very high amounts might be other income
                return NEGATIVE
            return ABSTAIN

        return [
            LabelingFunction(name="lf_pension_regular_monthly", f=lf_pension_regular_monthly),
            LabelingFunction(name="lf_pension_text_indicators", f=lf_pension_text_indicators),
            LabelingFunction(name="lf_pension_ultra_consistent", f=lf_pension_ultra_consistent),
            LabelingFunction(name="lf_pension_expected_range", f=lf_pension_expected_range),
            LabelingFunction(name="lf_not_pension_too_variable", f=lf_not_pension_too_variable),
            LabelingFunction(name="lf_not_pension_wrong_frequency", f=lf_not_pension_wrong_frequency),
            LabelingFunction(name="lf_not_pension_too_high", f=lf_not_pension_too_high),
        ]

# ===========================
# CLASSIFICATION FUNCTIONS
# ===========================

def apply_income_classification(user_profile: UserProfile, merchant_agg_df: pd.DataFrame):
    """Apply appropriate classifiers based on user profile - can run multiple"""

    active_classifiers = user_profile.get_active_classifiers()
    print(f"\n=== RUNNING {len(active_classifiers)} CLASSIFIERS ===")
    print(f"Active classifiers: {active_classifiers}")

    results = {}

    # Initialize result columns
    merchant_agg_df['is_salary'] = 0
    merchant_agg_df['salary_confidence'] = 0.0
    merchant_agg_df['is_work_income'] = 0
    merchant_agg_df['work_income_confidence'] = 0.0
    merchant_agg_df['is_pension'] = 0
    merchant_agg_df['pension_confidence'] = 0.0

    # Run salary classifier if needed
    if "salary" in active_classifiers:
        print("\n" + "="*50)
        print("RUNNING SALARY CLASSIFIER")
        print("="*50)
        salary_lfs, salary_model, merchant_agg_df = apply_salary_classification(user_profile, merchant_agg_df)
        results['salary'] = (salary_lfs, salary_model)

    # Run work income classifier if needed
    if "work_income" in active_classifiers:
        print("\n" + "="*50)
        print("RUNNING WORK INCOME CLASSIFIER")
        print("="*50)
        work_lfs, work_model, merchant_agg_df = apply_work_income_classification(user_profile, merchant_agg_df)
        results['work_income'] = (work_lfs, work_model)

    # Run pension classifier if needed
    if "pension" in active_classifiers:
        print("\n" + "="*50)
        print("RUNNING PENSION CLASSIFIER")
        print("="*50)
        pension_lfs, pension_model, merchant_agg_df = apply_pension_classification(user_profile, merchant_agg_df)
        results['pension'] = (pension_lfs, pension_model)

    # Summary of all results
    print("\n" + "="*60)
    print("FINAL CLASSIFICATION SUMMARY")
    print("="*60)

    total_transactions = len(merchant_agg_df)
    print(f"Total transactions analyzed: {total_transactions}")

    if "salary" in active_classifiers:
        salary_count = (merchant_agg_df['is_salary'] == 1).sum()
        high_conf_salary = (
            (merchant_agg_df['is_salary'] == 1) &
            (merchant_agg_df['salary_confidence'] > 0.7)
        ).sum()
        print(f"Salary predictions: {salary_count} ({salary_count/total_transactions*100:.1f}%)")
        print(f"High confidence salary: {high_conf_salary}")

    if "work_income" in active_classifiers:
        work_count = (merchant_agg_df['is_work_income'] == 1).sum()
        high_conf_work = (
            (merchant_agg_df['is_work_income'] == 1) &
            (merchant_agg_df['work_income_confidence'] > 0.7)
        ).sum()
        print(f"Work income predictions: {work_count} ({work_count/total_transactions*100:.1f}%)")
        print(f"High confidence work income: {high_conf_work}")

    if "pension" in active_classifiers:
        pension_count = (merchant_agg_df['is_pension'] == 1).sum()
        high_conf_pension = (
            (merchant_agg_df['is_pension'] == 1) &
            (merchant_agg_df['pension_confidence'] > 0.7)
        ).sum()
        print(f"Pension predictions: {pension_count} ({pension_count/total_transactions*100:.1f}%)")
        print(f"High confidence pension: {high_conf_pension}")

    # Check for overlaps (same transaction classified as multiple types)
    if len(active_classifiers) > 1:
        overlaps = 0
        if "salary" in active_classifiers and "work_income" in active_classifiers:
            both_salary_work = (
                (merchant_agg_df['is_salary'] == 1) &
                (merchant_agg_df['is_work_income'] == 1)
            ).sum()
            if both_salary_work > 0:
                print(f"Overlap (Salary + Work Income): {both_salary_work}")
                overlaps += both_salary_work

        if overlaps == 0:
            print("No overlapping classifications found ✓")

    return results, merchant_agg_df

def apply_salary_classification(user_profile: UserProfile, merchant_agg_df: pd.DataFrame):
    """Apply salary classification for employees"""
    print(f"\n=== APPLYING SALARY CLASSIFICATION ===")
    print(f"User sources: {[s.value for s in user_profile.income_sources]}")
    print(f"Thresholds: {user_profile.salary_thresholds}")

    # Create salary detector
    detector = SalaryDetector(user_profile)
    salary_lfs = detector.create_salary_labeling_functions()

    # Apply labeling functions
    applier = PandasLFApplier(lfs=salary_lfs)
    L_salary = applier.apply(merchant_agg_df)

    # Analyze performance
    lf_analysis = LFAnalysis(L=L_salary, lfs=salary_lfs)
    print(f"\nSalary LF Analysis:")
    print(lf_analysis.lf_summary())

    # Train model
    salary_model = LabelModel(cardinality=2, verbose=True)

    # Get class balance
    def get_binary_class_balance(L_matrix):
        votes = L_matrix[L_matrix != -1]
        if len(votes) == 0:
            return np.array([0.5, 0.5])
        positive_votes = np.sum(votes == 1)
        total_votes = len(votes)
        pos_ratio = positive_votes / total_votes if total_votes > 0 else 0.5
        return np.array([1 - pos_ratio, pos_ratio])

    class_balance = get_binary_class_balance(L_salary)
    print(f"Class balance: {class_balance}")

    # Train
    salary_model.fit(L_train=L_salary, n_epochs=500, log_freq=100, seed=42, class_balance=class_balance)

    # Predictions
    predictions = salary_model.predict(L=L_salary)
    probabilities = salary_model.predict_proba(L=L_salary)

    # Add to dataframe
    merchant_agg_df['is_salary'] = predictions
    merchant_agg_df['salary_confidence'] = probabilities[:, 1] if probabilities.shape[1] > 1 else probabilities[:, 0]

    # Results
    print(f"\nSalary Classification Results:")
    print(f"Total transactions: {len(merchant_agg_df)}")
    print(f"Predicted as salary: {(predictions == POSITIVE).sum()}")

    high_conf_salary = merchant_agg_df[
        (merchant_agg_df['is_salary'] == POSITIVE) &
        (merchant_agg_df['salary_confidence'] > 0.7)
    ]
    print(f"High confidence salary: {len(high_conf_salary)}")

    if len(high_conf_salary) > 0:
        print("\nTop salary predictions:")
        print(high_conf_salary[['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'salary_confidence']].head())

    return salary_lfs, salary_model, merchant_agg_df

def apply_work_income_classification(user_profile: UserProfile, merchant_agg_df: pd.DataFrame):
    """Apply work income classification for freelancers/self-employed"""
    print(f"\n=== APPLYING WORK INCOME CLASSIFICATION ===")
    print(f"User sources: {[s.value for s in user_profile.income_sources]}")
    print(f"Thresholds: {user_profile.work_income_thresholds}")

    # Create work income detector
    detector = WorkIncomeDetector(user_profile)
    work_income_lfs = detector.create_work_income_labeling_functions()

    # Apply labeling functions
    applier = PandasLFApplier(lfs=work_income_lfs)
    L_work_income = applier.apply(merchant_agg_df)

    # Analyze performance
    lf_analysis = LFAnalysis(L=L_work_income, lfs=work_income_lfs)
    print(f"\nWork Income LF Analysis:")
    print(lf_analysis.lf_summary())

    # Train model
    work_income_model = LabelModel(cardinality=2, verbose=True)

    # Get class balance
    def get_binary_class_balance(L_matrix):
        votes = L_matrix[L_matrix != -1]
        if len(votes) == 0:
            return np.array([0.5, 0.5])
        positive_votes = np.sum(votes == 1)
        total_votes = len(votes)
        pos_ratio = positive_votes / total_votes if total_votes > 0 else 0.5
        return np.array([1 - pos_ratio, pos_ratio])

    class_balance = get_binary_class_balance(L_work_income)
    print(f"Class balance: {class_balance}")

    # Train
    work_income_model.fit(L_train=L_work_income, n_epochs=500, log_freq=100, seed=42, class_balance=class_balance)

    # Predictions
    predictions = work_income_model.predict(L=L_work_income)
    probabilities = work_income_model.predict_proba(L=L_work_income)

    # Add to dataframe
    merchant_agg_df['is_work_income'] = predictions
    merchant_agg_df['work_income_confidence'] = probabilities[:, 1] if probabilities.shape[1] > 1 else probabilities[:, 0]

    # Results
    print(f"\nWork Income Classification Results:")
    print(f"Total transactions: {len(merchant_agg_df)}")
    print(f"Predicted as work income: {(predictions == POSITIVE).sum()}")

    high_conf_work = merchant_agg_df[
        (merchant_agg_df['is_work_income'] == POSITIVE) &
        (merchant_agg_df['work_income_confidence'] > 0.7)
    ]
    print(f"High confidence work income: {len(high_conf_work)}")

    if len(high_conf_work) > 0:
        print("\nTop work income predictions:")
        print(high_conf_work[['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'work_income_confidence']].head())

    return work_income_lfs, work_income_model, merchant_agg_df

def apply_pension_classification(user_profile: UserProfile, merchant_agg_df: pd.DataFrame):
    """Apply pension classification for retired users"""
    print(f"\n=== APPLYING PENSION CLASSIFICATION ===")
    print(f"User sources: {[s.value for s in user_profile.income_sources]}")
    print(f"Thresholds: {user_profile.pension_thresholds}")

    # Debug: Check data characteristics
    print(f"\nData overview:")
    print(f"Total transactions: {len(merchant_agg_df)}")
    print(f"Amount range: €{merchant_agg_df['amt_mean'].min():.2f} - €{merchant_agg_df['amt_mean'].max():.2f}")
    print(f"CV range: {merchant_agg_df['amt_cv'].min():.3f} - {merchant_agg_df['amt_cv'].max():.3f}")
    print(f"Delta days range: {merchant_agg_df['mean_delta_days'].min():.1f} - {merchant_agg_df['mean_delta_days'].max():.1f}")

    # Check for potential pension candidates
    potential_pensions = merchant_agg_df[
        (merchant_agg_df['amt_mean'] >= 150) &
        (merchant_agg_df['amt_cv'] <= 0.2) &
        (merchant_agg_df['mean_delta_days'] >= 20) &
        (merchant_agg_df['mean_delta_days'] <= 40)
    ]
    print(f"Potential pension candidates: {len(potential_pensions)}")

    if len(potential_pensions) > 0:
        print("Sample potential pensions:")
        print(potential_pensions[['CLEANED_TEXT', 'amt_mean', 'amt_cv', 'mean_delta_days', 'amt_count']].head())

    # Create pension detector
    detector = PensionDetector(user_profile)
    pension_lfs = detector.create_pension_labeling_functions()

    # Apply labeling functions
    applier = PandasLFApplier(lfs=pension_lfs)
    L_pension = applier.apply(merchant_agg_df)

    # Debug: Check LF outputs
    print(f"\nLF outputs summary:")
    for i, lf in enumerate(pension_lfs):
        lf_votes = L_pension[:, i]
        positive_votes = (lf_votes == 1).sum()
        negative_votes = (lf_votes == 0).sum()
        abstain_votes = (lf_votes == -1).sum()
        print(f"{lf.name}: +{positive_votes}, -{negative_votes}, abstain:{abstain_votes}")

    # Analyze performance
    lf_analysis = LFAnalysis(L=L_pension, lfs=pension_lfs)
    print(f"\nPension LF Analysis:")
    print(lf_analysis.lf_summary())

    # Check if we have any positive predictions
    positive_predictions = (L_pension == 1).any(axis=1).sum()
    if positive_predictions == 0:
        print("\nWARNING: No positive pension predictions found!")
        print("This might indicate:")
        print("1. No pension transactions in the data")
        print("2. Thresholds are too strict")
        print("3. Data format doesn't match expected patterns")

        # Return without training model
        merchant_agg_df['is_pension'] = 0
        merchant_agg_df['pension_confidence'] = 0.0
        return pension_lfs, None, merchant_agg_df

    # Train model
    pension_model = LabelModel(cardinality=2, verbose=True)

    # Get class balance
    def get_binary_class_balance(L_matrix):
        votes = L_matrix[L_matrix != -1]
        if len(votes) == 0:
            return np.array([0.5, 0.5])
        positive_votes = np.sum(votes == 1)
        total_votes = len(votes)
        pos_ratio = positive_votes / total_votes if total_votes > 0 else 0.01  # Avoid 0
        # Ensure neither class has 0 probability
        pos_ratio = max(0.01, min(0.99, pos_ratio))
        return np.array([1 - pos_ratio, pos_ratio])

    class_balance = get_binary_class_balance(L_pension)
    print(f"Class balance: {class_balance}")

    # Train
    pension_model.fit(L_train=L_pension, n_epochs=500, log_freq=100, seed=42, class_balance=class_balance)

    # Predictions
    predictions = pension_model.predict(L=L_pension)
    probabilities = pension_model.predict_proba(L=L_pension)

    # Add to dataframe
    merchant_agg_df['is_pension'] = predictions
    merchant_agg_df['pension_confidence'] = probabilities[:, 1] if probabilities.shape[1] > 1 else probabilities[:, 0]

    # Results
    print(f"\nPension Classification Results:")
    print(f"Total transactions: {len(merchant_agg_df)}")
    print(f"Predicted as pension: {(predictions == POSITIVE).sum()}")

    high_conf_pension = merchant_agg_df[
        (merchant_agg_df['is_pension'] == POSITIVE) &
        (merchant_agg_df['pension_confidence'] > 0.7)
    ]
    print(f"High confidence pension: {len(high_conf_pension)}")

    if len(high_conf_pension) > 0:
        print("\nTop pension predictions:")
        print(high_conf_pension[['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'pension_confidence']].head())

    return pension_lfs, pension_model, merchant_agg_df

# ===========================
# ONBOARDING FUNCTIONS
# ===========================

def simulate_onboarding():
    """Simulate the multi-select onboarding process"""
    print("=== INCOME CLASSIFICATION ONBOARDING ===\n")

    # Question 1: Income sources (multi-select)
    print("Question 1: What income sources do you have? (Select all that apply)")
    print("Enter the numbers separated by commas (e.g., 1,3,5)")
    print("1. Full-time job")
    print("2. Part-time job")
    print("3. Freelance work")
    print("4. Self-employed/Business")
    print("5. Pension/Retirement income")

    income_choice = input("\nEnter your choices (e.g., 1,3): ").strip()

    # Parse multiple selections
    selected_numbers = []
    try:
        selected_numbers = [int(x.strip()) for x in income_choice.split(',')]
    except ValueError:
        print("Invalid input, defaulting to part-time job")
        selected_numbers = [2]

    # Map to income sources
    income_mapping = {
        1: IncomeSource.FULL_TIME,
        2: IncomeSource.PART_TIME,
        3: IncomeSource.FREELANCE,
        4: IncomeSource.SELF_EMPLOYED,
        5: IncomeSource.RETIRED
    }

    income_sources = set()
    for num in selected_numbers:
        if num in income_mapping:
            income_sources.add(income_mapping[num])

    if not income_sources:  # Fallback if nothing selected
        income_sources = {IncomeSource.PART_TIME}

    print(f"Selected income sources: {[source.value for source in income_sources]}")

    # Question 2: Primary income source (if multiple selected)
    primary_income = None
    if len(income_sources) > 1:
        print(f"\nQuestion 2: Which is your PRIMARY income source?")
        source_list = list(income_sources)
        for i, source in enumerate(source_list, 1):
            print(f"{i}. {source.value.replace('_', ' ').title()}")

        primary_choice = input(f"\nEnter your choice (1-{len(source_list)}): ").strip()
        try:
            primary_idx = int(primary_choice) - 1
            if 0 <= primary_idx < len(source_list):
                primary_income = source_list[primary_idx]
        except ValueError:
            pass

        if not primary_income:
            primary_income = source_list[0]  # Default to first
    else:
        primary_income = next(iter(income_sources))

    print(f"Primary income source: {primary_income.value}")

    # Question 3: Monthly income range
    print(f"\nQuestion 3: What's your approximate TOTAL monthly income? (EUR)")
    print("1. Under €1,500")
    print("2. €1,500 - €4,000")
    print("3. €4,000+")
    print("4. Prefer not to say")

    income_range_choice = input("\nEnter your choice (1-4): ").strip()

    income_mapping = {
        "1": "under_1500",
        "2": "1500_4000",
        "3": "4000_plus",
        "4": "1500_4000"  # Default to middle range
    }
    income_range = income_mapping.get(income_range_choice, "1500_4000")

    # Question 4: Payment frequencies (for each income source)
    payment_frequencies = {}

    for source in income_sources:
        if source in [IncomeSource.FULL_TIME, IncomeSource.PART_TIME]:
            print(f"\nQuestion 4a: How often are you paid from your {source.value.replace('_', ' ')} job?")
            print("1. Weekly")
            print("2. Every 2 weeks")
            print("3. Monthly")
            print("4. Irregular")

            freq_choice = input("\nEnter your choice (1-4): ").strip()

            freq_mapping = {
                "1": PaymentFrequency.WEEKLY,
                "2": PaymentFrequency.BIWEEKLY,
                "3": PaymentFrequency.MONTHLY,
                "4": PaymentFrequency.IRREGULAR
            }
            payment_frequencies[source] = freq_mapping.get(freq_choice, PaymentFrequency.MONTHLY)

        elif source in [IncomeSource.FREELANCE, IncomeSource.SELF_EMPLOYED]:
            print(f"\nQuestion 4b: How would you describe your {source.value.replace('_', ' ')} payment pattern?")
            print("1. Regular monthly payments")
            print("2. Project-based (irregular)")
            print("3. Mixed/Variable")

            freq_choice = input("\nEnter your choice (1-3): ").strip()

            freq_mapping = {
                "1": PaymentFrequency.MONTHLY,
                "2": PaymentFrequency.IRREGULAR,
                "3": PaymentFrequency.IRREGULAR
            }
            payment_frequencies[source] = freq_mapping.get(freq_choice, PaymentFrequency.IRREGULAR)

        elif source == IncomeSource.RETIRED:
            print(f"\nQuestion 4c: How often do you receive your pension?")
            print("1. Monthly")
            print("2. Other frequency")

            freq_choice = input("\nEnter your choice (1-2): ").strip()
            payment_frequencies[source] = PaymentFrequency.MONTHLY if freq_choice == "1" else PaymentFrequency.IRREGULAR

    return UserProfile(
        income_sources=income_sources,
        monthly_income_range=income_range,
        primary_income_source=primary_income,
        payment_frequencies=payment_frequencies
    )

def quick_setup_examples():
    """Quick setup examples for different scenarios"""
    print("=== QUICK SETUP EXAMPLES ===\n")

    # Example 1: Full-time employee only
    salary_only_profile = UserProfile(
        income_sources={IncomeSource.FULL_TIME},
        monthly_income_range="1500_4000",
        primary_income_source=IncomeSource.FULL_TIME,
        payment_frequencies={IncomeSource.FULL_TIME: PaymentFrequency.MONTHLY}
    )

    # Example 2: Full-time + Side hustle
    salary_plus_freelance_profile = UserProfile(
        income_sources={IncomeSource.FULL_TIME, IncomeSource.FREELANCE},
        monthly_income_range="1500_4000",
        primary_income_source=IncomeSource.FULL_TIME,
        payment_frequencies={
            IncomeSource.FULL_TIME: PaymentFrequency.MONTHLY,
            IncomeSource.FREELANCE: PaymentFrequency.IRREGULAR
        }
    )

    # Example 3: Retired + Consulting
    pension_plus_consulting_profile = UserProfile(
        income_sources={IncomeSource.RETIRED, IncomeSource.FREELANCE},
        monthly_income_range="1500_4000",
        primary_income_source=IncomeSource.RETIRED,
        payment_frequencies={
            IncomeSource.RETIRED: PaymentFrequency.MONTHLY,
            IncomeSource.FREELANCE: PaymentFrequency.IRREGULAR
        }
    )

    print("Created three example profiles:")
    print(f"1. Salary only: {[s.value for s in salary_only_profile.income_sources]}")
    print(f"   Active classifiers: {salary_only_profile.get_active_classifiers()}")
    print(f"2. Full-time + Freelance: {[s.value for s in salary_plus_freelance_profile.income_sources]}")
    print(f"   Active classifiers: {salary_plus_freelance_profile.get_active_classifiers()}")
    print(f"3. Retired + Consulting: {[s.value for s in pension_plus_consulting_profile.income_sources]}")
    print(f"   Active classifiers: {pension_plus_consulting_profile.get_active_classifiers()}")

    return salary_only_profile, salary_plus_freelance_profile, pension_plus_consulting_profile

# ===========================
# MAIN USAGE EXAMPLES
# ===========================

def main():
    """Main function with usage examples"""
    print("=== MULTI-INCOME CLASSIFICATION SYSTEM ===")
    print("Complete system loaded successfully!")
    print()
    print("Usage examples:")
    print()
    print("# 1. Interactive onboarding (multi-select):")
    print("user_profile = simulate_onboarding()")
    print()
    print("# 2. Quick examples:")
    print("salary_only, salary_plus_freelance, pension_plus_consulting = quick_setup_examples()")
    print()
    print("# 3. Apply classification:")
    print("results, updated_df = apply_income_classification(user_profile, merchant_agg_df)")
    print()
    print("# 4. Example scenarios:")
    print("# - Full-time only: Select '1' → Runs salary classifier")
    print("# - Full-time + Side hustle: Select '1,3' → Runs salary AND work income classifiers")
    print("# - Retired + Consulting: Select '5,3' → Runs pension AND work income classifiers")
    print()
    print("Ready to use! 🚀")

if __name__ == "__main__":
    main()

user_profile = simulate_onboarding()

# Correct way:
results, updated_df = apply_income_classification(user_profile, merchant_agg_df)

"""---

# Reusable category classification framework
"""

from typing import List

class CategoryClassifier:
    """Reusable framework for binary category classification using weak supervision"""

    def __init__(self, category_name: str, ft_model, dataframe: pd.DataFrame):
        self.category_name = category_name
        self.ft_model = ft_model
        self.df = dataframe
        self.POSITIVE = 1
        self.NEGATIVE = 0
        self.ABSTAIN = -1

        # Will be set by subclasses
        self.anchors = []
        self.anchor_system = None
        self.labeling_functions = []
        self.L_matrix = None
        self.label_model = None
        self.results = {}

    def setup_anchors(self, anchors: List[str], similarity_threshold: float = 0.6):
        """Setup FastText anchor system"""
        self.anchors = anchors
        self.anchor_system = FastTextAnchorSystem(
            self.ft_model, anchors, similarity_threshold
        )

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """To be implemented by each category subclass"""
        raise NotImplementedError("Each category must implement its own LFs")

    def apply_labeling_functions(self):
        """Apply labeling functions and analyze"""
        self.labeling_functions = self.create_labeling_functions()

        applier = PandasLFApplier(lfs=self.labeling_functions)
        self.L_matrix = applier.apply(self.df)

        # Analyze LF performance
        lf_analysis = LFAnalysis(L=self.L_matrix, lfs=self.labeling_functions)
        print(f"\n{self.category_name} LF Analysis:")
        print(lf_analysis.lf_summary())

        return self.L_matrix

    def train_label_model(self, n_epochs: int = 500):
        """Train Snorkel label model"""
        if self.L_matrix is None:
            raise ValueError("Must apply labeling functions first")

        # Calculate class balance
        votes = self.L_matrix[self.L_matrix != -1]
        if len(votes) == 0:
            class_balance = np.array([0.5, 0.5])
        else:
            pos_ratio = np.sum(votes == 1) / len(votes)
            pos_ratio = max(0.01, min(0.99, pos_ratio))  # Smoothing
            class_balance = np.array([1 - pos_ratio, pos_ratio])

        print(f"{self.category_name} class balance: {class_balance}")

        # Train model
        self.label_model = LabelModel(cardinality=2, verbose=True)
        self.label_model.fit(
            L_train=self.L_matrix,
            n_epochs=n_epochs,
            log_freq=100,
            seed=42,
            class_balance=class_balance
        )

    def get_predictions(self, confidence_threshold: float = 0.8):
        """Get predictions and add to dataframe"""
        if self.label_model is None:
            raise ValueError("Must train label model first")

        probs = self.label_model.predict_proba(L=self.L_matrix)
        predictions = self.label_model.predict(L=self.L_matrix)

        # Add to dataframe
        label_col = f'is_{self.category_name.lower()}_weak_label'
        confidence_col = f'{self.category_name.lower()}_confidence'

        self.df[label_col] = predictions
        self.df[confidence_col] = probs[:, 1] if probs.shape[1] > 1 else probs[:, 0]

        # Get high confidence results
        high_confidence = self.df[
            (self.df[label_col] == self.POSITIVE) &
            (self.df[confidence_col] > confidence_threshold)
        ]

        # Store results
        self.results = {
            'total_transactions': len(self.df),
            'predicted_positive': (self.df[label_col] == self.POSITIVE).sum(),
            'high_confidence_positive': len(high_confidence),
            'abstentions': (self.df[label_col] == self.ABSTAIN).sum(),
            'high_confidence_examples': high_confidence
        }

        return self.results

    def run_full_pipeline(self, confidence_threshold: float = 0.8):
        """Run the complete pipeline"""
        print(f"\n=== Running {self.category_name} Classification Pipeline ===")

        # 1. Apply LFs
        self.apply_labeling_functions()

        # 2. Train label model
        self.train_label_model()

        # 3. Get predictions
        results = self.get_predictions(confidence_threshold)

        # 4. Print summary
        print(f"\n{self.category_name} Classification Results:")
        print(f"Total transactions: {results['total_transactions']}")
        print(f"Predicted as {self.category_name.lower()}: {results['predicted_positive']}")
        print(f"High confidence: {results['high_confidence_positive']}")

        if len(results['high_confidence_examples']) > 0:
            print(f"\nHigh confidence {self.category_name.lower()} examples:")
            display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', f'{self.category_name.lower()}_confidence']
            print(results['high_confidence_examples'][display_cols].head())

        return results

# Reusable FastText Anchor System
class FastTextAnchorSystem:
    def __init__(self, ft_model, anchors: list, similarity_threshold: float = 0.5):
        self.ft = ft_model
        self.anchors = anchors
        self.similarity_threshold = similarity_threshold
        self.expanded_anchors = self._expand_anchors()

    def _expand_anchors(self, n_similar: int = 20):
        expanded_words = set(self.anchors)
        for word in self.anchors:
            try:
                similar_words = self.ft.get_nearest_neighbors(word, k=n_similar)
                for sim_score, sim_word in similar_words:
                    if sim_score >= self.similarity_threshold:
                        expanded_words.add(sim_word)
            except:
                continue
        print(f"Anchors expanded from {len(self.anchors)} to {len(expanded_words)} words")
        print(expanded_words)
        return expanded_words

    def get_text_similarity(self, text: str) -> float:
        if not text:
            return 0.0
        try:
            text_vec = self.ft.get_sentence_vector(text)
            similarities = []
            for anchor_word in self.expanded_anchors:
                try:
                    anchor_vec = self.ft.get_word_vector(anchor_word)
                    sim = np.dot(text_vec, anchor_vec) / (np.linalg.norm(text_vec) * np.linalg.norm(anchor_vec))
                    similarities.append(sim)
                except:
                    continue
            return max(similarities) if similarities else 0.0
        except:
            return 0.0

"""# Benefits

## Unemployment
"""

class UnemploymentBenefitsClassifier(CategoryClassifier):
    """Unemployment benefits classifier"""

    def __init__(self, ft_model, dataframe: pd.DataFrame):
        super().__init__("UnemploymentBenefits", ft_model, dataframe)


    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create unemployment-specific labeling functions"""

        def lf_unemployment_explicit(x):
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN
            text_lower = x.CLEANED_TEXT.lower()
            unemployment_terms = [
                "france travail", "pole emploi", "ARE", "CSP", "ASS"
            ]
            if any(term in text_lower for term in unemployment_terms):
                return self.POSITIVE
            return self.NEGATIVE

        def lf_unemployment_monthly_pattern(x):
            # Unemployment benefits are typically regular, monthly, moderate amounts
            if (28 <= x.mean_delta_days <= 32 and x.amt_mean <= 5000):
                return self.POSITIVE
            return self.ABSTAIN

        def lf_unemployment_lumpsum_pattern(x):
            # Unemployment benefits can be in lumpsum if with ACRE and high amounts
            if (x.amt_mean > 5000):
                return self.POSITIVE
            return self.ABSTAIN


        return [
            LabelingFunction(name="lf_unemployment_explicit", f=lf_unemployment_explicit),
            LabelingFunction(name="lf_unemployment_monthly_pattern", f=lf_unemployment_monthly_pattern),
            LabelingFunction(name="lf_unemployment_lumpsum_pattern", f=lf_unemployment_lumpsum_pattern),
        ]

def extract_lf_results_to_excel(classifier, dataframe, filename="unemployment_lf_results.xlsx"):
    """Extract LF results per transaction group and export to Excel"""

    # Get the LF matrix
    L_matrix = classifier.L_matrix
    lf_names = [lf.name for lf in classifier.labeling_functions]

    # Create LF results DataFrame
    lf_results_df = pd.DataFrame(L_matrix, columns=lf_names)

    # Add original transaction data
    results_with_context = pd.concat([
        dataframe[['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'amt_cv']].reset_index(drop=True),
        lf_results_df
    ], axis=1)

    # Add final predictions if they exist
    label_col = f'is_{classifier.category_name.lower()}_weak_label'
    confidence_col = f'{classifier.category_name.lower()}_confidence'

    if label_col in dataframe.columns:
        results_with_context[label_col] = dataframe[label_col].values
        results_with_context[confidence_col] = dataframe[confidence_col].values

    # Add summary columns
    results_with_context['total_lf_votes'] = (L_matrix != -1).sum(axis=1)
    results_with_context['positive_lf_votes'] = (L_matrix == 1).sum(axis=1)
    results_with_context['negative_lf_votes'] = (L_matrix == 0).sum(axis=1)
    results_with_context['has_conflicts'] = [
        len(set(row[row != -1])) > 1 if len(row[row != -1]) > 1 else False
        for row in L_matrix
    ]

    # Create readable LF result columns
    for i, lf_name in enumerate(lf_names):
        results_with_context[f'{lf_name}_readable'] = results_with_context[lf_name].map({
            1: 'POSITIVE', 0: 'NEGATIVE', -1: 'ABSTAIN'
        })

    # Export to Excel with multiple sheets
    with pd.ExcelWriter(filename, engine='openpyxl') as writer:
        # Sheet 1: All results
        results_with_context.to_excel(writer, sheet_name='All_Results', index=False)

        # Sheet 2: Only transactions where LFs fired
        active_results = results_with_context[results_with_context['total_lf_votes'] > 0]
        active_results.to_excel(writer, sheet_name='Active_LFs', index=False)

        # Sheet 3: Only positive predictions
        if label_col in results_with_context.columns:
            positive_results = results_with_context[results_with_context[label_col] == 1]
            if len(positive_results) > 0:
                positive_results.to_excel(writer, sheet_name='Positive_Predictions', index=False)

        # Sheet 4: Conflicts
        conflicts = results_with_context[results_with_context['has_conflicts']]
        if len(conflicts) > 0:
            conflicts.to_excel(writer, sheet_name='Conflicts', index=False)

        # Sheet 5: LF Summary Statistics
        lf_summary = create_lf_summary(L_matrix, lf_names, dataframe)
        lf_summary.to_excel(writer, sheet_name='LF_Summary', index=False)

    print(f"Results exported to {filename}")
    return results_with_context

def create_lf_summary(L_matrix, lf_names, dataframe):
    """Create summary statistics for each LF"""
    summary_data = []

    for i, lf_name in enumerate(lf_names):
        lf_votes = L_matrix[:, i]

        positive_votes = np.sum(lf_votes == 1)
        negative_votes = np.sum(lf_votes == 0)
        abstentions = np.sum(lf_votes == -1)
        total_votes = positive_votes + negative_votes
        coverage = total_votes / len(lf_votes) if len(lf_votes) > 0 else 0

        summary_data.append({
            'LF_Name': lf_name,
            'Positive_Votes': positive_votes,
            'Negative_Votes': negative_votes,
            'Abstentions': abstentions,
            'Total_Votes': total_votes,
            'Coverage': coverage,
            'Positive_Rate': positive_votes / total_votes if total_votes > 0 else 0
        })

    return pd.DataFrame(summary_data)

# Usage after running your classifier
unemployment_classifier = UnemploymentBenefitsClassifier(ft, merchant_agg_df)
unemployment_results = unemployment_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export LF results to Excel
results_df = extract_lf_results_to_excel(
    unemployment_classifier,
    merchant_agg_df,
    "unemployment_lf_detailed_results.xlsx"
)

"""## Social"""

import re

class SocialBenefitsClassifier(CategoryClassifier):
    """Social benefits classifier"""

    def __init__(self, ft_model, dataframe: pd.DataFrame):
        super().__init__("SocialBenefits", ft_model, dataframe)


    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create social-specific labeling functions"""

        def lf_social_explicit(x):
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN
            text_lower = x.CLEANED_TEXT.lower()
            social_terms = [
                "caf", "rsa", "prime d'activite", "allocations familiales", "paje", "cmg",
                "ars", "asf", "aeeh", "ajpp", "apl", "alf", "als", "cheque energie", "bourse"
            ]
            for term in social_terms:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    return self.POSITIVE
            return self.NEGATIVE


        def lf_social_monthly_pattern(x):
            # Unemployment benefits are typically regular, monthly, moderate amounts
            if (28 <= x.mean_delta_days <= 32 and x.amt_mean <= 1000):
                return self.POSITIVE
            return self.ABSTAIN

        def lf_social_min_pattern(x):
            text_lower = x.CLEANED_TEXT.lower()
            social_terms = [
               "Allocations familiales"
            ]
            if any(term in text_lower for term in social_terms):
                self.ABSTAIN
            elif (x.amt_mean > 100):
                return self.POSITIVE
            return self.NEGATIVE


        return [
            LabelingFunction(name="lf_social_explicit", f=lf_social_explicit),
            LabelingFunction(name="lf_social_monthly_pattern", f=lf_social_monthly_pattern),
            LabelingFunction(name="lf_social_min_pattern", f=lf_social_min_pattern),
        ]

# Usage after running your classifier
social_classifier = SocialBenefitsClassifier(ft, merchant_agg_df)
social_results = social_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export LF results to Excel
results_df = extract_lf_results_to_excel(
    social_classifier,
    merchant_agg_df,
    "social_lf_detailed_results.xlsx"
)

"""# Pension

Covered in the 3rd version of the Salary section

# Investment income
"""

"""
Investment Income Classifier using the reusable CategoryClassifier framework
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class InvestmentIncomeClassifier(CategoryClassifier):
    """Investment income classifier using weak supervision framework"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Investment", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_investment_thresholds()

        # Investment-specific anchor words for FastText expansion
        self.investment_anchor_terms = [
            "dividende", "interet", "coupon", "gain", "profit",
            "rachat", "fonds", "action", "obligation", "titre",
            "dividends", "interest", "dividend", "fund", "funds"
        ]

        # Comprehensive investment income terms organized by category
        self.investment_terms = {
            # Dividends
            "dividends": ["dividende", "dividendes", "div", "dividend", "dividends"],

            # Interest
            "interest": ["interet", "intérêt", "interets", "intérêts", "int", "interest",
                        "coupon", "coupons", "rendement", "yield"],

            # Capital gains
            "capital_gains": ["plus[- ]?value", "plus[- ]?values", "gain", "gains",
                             "capital", "profit", "benefice", "bénéfice"],

            # Fund operations
            "funds": ["opcr", "opcrachat", "rachat", "parts", "fonds", "fund", "funds",
                     "sicav", "fcpi", "scpi", "etf", "tracker"],

            # Investment platforms/brokers
            "brokers": ["degiro", "interactive brokers", "saxo", "binck", "boursorama",
                       "fortuneo", "credit agricole titres", "bnp paribas securities"],

            # Investment instruments
            "instruments": ["action", "actions", "obligation", "obligations", "titre",
                           "titres", "warrant", "warrants", "option", "options"]
        }

        # Flatten all terms for easy searching
        self.all_investment_terms = []
        for category_terms in self.investment_terms.values():
            self.all_investment_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.investment_anchor_terms, similarity_threshold=0.65)

    def _calculate_investment_thresholds(self) -> dict:
        """Calculate thresholds for investment income detection"""
        base_thresholds = {
            'min_amount': 10,        # Minimum per transaction
            'max_amount': 50000,     # Maximum reasonable
            'quarterly_min': 50,     # Minimum for quarterly patterns
            'annual_min': 100,       # Minimum for annual patterns
            'max_cv': 2.0,          # High CV tolerance (investment returns vary)
            'min_transactions': 1    # Single transactions can be investment income
        }

        # Adjust based on user's income level if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 25,
                    'quarterly_min': 200,
                    'annual_min': 500
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': 5,
                    'quarterly_min': 25,
                    'annual_min': 50
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create investment-specific labeling functions"""

        def lf_investment_explicit_terms(x):
            """Detect investment income based on explicit terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Check for explicit investment terms
            for term in self.all_investment_terms:
                if "?" in term or "[" in term:  # Handle regex patterns
                    if re.search(term, text_lower):
                        if x.amt_mean >= self.thresholds['min_amount']:
                            return self.POSITIVE
                else:
                    if re.search(rf"\b{re.escape(term)}\b", text_lower):
                        if x.amt_mean >= self.thresholds['min_amount']:
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_fasttext_similarity(x):
            """Detect investment income using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # High similarity with minimum amount
            if similarity >= 0.7 and x.amt_mean >= self.thresholds['min_amount']:
                return self.POSITIVE
            # Lower similarity but higher amount threshold
            elif similarity >= 0.6 and x.amt_mean >= self.thresholds['quarterly_min']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_quarterly_pattern(x):
            """Detect quarterly dividend patterns"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Quarterly pattern: ~90-95 days between payments
            is_quarterly = 85 <= x.mean_delta_days <= 100
            has_reasonable_amount = x.amt_mean >= self.thresholds['quarterly_min']
            moderate_consistency = x.amt_cv <= 0.5  # Dividends can vary

            if is_quarterly and has_reasonable_amount and moderate_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_annual_pattern(x):
            """Detect annual investment patterns"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Annual pattern: ~365 days
            is_annual = 350 <= x.mean_delta_days <= 380
            has_reasonable_amount = x.amt_mean >= self.thresholds['annual_min']
            is_consistent = x.amt_cv <= 0.3  # Annual payments more consistent

            if is_annual and has_reasonable_amount and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_semi_annual(x):
            """Detect semi-annual patterns (bonds, REITs)"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Semi-annual: ~180 days
            is_semi_annual = 170 <= x.mean_delta_days <= 190
            has_reasonable_amount = x.amt_mean >= self.thresholds['quarterly_min']

            if is_semi_annual and has_reasonable_amount:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_broker_source(x):
            """Detect payments from known investment brokers"""
            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            # Check both merchant name and transaction text
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Check for known investment brokers
            for broker in self.investment_terms["brokers"]:
                if broker in text_to_check:
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_amount_patterns(x):
            """Detect investment-like amount patterns"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            is_reasonable_amount = (
                self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']
            )

            # Not too regular (excludes salary) but not too irregular
            moderate_variability = 0.1 <= x.amt_cv <= self.thresholds['max_cv']

            # Check for "dividend-like" amounts (often round numbers)
            amount_str = str(int(x.amt_mean))
            ends_in_round = amount_str.endswith(('0', '5'))

            if is_reasonable_amount and moderate_variability:
                return self.POSITIVE
            elif is_reasonable_amount and ends_in_round and x.amt_count >= 2:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_investment_salary_like(x):
            """Negative LF: Very regular, large payments are likely salary"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            # Very regular patterns with large amounts
            is_very_regular = (
                (26 <= x.mean_delta_days <= 32) or  # Monthly
                (13 <= x.mean_delta_days <= 16) or  # Bi-weekly
                (6 <= x.mean_delta_days <= 8)       # Weekly
            )

            is_very_consistent = x.amt_cv < 0.1
            is_large_amount = x.amt_mean > 1000

            if is_very_regular and is_very_consistent and is_large_amount:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_investment_small_frequent(x):
            """Negative LF: Very small, frequent payments unlikely to be investment"""
            if x.amt_mean < 5 and x.amt_count > 10:
                return self.NEGATIVE
            return self.ABSTAIN

        # Return list of labeling functions
        return [
            LabelingFunction(name="lf_investment_explicit_terms", f=lf_investment_explicit_terms),
            LabelingFunction(name="lf_investment_fasttext_similarity", f=lf_investment_fasttext_similarity),
            LabelingFunction(name="lf_investment_quarterly_pattern", f=lf_investment_quarterly_pattern),
            LabelingFunction(name="lf_investment_annual_pattern", f=lf_investment_annual_pattern),
            LabelingFunction(name="lf_investment_semi_annual", f=lf_investment_semi_annual),
            LabelingFunction(name="lf_investment_broker_source", f=lf_investment_broker_source),
            LabelingFunction(name="lf_investment_amount_patterns", f=lf_investment_amount_patterns),
            LabelingFunction(name="lf_not_investment_salary_like", f=lf_not_investment_salary_like),
            LabelingFunction(name="lf_not_investment_small_frequent", f=lf_not_investment_small_frequent),
        ]


# Usage example
def create_investment_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run investment income classifier"""

    # Create classifier instance
    classifier = InvestmentIncomeClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Assuming you have ft_model, merchant_agg_df, and user_profile ready
investment_classifier, results = create_investment_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

# Access results
print(f"Investment income transactions found: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Access the updated dataframe with predictions
updated_df = investment_classifier.df
print(updated_df[['CLEANED_TEXT', 'is_investment_weak_label', 'investment_confidence']].head())
"""

# Usage after running your classifier
investment_classifier = InvestmentIncomeClassifier(ft, merchant_agg_df)
investment_results = investment_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export LF results to Excel
results_df = extract_lf_results_to_excel(
    investment_classifier,
    merchant_agg_df,
    "investment_lf_detailed_results.xlsx"
)

"""# Savings income"""

"""
Savings Income Classifier - Separate from Investment Income
Handles savings accounts, CDs, money market accounts, and other low-risk interest
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class SavingsIncomeClassifier(CategoryClassifier):
    """Savings income classifier for low-risk interest income"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Savings", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_savings_thresholds()

        # Savings-specific anchor words
        self.savings_anchor_terms = [
            "interet", "interest", "epargne", "savings", "livret",
            "compte", "deposit", "cd", "terme", "placement"
        ]

        # Savings-specific terms
        self.savings_terms = {
            # Savings accounts
            "savings_accounts": ["livret", "livret a", "ldds", "pel", "cel",
                               "savings", "epargne", "épargne"],

            # Interest terms
            "interest": ["interet", "intérêt", "interets", "intérêts",
                        "interest", "int", "rendement"],

            # Bank account types
            "account_types": ["compte", "account", "deposit", "depot", "dépôt"],

            # Time deposits
            "time_deposits": ["terme", "term", "cd", "certificat", "certificate",
                            "placement", "fixed"],

            # Money market
            "money_market": ["monetaire", "monétaire", "money market", "mmda"],

            # Specific French savings products
            "french_savings": ["livret a", "livret bleu", "livret jeune",
                             "livret developpement durable", "ldds", "pel", "cel"]
        }

        # Flatten terms
        self.all_savings_terms = []
        for category_terms in self.savings_terms.values():
            self.all_savings_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.savings_anchor_terms, similarity_threshold=0.7)

    def _calculate_savings_thresholds(self) -> dict:
        """Calculate thresholds for savings income detection"""
        base_thresholds = {
            'min_amount': 0.01,      # Can be very small (low interest rates)
            'max_amount': 5000,      # Usually not huge amounts
            'monthly_min': 0.50,     # Minimum for monthly patterns
            'quarterly_min': 1.50,   # Minimum for quarterly patterns
            'annual_min': 5.00,      # Minimum for annual patterns
            'max_cv': 0.3,          # Should be very consistent (unlike investments)
            'min_transactions': 2    # Need some regularity
        }

        # Adjust based on user's income/savings level
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 1.0,
                    'monthly_min': 5.0,
                    'quarterly_min': 15.0,
                    'annual_min': 50.0
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                # Keep very low thresholds for lower income
                pass

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create savings-specific labeling functions"""

        def lf_savings_explicit_terms(x):
            """Detect savings income based on explicit terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Check for explicit savings terms
            for term in self.all_savings_terms:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_fasttext_similarity(x):
            """Detect savings income using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher threshold for savings (more specific terms)
            if similarity >= 0.75 and x.amt_mean >= self.thresholds['min_amount']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_monthly_regular(x):
            """Detect monthly savings interest (most common pattern)"""
            if x.amt_mean <= 0 or x.amt_count < 3:  # Need several occurrences
                return self.ABSTAIN

            # Monthly pattern: 28-32 days
            is_monthly = 28 <= x.mean_delta_days <= 32
            has_reasonable_amount = x.amt_mean >= self.thresholds['monthly_min']
            is_very_consistent = x.amt_cv <= self.thresholds['max_cv']  # Savings very consistent

            if is_monthly and has_reasonable_amount and is_very_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_quarterly_regular(x):
            """Detect quarterly savings interest"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Quarterly: 88-95 days
            is_quarterly = 88 <= x.mean_delta_days <= 95
            has_reasonable_amount = x.amt_mean >= self.thresholds['quarterly_min']
            is_very_consistent = x.amt_cv <= self.thresholds['max_cv']

            if is_quarterly and has_reasonable_amount and is_very_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_annual_regular(x):
            """Detect annual savings interest (CDs, etc.)"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Annual: 360-370 days
            is_annual = 360 <= x.mean_delta_days <= 370
            has_reasonable_amount = x.amt_mean >= self.thresholds['annual_min']
            is_very_consistent = x.amt_cv <= self.thresholds['max_cv']

            if is_annual and has_reasonable_amount and is_very_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_bank_context(x):
            """Detect savings based on bank context"""
            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            # Common bank names with savings context
            bank_indicators = [
                "credit agricole", "bnp", "societe generale", "lcl",
                "caisse epargne", "banque populaire", "credit mutuel",
                "hsbc", "ing", "boursorama", "fortuneo"
            ]

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Look for bank + savings context
            has_bank = any(bank in text_to_check for bank in bank_indicators)
            has_savings_context = any(term in text_to_check for term in
                                    ["interet", "interest", "epargne", "livret", "placement"])

            if has_bank and has_savings_context and x.amt_mean >= self.thresholds['min_amount']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_small_regular_amounts(x):
            """Detect characteristic small, very regular amounts"""
            if x.amt_mean <= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Small amounts (typical of current low interest rates)
            is_small_amount = self.thresholds['min_amount'] <= x.amt_mean <= 100

            # Very regular (monthly or quarterly)
            is_regular = (
                (28 <= x.mean_delta_days <= 32) or  # Monthly
                (88 <= x.mean_delta_days <= 95)     # Quarterly
            )

            # Very consistent (savings interest is predictable)
            is_very_consistent = x.amt_cv <= 0.2

            if is_small_amount and is_regular and is_very_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_savings_investment_like(x):
            """Negative LF: Variable amounts are more likely investments"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            # High variability suggests investments, not savings
            is_highly_variable = x.amt_cv > 1.0

            # Large amounts with high variability are likely investment returns
            is_large_and_variable = x.amt_mean > 500 and x.amt_cv > 0.5

            if is_highly_variable or is_large_and_variable:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_savings_one_time(x):
            """Negative LF: One-time large payments unlikely to be savings"""
            if x.amt_count == 1 and x.amt_mean > 1000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_savings_naf_codes(x):
            """NAF codes that correspond to banks and financial institutions offering savings"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # NAF codes for banks, credit institutions, and financial services
            savings_naf_codes = [
                "64.1", "64.11", "64.11Z",  # Central banking, monetary institutions
                "64.19", "64.19Z",          # Other monetary intermediation
                "64.2", "64.20", "64.20Z",  # Activities of holding companies
                "64.9", "64.91", "64.91Z",  # Financial leasing
                "64.92", "64.92Z",          # Other credit granting
                "64.99", "64.99Z",          # Other financial service activities
                "65.1", "65.11", "65.11Z",  # Life insurance
                "65.12", "65.12Z",          # Non-life insurance
                "66.1", "66.11", "66.11Z",  # Administration of financial markets
                "66.12", "66.12Z",          # Security and commodity contracts brokerage
                "66.19", "66.19Z",          # Other activities auxiliary to financial services
                "66.2", "66.21", "66.21Z",  # Risk and damage evaluation
                "66.22", "66.22Z",          # Activities of insurance agents and brokers
                "66.29", "66.29Z",          # Other activities auxiliary to insurance and pension funding
                "66.3", "66.30", "66.30Z",  # Fund management activities
            ]

            if str(x.NAF_CODE).strip() in savings_naf_codes:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_savings_bank_merchants(x):
            """Known banks and financial institutions that offer savings products"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Major banks and financial institutions (focusing on traditional banks)
            savings_merchants = [
                # French banks
                "BNP Paribas", "Crédit Agricole", "Société Générale", "Crédit Mutuel",
                "Banque Populaire", "Caisse d'Épargne", "LCL", "La Banque Postale",
                "Crédit Coopératif", "Banque Palatine", "CIC", "Crédit du Nord",

                # European banks
                "ING", "Deutsche Bank", "Commerzbank", "UniCredit", "Intesa Sanpaolo",
                "Santander", "BBVA", "ABN AMRO", "Rabobank", "KBC", "Belfius",
                "Erste Group", "Raiffeisen", "Nordea", "Danske Bank", "SEB",
                "Swedbank", "DNB", "SpareBank", "Handelsbanken",

                # UK banks
                "Barclays", "HSBC", "Lloyds", "Royal Bank of Scotland", "NatWest",
                "TSB", "Metro Bank", "Santander UK", "First Direct", "Halifax",
                "Bank of Scotland", "Nationwide",

                # US banks
                "JPMorgan Chase", "Bank of America", "Wells Fargo", "Citigroup",
                "Goldman Sachs", "Morgan Stanley", "US Bank", "PNC Bank",
                "Capital One", "TD Bank", "BB&T", "SunTrust", "Regions Bank",

                # Online/digital banks known for savings
                "Marcus", "Ally Bank", "American Express Bank", "Discover Bank",
                "Capital One 360", "CIT Bank", "Synchrony Bank", "Barclays US",
                "HSBC Direct", "ING Direct", "Boursorama", "Fortuneo", "Hello Bank",
                "N26", "Revolut", "Monzo", "Starling Bank",

                # Credit unions and savings institutions
                "Navy Federal", "USAA", "Pentagon Federal", "Alliant Credit Union",
                "American Express", "Vanguard", "Fidelity", "Charles Schwab"
            ]

            # Check for exact match first
            if merchant_text in savings_merchants:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE

            # Check for partial matches (case-insensitive)
            merchant_lower = merchant_text.lower()
            for bank in savings_merchants:
                if bank.lower() in merchant_lower or merchant_lower in bank.lower():
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_savings_explicit_terms", f=lf_savings_explicit_terms),
            LabelingFunction(name="lf_savings_fasttext_similarity", f=lf_savings_fasttext_similarity),
            LabelingFunction(name="lf_savings_monthly_regular", f=lf_savings_monthly_regular),
            LabelingFunction(name="lf_savings_quarterly_regular", f=lf_savings_quarterly_regular),
            LabelingFunction(name="lf_savings_annual_regular", f=lf_savings_annual_regular),
            LabelingFunction(name="lf_savings_bank_context", f=lf_savings_bank_context),
            LabelingFunction(name="lf_savings_small_regular_amounts", f=lf_savings_small_regular_amounts),
            LabelingFunction(name="lf_savings_naf_codes", f=lf_savings_naf_codes),
            LabelingFunction(name="lf_savings_bank_merchants", f=lf_savings_bank_merchants),
            LabelingFunction(name="lf_not_savings_investment_like", f=lf_not_savings_investment_like),
            LabelingFunction(name="lf_not_savings_one_time", f=lf_not_savings_one_time),
        ]


# Updated Investment Income Classifier (adjusted to exclude savings-like patterns)
class InvestmentIncomeClassifier(CategoryClassifier):
    """Investment income classifier - excludes savings income"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Investment", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_investment_thresholds()

        # Investment-specific anchors (excluding savings terms)
        self.investment_anchor_terms = [
            "dividende", "dividend", "gain", "profit", "capital",
            "rachat", "fonds", "action", "obligation", "opcr"  # Removed generic "interet"
        ]

        # Investment terms (more focused, excluding savings overlap)
        self.investment_terms = {
            # Dividends (clear investment signal)
            "dividends": ["dividende", "dividendes", "div", "dividend", "dividends"],

            # Capital gains (clear investment signal)
            "capital_gains": ["plus[- ]?value", "plus[- ]?values", "gain", "gains",
                             "capital", "profit", "benefice", "bénéfice"],

            # Fund operations (clear investment signal)
            "funds": ["opcr", "opcrachat", "rachat", "parts", "fonds", "fund", "funds",
                     "sicav", "fcpi", "scpi", "etf", "tracker"],

            # Investment platforms/brokers
            "brokers": ["degiro", "interactive brokers", "saxo", "binck",
                       "credit agricole titres", "bnp paribas securities"],

            # Investment instruments
            "instruments": ["action", "actions", "obligation", "obligations",
                           "warrant", "warrants", "option", "options"]
        }

        self.all_investment_terms = []
        for category_terms in self.investment_terms.values():
            self.all_investment_terms.extend(category_terms)

        self.setup_anchors(self.investment_anchor_terms, similarity_threshold=0.65)

    def _calculate_investment_thresholds(self) -> dict:
        """Calculate thresholds for investment income - adjusted to exclude savings"""
        base_thresholds = {
            'min_amount': 25,        # Higher minimum (exclude small savings interest)
            'max_amount': 50000,
            'quarterly_min': 50,
            'annual_min': 100,
            'max_cv': 2.0,          # High CV tolerance
            'min_cv': 0.3,          # NEW: Minimum CV to exclude very regular savings
        }

        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 50,    # Even higher for wealthy users
                    'quarterly_min': 200,
                    'annual_min': 500
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Investment LFs - updated to exclude savings patterns"""

        def lf_investment_explicit_terms(x):
            """Detect investment income - excluding generic interest terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            for term in self.all_investment_terms:
                if "?" in term or "[" in term:
                    if re.search(term, text_lower):
                        if x.amt_mean >= self.thresholds['min_amount']:
                            return self.POSITIVE
                else:
                    if re.search(rf"\b{re.escape(term)}\b", text_lower):
                        if x.amt_mean >= self.thresholds['min_amount']:
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_variable_amounts(x):
            """Detect investment income by amount variability (vs savings consistency)"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Investment returns are typically more variable than savings
            has_reasonable_amount = x.amt_mean >= self.thresholds['min_amount']
            has_investment_variability = x.amt_cv >= self.thresholds['min_cv']  # Not too regular
            not_too_variable = x.amt_cv <= self.thresholds['max_cv']  # But not chaotic

            if has_reasonable_amount and has_investment_variability and not_too_variable:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_investment_savings_like(x):
            """Negative LF: Very regular, small amounts are likely savings"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            # Small, very regular amounts with low variability = likely savings
            is_small = x.amt_mean < 50
            is_very_regular = (
                (28 <= x.mean_delta_days <= 32) or  # Monthly
                (88 <= x.mean_delta_days <= 95)     # Quarterly
            )
            is_very_consistent = x.amt_cv <= 0.2

            if is_small and is_very_regular and is_very_consistent:
                return self.NEGATIVE

            return self.ABSTAIN
        def lf_investment_naf_codes(x):
            """NAF codes for investment management, brokerage, and fund companies"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # NAF codes for investment services, fund management, brokerage
            investment_naf_codes = [
                "66.12", "66.12Z",          # Security and commodity contracts brokerage
                "66.19", "66.19Z",          # Other activities auxiliary to financial services
                "66.30", "66.30Z",          # Fund management activities
                "64.91", "64.91Z",          # Financial leasing
                "64.99", "64.99Z",          # Other financial service activities (investment-related)
                "70.10", "70.10Z",          # Activities of head offices (holding companies)
                "70.22", "70.22Z",          # Business and other management consultancy activities
                "82.99", "82.99Z",          # Other business support service activities
                "68.10", "68.10Z",          # Buying and selling of own real estate (REITs)
                "68.20", "68.20Z",          # Renting and operating of own or leased real estate
                "77.40", "77.40Z",          # Leasing of intellectual property (IP investments)
                "01.61Z", "01.62Z",         # Support activities for crop production (agricultural funds)
                "46.15Z",                   # Agents involved in the sale of furniture and other goods
                "77.11Z",                   # Rental of cars and light motor vehicles (vehicle funds)
            ]

            if str(x.NAF_CODE).strip() in investment_naf_codes:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_investment_broker_merchants(x):
            """Known investment brokers, fund companies, and investment platforms"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Investment brokers, fund companies, and platforms
            investment_merchants = [
                # Major brokers/platforms
                "Degiro", "Interactive Brokers", "Saxo Bank", "eToro", "Plus500",
                "Trading 212", "Freetrade", "Robinhood", "E*TRADE", "TD Ameritrade",
                "Charles Schwab", "Fidelity", "Vanguard", "Merrill Lynch", "Morgan Stanley",
                "Goldman Sachs", "J.P. Morgan", "UBS", "Credit Suisse", "Deutsche Bank Securities",

                # French brokers/banks with securities services
                "Boursorama Securities", "Fortuneo Securities", "BNP Paribas Securities",
                "Crédit Agricole Titres", "Société Générale Securities", "Binck Bank",
                "Bourse Direct", "Lynx Broker", "IG Markets", "CMC Markets",

                # Fund management companies
                "BlackRock", "Vanguard Group", "State Street", "Fidelity Investments",
                "Capital Group", "T. Rowe Price", "Franklin Templeton", "Invesco",
                "Amundi", "AXA Investment Managers", "BNP Paribas Asset Management",
                "Natixis Investment Managers", "Carmignac", "Lazard Asset Management",

                # European investment firms
                "Lyxor Asset Management", "BNPP AM", "CPR Asset Management",
                "Ostrum Asset Management", "Edmond de Rothschild Asset Management",
                "La Française Asset Management", "Tikehau Investment Management",

                # Robo-advisors and digital investment platforms
                "Betterment", "Wealthfront", "Acorns", "Stash", "M1 Finance",
                "Wealthsimple", "Nutmeg", "Moneyfarm", "Scalable Capital", "Trade Republic",
                "Yomoni", "Nalo", "WeSave", "Advize", "Linxea",

                # Alternative investment platforms
                "YieldStreet", "Fundrise", "RealtyMogul", "CrowdStreet", "EquityMultiple",
                "AngelList", "SeedInvest", "StartEngine", "Republic", "Crowdcube",

                # Crypto/digital asset platforms (that may distribute gains)
                "Coinbase", "Binance", "Kraken", "Bitpanda", "Bitstamp", "Gemini",
                "BlockFi", "Celsius", "Nexo", "Crypto.com", "Paymium", "Bitit"
            ]

            # Check for exact match first
            if merchant_text in investment_merchants:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE

            # Check for partial matches (case-insensitive)
            merchant_lower = merchant_text.lower()
            for broker in investment_merchants:
                if broker.lower() in merchant_lower or merchant_lower in broker.lower():
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        # Include other investment LFs from previous version...
        # (quarterly patterns, broker detection, etc.)

        return [
            LabelingFunction(name="lf_investment_explicit_terms", f=lf_investment_explicit_terms),
            LabelingFunction(name="lf_investment_variable_amounts", f=lf_investment_variable_amounts),
            LabelingFunction(name="lf_investment_naf_codes", f=lf_investment_naf_codes),
            LabelingFunction(name="lf_investment_broker_merchants", f=lf_investment_broker_merchants),
            LabelingFunction(name="lf_not_investment_savings_like", f=lf_not_investment_savings_like),
            # Add other LFs...
        ]


# Usage Example
def create_comprehensive_income_classifiers(ft_model, merchant_agg_df, user_profile=None):
    """Create both savings and investment classifiers"""

    # Create savings classifier
    savings_classifier = SavingsIncomeClassifier(ft_model, merchant_agg_df.copy(), user_profile)
    savings_results = savings_classifier.run_full_pipeline(confidence_threshold=0.8)

    # Create investment classifier
    investment_classifier = InvestmentIncomeClassifier(ft_model, merchant_agg_df.copy(), user_profile)
    investment_results = investment_classifier.run_full_pipeline(confidence_threshold=0.7)

    return {
        'savings': {'classifier': savings_classifier, 'results': savings_results},
        'investment': {'classifier': investment_classifier, 'results': investment_results}
    }

# Example usage:
"""
classifiers = create_comprehensive_income_classifiers(ft, merchant_agg_df, user_profile)

print("Savings Income:", classifiers['savings']['results']['predicted_positive'])
print("Investment Income:", classifiers['investment']['results']['predicted_positive'])

# Access dataframes with predictions
savings_df = classifiers['savings']['classifier'].df
investment_df = classifiers['investment']['classifier'].df
"""

# =============================================================================
# OPTION 1: Run Classifiers Separately
# =============================================================================

# 1A. Savings Income Classifier
print("=== SAVINGS INCOME CLASSIFICATION ===")
savings_classifier = SavingsIncomeClassifier(ft, merchant_agg_df, user_profile)
savings_results = savings_classifier.run_full_pipeline(confidence_threshold=0.8)

# Export savings LF results to Excel
savings_results_df = extract_lf_results_to_excel(
    savings_classifier,
    merchant_agg_df,
    "savings_lf_detailed_results.xlsx"
)

print(f"Savings Income Results:")
print(f"- Total predicted: {savings_results['predicted_positive']}")
print(f"- High confidence: {savings_results['high_confidence_positive']}")

# 1B. Investment Income Classifier
print("\n=== INVESTMENT INCOME CLASSIFICATION ===")
investment_classifier = InvestmentIncomeClassifier(ft, merchant_agg_df, user_profile)
investment_results = investment_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export investment LF results to Excel
investment_results_df = extract_lf_results_to_excel(
    investment_classifier,
    merchant_agg_df,
    "investment_lf_detailed_results.xlsx"
)

print(f"Investment Income Results:")
print(f"- Total predicted: {investment_results['predicted_positive']}")
print(f"- High confidence: {investment_results['high_confidence_positive']}")

"""# Exceptionnal income

- Variable
- Other

"""

"""
Exceptional Income Classifier - Handles irregular, one-time, or infrequent income
This includes bonuses, winnings, inheritance, gifts, refunds, legal settlements, etc.
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class ExceptionalIncomeClassifier(CategoryClassifier):
    """Exceptional income classifier for irregular, one-time, or infrequent income"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Exceptional", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_exceptional_thresholds()

        # Exceptional income anchor words
        self.exceptional_anchor_terms = [
            "bonus", "prime", "gift", "cadeau", "remboursement", "refund",
            "win", "gain", "lot", "heritage", "inheritance", "settlement"
        ]

        # Exceptional income terms organized by category
        self.exceptional_terms = {
            # Bonuses and rewards
            "bonuses": ["bonus", "prime", "primes", "gratification", "reward",
                       "récompense", "incentive", "commission", "commissions"],

            # Winnings and gambling
            "winnings": ["gain", "gains", "win", "wins", "lot", "lots", "lottery",
                        "loterie", "casino", "bet", "paris", "pari", "jackpot",
                        "prize", "prix", "concours", "contest", "sweepstake"],

            # Gifts and inheritance
            "gifts": ["gift", "gifts", "cadeau", "cadeaux", "don", "dons", "donation",
                     "heritage", "héritage", "inheritance", "legacy", "succession",
                     "testament", "will"],

            # Refunds and reimbursements
            "refunds": ["refund", "refunds", "remboursement", "remboursements",
                       "rembourse", "restitution", "credit", "crédit", "avoir",
                       "retour", "return", "chargeback"],

            # Legal and insurance settlements
            "settlements": ["settlement", "settlements", "indemnité", "indemnités",
                           "indemnisation", "compensation", "dommages", "damages",
                           "assurance", "insurance", "sinistre", "claim"],

            # Government payments (one-time)
            "government": ["allocation", "allocations", "aide", "aides", "subvention",
                          "grant", "grants", "subsidy", "subsidies", "tax credit",
                          "crédit impot", "stimulus", "covid", "pandemic"],

            # Sale proceeds (one-time)
            "sales": ["vente", "sale", "proceeds", "produit", "cession", "disposal",
                     "liquidation", "sold", "vendu"],

            # Freelance/consulting (irregular)
            "freelance": ["freelance", "consulting", "consultant", "prestation",
                         "honoraires", "fees", "project", "projet", "mission",
                         "contract", "contrat", "gig"],

            # Royalties and licensing
            "royalties": ["royalty", "royalties", "redevance", "redevances",
                         "licence", "license", "copyright", "patent", "brevet",
                         "intellectual property", "propriété intellectuelle"]
        }

        # Flatten terms
        self.all_exceptional_terms = []
        for category_terms in self.exceptional_terms.values():
            self.all_exceptional_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.exceptional_anchor_terms, similarity_threshold=0.65)

    def _calculate_exceptional_thresholds(self) -> dict:
        """Calculate thresholds for exceptional income detection"""
        base_thresholds = {
            'min_amount': 50,           # Higher minimum (exceptional should be meaningful)
            'max_amount': 1000000,      # Very high ceiling (inheritance, lottery, etc.)
            'large_amount': 1000,       # Threshold for "large" exceptional income
            'very_large_amount': 10000, # Threshold for "very large" exceptional income
            'max_frequency': 6,         # Maximum transactions per year to be "exceptional"
            'max_cv': 5.0,             # Very high CV tolerance (highly irregular)
            'min_days_between': 60,     # Minimum days between transactions to be irregular
        }

        # Adjust based on user's income level
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 200,          # Higher minimum for wealthy users
                    'large_amount': 2000,
                    'very_large_amount': 20000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': 25,           # Lower minimum for lower income
                    'large_amount': 500,
                    'very_large_amount': 5000
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create exceptional income-specific labeling functions"""

        def lf_exceptional_explicit_terms(x):
            """Detect exceptional income based on explicit terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Check for explicit exceptional income terms
            for term in self.all_exceptional_terms:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_exceptional_fasttext_similarity(x):
            """Detect exceptional income using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher similarity threshold for exceptional income
            if similarity >= 0.7 and x.amt_mean >= self.thresholds['min_amount']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_exceptional_large_infrequent(x):
            """Detect large, infrequent amounts (classic exceptional pattern)"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            # Large amounts that occur infrequently
            is_large = x.amt_mean >= self.thresholds['large_amount']
            is_infrequent = x.amt_count <= self.thresholds['max_frequency']
            has_gaps = x.mean_delta_days >= self.thresholds['min_days_between'] if x.amt_count > 1 else True

            if is_large and is_infrequent and has_gaps:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_exceptional_very_large_single(x):
            """Detect very large single payments (inheritance, lottery, etc.)"""
            if x.amt_count == 1 and x.amt_mean >= self.thresholds['very_large_amount']:
                return self.POSITIVE
            return self.ABSTAIN

        def lf_exceptional_bonus_timing(x):
            """Detect bonus-like timing patterns (end of year, quarterly)"""
            if x.amt_mean <= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Bonus patterns: annual (~365 days) or quarterly (~90 days) but irregular amounts
            is_annual_bonus = 350 <= x.mean_delta_days <= 380
            is_quarterly_bonus = 85 <= x.mean_delta_days <= 100

            # Bonuses often vary in amount (performance-based)
            has_variability = x.amt_cv >= 0.3
            is_meaningful_amount = x.amt_mean >= self.thresholds['min_amount']

            if (is_annual_bonus or is_quarterly_bonus) and has_variability and is_meaningful_amount:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_exceptional_naf_codes(x):
            """NAF codes associated with exceptional income sources"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # NAF codes for activities that might generate exceptional income
            exceptional_naf_codes = [
                "92.00Z",  # Gambling and betting activities
                "93.11Z",  # Operation of sports facilities
                "93.12Z",  # Activities of sport clubs
                "93.13Z",  # Fitness facilities
                "93.19Z",  # Other sports activities
                "90.01Z",  # Performing arts
                "90.02Z",  # Support activities to performing arts
                "90.03A",  # Artistic creation
                "90.03B",  # Other artistic creation
                "90.04Z",  # Operation of arts facilities
                "58.11Z",  # Book publishing
                "58.13Z",  # Publishing of newspapers
                "58.14Z",  # Publishing of journals and periodicals
                "59.11A",  # Motion picture production
                "59.11B",  # Motion picture post-production
                "59.11C",  # Motion picture distribution
                "59.13A",  # Distribution of motion pictures
                "59.13B",  # Edition and distribution of video recordings
                "59.14Z",  # Motion picture projection activities
                "60.10Z",  # Radio broadcasting
                "60.20A",  # Television programming and broadcasting
                "60.20B",  # Television programming and broadcasting
                "77.21Z",  # Renting and leasing of recreational goods
                "77.22Z",  # Renting of video tapes and disks
                "77.29Z",  # Renting and leasing of other consumer goods
                "68.31Z",  # Real estate agencies
                "68.32A",  # Administration of residential real estate
                "68.32B",  # Administration of non-residential real estate
                "77.40Z",  # Leasing of intellectual property
                "82.30Z",  # Organisation of conventions and trade shows
                "82.99Z",  # Other business support service activities
                "84.13Z",  # Regulation of and contribution to more efficient operation
                "88.99A",  # Other social work activities without accommodation n.e.c.
                "88.99B",  # Other social work activities without accommodation n.e.c.
                "94.12Z",  # Activities of professional membership organisations
                "94.99Z",  # Activities of other membership organisations n.e.c.
                "96.09Z"   # Other personal service activities n.e.c.
            ]

            if str(x.NAF_CODE).strip() in exceptional_naf_codes:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_exceptional_merchants(x):
            """Known merchants/sources of exceptional income"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Merchants associated with exceptional income
            exceptional_merchants = [
                # Lottery and gambling
                "Française des Jeux", "FDJ", "PMU", "Betclic", "Winamax", "PokerStars",
                "Unibet", "Bet365", "William Hill", "Ladbrokes", "Paddy Power",
                "DraftKings", "FanDuel", "BetMGM", "Caesars", "MGM", "Harrah's",

                # Government agencies (tax refunds, stimulus)
                "Trésor Public", "Direction Générale des Finances Publiques", "DGFIP",
                "IRS", "Internal Revenue Service", "HM Revenue", "HMRC", "CRA",
                "Canada Revenue Agency", "Centrelink", "Social Security Administration",

                # Insurance companies (settlements)
                "AXA", "Allianz", "Generali", "Aviva", "Zurich", "Swiss Re",
                "Munich Re", "State Farm", "Geico", "Progressive", "Allstate",
                "Farmers Insurance", "Liberty Mutual", "Travelers", "Chubb",

                # Legal/settlement services
                "PayPal Resolution", "Escrow", "Settlement Fund", "Class Action",
                "Legal Settlement", "Court Settlement", "Arbitration",

                # Auction houses and collectibles
                "Sotheby's", "Christie's", "Phillips", "Heritage Auctions",
                "eBay", "Catawiki", "Drouot", "Artcurial",

                # Royalty collection societies
                "SACEM", "ASCAP", "BMI", "SESAC", "PRS", "GEMA", "STIM",

                # Crowdfunding platforms
                "Kickstarter", "Indiegogo", "GoFundMe", "Patreon", "Tipeee",
                "Ulule", "KissKissBankBank", "Leetchi",

                # Patent/IP licensing
                "Patent Licensing", "IP Royalty", "Trademark Licensing",
                "Copyright Collective", "Licensing Corporation"
            ]

            # Check for exact match first
            if merchant_text in exceptional_merchants:
                if x.amt_mean >= self.thresholds['min_amount']:
                    return self.POSITIVE

            # Check for partial matches (case-insensitive)
            merchant_lower = merchant_text.lower()
            for merchant in exceptional_merchants:
                if merchant.lower() in merchant_lower or merchant_lower in merchant.lower():
                    if x.amt_mean >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_exceptional_high_variability(x):
            """Detect income with very high variability (irregular amounts)"""
            if x.amt_mean <= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Very high coefficient of variation suggests irregular/exceptional income
            has_high_variability = x.amt_cv >= 2.0
            is_meaningful_amount = x.amt_mean >= self.thresholds['min_amount']
            is_infrequent = x.amt_count <= self.thresholds['max_frequency']

            if has_high_variability and is_meaningful_amount and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_exceptional_regular_salary(x):
            """Negative LF: Regular salary-like patterns are not exceptional"""
            if x.amt_mean <= 0:
                return self.ABSTAIN

            # Very regular patterns are likely salary, not exceptional
            is_very_regular = (
                (26 <= x.mean_delta_days <= 32) or  # Monthly
                (13 <= x.mean_delta_days <= 16) or  # Bi-weekly
                (6 <= x.mean_delta_days <= 8)       # Weekly
            )

            is_consistent = x.amt_cv < 0.2
            is_frequent = x.amt_count > 6  # More than 6 times suggests regular income

            if is_very_regular and is_consistent and is_frequent:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_exceptional_small_regular(x):
            """Negative LF: Small, regular amounts are not exceptional"""
            if x.amt_mean < 20 and x.amt_count > 4 and x.amt_cv < 0.5:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_exceptional_explicit_terms", f=lf_exceptional_explicit_terms),
            LabelingFunction(name="lf_exceptional_fasttext_similarity", f=lf_exceptional_fasttext_similarity),
            LabelingFunction(name="lf_exceptional_large_infrequent", f=lf_exceptional_large_infrequent),
            LabelingFunction(name="lf_exceptional_very_large_single", f=lf_exceptional_very_large_single),
            LabelingFunction(name="lf_exceptional_bonus_timing", f=lf_exceptional_bonus_timing),
            LabelingFunction(name="lf_exceptional_naf_codes", f=lf_exceptional_naf_codes),
            LabelingFunction(name="lf_exceptional_merchants", f=lf_exceptional_merchants),
            LabelingFunction(name="lf_exceptional_high_variability", f=lf_exceptional_high_variability),
            LabelingFunction(name="lf_not_exceptional_regular_salary", f=lf_not_exceptional_regular_salary),
            LabelingFunction(name="lf_not_exceptional_small_regular", f=lf_not_exceptional_small_regular),
        ]


# Usage example
def create_exceptional_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run exceptional income classifier"""

    # Create classifier instance
    classifier = ExceptionalIncomeClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
exceptional_classifier, results = create_exceptional_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

print(f"Exceptional income transactions: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Export results
exceptional_excel = extract_lf_results_to_excel(
    exceptional_classifier, merchant_agg_df, "exceptional_lf_detailed_results.xlsx"
)
"""

# =============================================================================
# OPTION 1: Run Classifiers Separately
# =============================================================================

# 1A. Savings Income Classifier
print("=== SAVINGS INCOME CLASSIFICATION ===")
savings_classifier = SavingsIncomeClassifier(ft, merchant_agg_df, user_profile)
savings_results = savings_classifier.run_full_pipeline(confidence_threshold=0.8)

# Export savings LF results to Excel
savings_results_df = extract_lf_results_to_excel(
    savings_classifier,
    merchant_agg_df,
    "savings_lf_detailed_results.xlsx"
)

print(f"Savings Income Results:")
print(f"- Total predicted: {savings_results['predicted_positive']}")
print(f"- High confidence: {savings_results['high_confidence_positive']}")

# 1B. Investment Income Classifier
print("\n=== INVESTMENT INCOME CLASSIFICATION ===")
investment_classifier = InvestmentIncomeClassifier(ft, merchant_agg_df, user_profile)
investment_results = investment_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export investment LF results to Excel
investment_results_df = extract_lf_results_to_excel(
    investment_classifier,
    merchant_agg_df,
    "investment_lf_detailed_results.xlsx"
)

print(f"Investment Income Results:")
print(f"- Total predicted: {investment_results['predicted_positive']}")
print(f"- High confidence: {investment_results['high_confidence_positive']}")

# 1C. Exceptional Income Classifier
print("\n=== EXCEPTIONAL INCOME CLASSIFICATION ===")
exceptional_classifier = ExceptionalIncomeClassifier(ft, merchant_agg_df, user_profile)
exceptional_results = exceptional_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export exceptional LF results to Excel
exceptional_results_df = extract_lf_results_to_excel(
    exceptional_classifier,
    merchant_agg_df,
    "exceptional_lf_detailed_results.xlsx"
)

print(f"Exceptional Income Results:")
print(f"- Total predicted: {exceptional_results['predicted_positive']}")
print(f"- High confidence: {exceptional_results['high_confidence_positive']}")

"""# EXPENSES

# General expenses

## House expenses

### Groceries
"""

# Easy to maintain lists - put these at the top of your file or in a config
GROCERY_NAF_CODES = [
    "47.11Z", "47.19Z", "47.21Z", "47.22Z", "47.23Z",
    "47.24Z", "47.25Z", "47.29Z",
    # Add new codes here
]

GROCERY_MERCHANTS = [
    'carrefour', 'leclerc', 'auchan', 'intermarche', 'lidl',
    'monoprix', 'franprix', 'casino', 'super u', 'hyper u',
    # Add new merchants here
]

GROCERY_KEYWORDS = [
    'supermarche', 'hypermarche', 'epicerie', 'alimentation',
    'courses', 'market', 'grocery', 'supermarket',
    # Add new keywords here
]

# Then use them in your LFs
def lf_grocery_naf_codes(x):
    if pd.isna(x.NAF_CODE):
        return self.ABSTAIN
    return self.POSITIVE if str(x.NAF_CODE).strip() in GROCERY_NAF_CODES else self.ABSTAIN

class GroceriesClassifier(CategoryClassifier):
    """Groceries classifier with your specific NAF codes and merchant lists"""

    def __init__(self, ft_model, dataframe: pd.DataFrame):
        super().__init__("Groceries", ft_model, dataframe)

        # Setup text anchors
        grocery_anchors = [
            "supermarche", "alimentation", "courses", "epicerie",
            "hypermarche", "market", "grocery", "food"
        ]
        self.setup_anchors(grocery_anchors, similarity_threshold=0.6)

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create grocery-specific labeling functions"""

        def lf_grocery_naf_codes(x):
            """NAF codes that correspond to grocery/food businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Your complete NAF code list for groceries/food
            grocery_naf_codes = [
                "01.1", "01.11", "01.11Z", "01.12", "01.12Z", "01.13", "01.13Z",
                "01.14", "01.14Z", "01.16", "01.16Z", "01.19", "01.19Z", "01.2",
                "01.21", "01.21Z", "01.22", "01.22Z", "01.23", "01.23Z", "01.24",
                "01.24Z", "01.25", "01.25Z", "01.26", "01.26Z", "01.27", "01.27Z",
                "01.28", "01.28Z", "01.4", "01.41", "01.44", "01.44Z", "01.45",
                "01.45Z", "01.46", "01.46Z", "01.47", "01.47Z", "01.5", "01.50",
                "01.50Z", "02.3", "02.30", "02.30Z", "03", "03.11Z", "03.12",
                "03.12Z", "10.3", "10.31", "10.31Z", "10.39A", "10.39B", "10.4",
                "10.41", "10.41A", "10.41B", "10.42", "10.42Z", "10.5", "10.51",
                "10.51A", "10.89Z", "11.07", "47.11A", "47.11B", "47.11C", "47.11D",
                "47.11E", "47.11F", "47.19", "47.19A", "47.19B", "47.2", "47.21",
                "47.21Z", "47.22", "47.22Z", "47.23", "47.23Z", "47.24", "47.24Z",
                "47.29", "47.29Z", "47.78B", "47.78C", "47.79", "47.79Z", "47.8",
                "47.81", "47.81Z", "47.89", "47.89Z", "47.99", "47.99A"
            ]

            if str(x.NAF_CODE).strip() in grocery_naf_codes:
                return self.POSITIVE
            return self.ABSTAIN

        def lf_grocery_merchants(x):
            """Known grocery store merchants from your list"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Your complete merchant list (keeping original case for exact matching)
            grocery_merchants = [
                "A.S. Watson Group", "Aeon", "Ahold Delhaize", "Ajinomoto", "Albertsons",
                "Albertsons Companies", "Aldi Einkauf & oHG / Aldi International Services & oHG",
                "Alimentation Couche-Tard", "Almarai", "Anheuser-Busch InBev",
                "Anhui Gujing Distillery", "Arca Continental", "Archer Daniels Midland",
                "Asahi Group Holdings", "Asda Group", "Associated British Foods", "ATB-Market",
                "Avenue Supermarts", "Barry Callebaut", "BIM Birlesik Magazalar",
                "BIM Birleşik Mağazalar A.Ş.", "BJ's Wholesale Club", "BJ's Wholesale Club Holdings",
                "British American Tobacco", "Brown-Forman", "Bunge", "Campbell Soup", "Carlsberg",
                "Carrefour", "Casey's General Stores", "Casino Guichard-Perrachon", "Celsius Holdings",
                "Cencosud", "Centres Distributeurs E. Leclerc", "Charoen Pokphand Group",
                "China Mengniu Dairy", "China Resources Beer (Holdings)", "Chyuan Lien Enterprise Co/ PXMart",
                "CJ Cheiljedang", "CJ Corporation", "Co-operative Group", "Coca-Cola",
                "Coca-Cola Europacific Partners", "Coca-Cola HBC", "Coles Group", "Colruyt",
                "Colruyt Group", "Conad Consorzio Nazionale", "Conagra Brands", "Constellation Brands",
                "Coop Danmark VS", "Coop Group", "Coop Italia", "Coop Norge, the Group",
                "Costco Wholesale", "Costco Wholesale Corporation", "Couche Tard", "CP All",
                "CP Axtra", "Dairy Farm International Holdings", "Danone", "Demoulas Super Markets",
                "Diageo", "dion Corporation", "Dirk Rossmann", "Distribuidora Internacional de Alimentación",
                "dm-drogerie markt Verwaltungs-GmbH", "Dollar General", "Dollar General Corporation",
                "Dollar Tree", "Dollarama", "E-mart", "Edeka-Verbund", "EG Group", "Empire",
                "Empire Company", "Endeavour Group", "Esselunga", "Femsa", "FEMSA Comercio",
                "Foshan Haitian Flavouring and Food", "General Mills", "George Weston", "Giant Eagle",
                "Givaudan", "Glencore International", "Grupo Bimbo", "Grupo Comercial Chedraui",
                "Grupo Comercial Chedraui SAB de CV Class B", "Grupo Eroski", "Gruppo Eurospin",
                "Guangdong Haid Group", "H-E-B Grocery Company", "H20 Retailing Corporation",
                "Homeplus", "Hormel Foods", "Hy-Vee", "ICA Gruppen", "Ingles Markets", "Ingredion",
                "Inner Mongolia Yili", "J Sainsbury", "JBS", "JDE Peet's", "Jeronimo Martins",
                "Jerónimo Martins SGPS", "JM Smucker", "Kellanova", "Kerry Group", "Kesko",
                "Kesko Corporation", "Keurig Dr Pepper", "Koninklijke Jumbo Food Groep",
                "Kraft Heinz Company", "Kroger", "Lamb Weston Holdings", "Lawson", "Lenta Group",
                "Lindt & Sprungli", "Loblaw Companies Limited", "Louis Delhaize", "Marfrig Global Foods",
                "MAXIMA GRUPE, UAB", "McCormick", "Meijer", "Mercadona", "Metro", "Metro Group",
                "Migros-Genossenschafts Bund", "Mondelez International", "Monster Beverage",
                "Muyuan Foodstuff", "Nestlé", "New Hope Liuhe", "Nongfu Spring", "NorgesGruppen ASA",
                "OK Corporation", "Olam Group", "Organizacién Soriana, SAB. de C.V.", "PepsiCo",
                "Performance Food Group", "Pick n Pay Stores", "PJSC \"Magnit\"", "President Chain Store Corp.",
                "PT Indomarco Prismatama", "PT Sumber Afaia Tijaya Tok", "Publix Super Markets",
                "Reitan AS", "Rewe Group", "Royal Ahold Delhaize N.V.", "S Group", "Salling Group",
                "Saputo", "Save-On-Foods", "Seven & I Holdings", "Shoprite Holdings",
                "Southeastern Grocers", "Spar Holding", "Sprouts Farmers Market", "SRetail Co",
                "Stater Bros.", "Südzucker", "Suntory Beverage & Food", "Sysco",
                "Système U, Centrale Nationale", "Tengelmann Group", "Tesco", "The Hershey Company",
                "The Kroger", "The Save Mart Companies", "The SPAR Group", "Tyson Foods",
                "Uni-President", "United Natural Foods", "US Foods", "Varun Beverages",
                "Wegmans Food Markets", "Wens Foodstuff Group", "WH Group", "Wilmar International",
                "WinCo Foods", "Wm Morrison Supermarkets", "Woolworths", "Woolworths Limited",
                "Wumart Technology Group", "X5 Retail Group", "Yaoko Co", "Yonghui Superstores"
            ]

            # Check for exact match first
            if merchant_text in grocery_merchants:
                return self.POSITIVE

            # Check for partial matches (case-insensitive)
            merchant_lower = merchant_text.lower()
            for grocery_merchant in grocery_merchants:
                if grocery_merchant.lower() in merchant_lower or merchant_lower in grocery_merchant.lower():
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_merchant_keywords(x):
            """Key grocery brand names that might appear in various forms"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            # Combine merchant and text for checking
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Key brand names that are likely to appear in various forms
            key_grocery_brands = [
                'carrefour', 'leclerc', 'aldi', 'costco', 'walmart', 'tesco', 'kroger',
                'lidl', 'metro', 'casino', 'auchan', 'intermarche', 'monoprix',
                'sainsbury', 'asda', 'morrisons', 'coop', 'spar', 'edeka',
                'rewe', 'migros', 'ica', 'aeon', 'woolworths', 'coles'
            ]

            if any(brand in text_to_check for brand in key_grocery_brands):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_text_anchor(x):
            """FastText similarity to grocery anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)
            return self.POSITIVE if similarity >= 0.6 else self.ABSTAIN

        def lf_grocery_spending_pattern(x):
            """Spending patterns typical of grocery shopping"""
            if x.amt_mean >= 0:  # Should be expenses (negative)
                return self.ABSTAIN

            # Frequent, moderate amounts with some variance
            if (x.amt_count >= 4 and  # Regular purchases
                -300 <= x.amt_mean <= -10 and  # Typical grocery range
                x.mean_delta_days <= 21 and  # At least every 3 weeks
                0.2 <= x.amt_cv <= 1.8):  # Some variance in basket sizes
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_grocery_large_amounts(x):
            """Very large amounts unlikely to be groceries"""
            if x.amt_mean < -500:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_grocery_positive_amounts(x):
            """Positive amounts are income, not expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_grocery_very_infrequent(x):
            """Very infrequent purchases unlikely to be groceries"""
            if x.amt_count >= 3 and x.mean_delta_days > 60:  # Very infrequent
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_grocery_naf_codes", f=lf_grocery_naf_codes),
            LabelingFunction(name="lf_grocery_merchants", f=lf_grocery_merchants),
            LabelingFunction(name="lf_grocery_merchant_keywords", f=lf_grocery_merchant_keywords),
            LabelingFunction(name="lf_grocery_text_anchor", f=lf_grocery_text_anchor),
            LabelingFunction(name="lf_grocery_spending_pattern", f=lf_grocery_spending_pattern),
            LabelingFunction(name="lf_not_grocery_large_amounts", f=lf_not_grocery_large_amounts),
            LabelingFunction(name="lf_not_grocery_positive_amounts", f=lf_not_grocery_positive_amounts),
            LabelingFunction(name="lf_not_grocery_very_infrequent", f=lf_not_grocery_very_infrequent),
        ]

# Usage
groceries_classifier = GroceriesClassifier(ft, merchant_agg_df)
groceries_results = groceries_classifier.run_full_pipeline(confidence_threshold=0.8)


# Export LF results to Excel
results_df = extract_lf_results_to_excel(
    groceries_classifier,
    merchant_agg_df,
    "groceries_lf_detailed_results.xlsx"
)

class EnhancedGroceriesClassifier(CategoryClassifier):
    """Enhanced groceries classifier with improved detection capabilities"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Groceries", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_grocery_thresholds()

        # Enhanced text anchors (more comprehensive)
        grocery_anchors = [
            "supermarche", "alimentation", "courses", "epicerie", "hypermarche",
            "market", "grocery", "food", "magasin", "fresh", "bio", "organic",
            "fruits", "legumes", "viande", "meat", "dairy", "lait", "pain", "bread"
        ]
        self.setup_anchors(grocery_anchors, similarity_threshold=0.6)

    def _calculate_grocery_thresholds(self) -> dict:
        """Calculate grocery-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -500,      # Maximum grocery expense
            'max_amount': -5,        # Minimum meaningful grocery expense
            'typical_min': -200,     # Typical grocery range
            'typical_max': -20,
            'max_days_between': 21,  # Maximum days between grocery trips
            'min_frequency': 4,      # Minimum transactions to establish pattern
            'max_cv': 1.8,          # Maximum coefficient of variation
            'min_cv': 0.2           # Minimum CV (some variance expected)
        }

        # Adjust thresholds based on user income/family size
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -800,      # Higher spending capacity
                    'typical_min': -400,
                    'typical_max': -30
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -300,      # Lower spending capacity
                    'typical_min': -150,
                    'typical_max': -10
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create enhanced grocery-specific labeling functions"""

        def lf_grocery_naf_codes(x):
            """NAF codes that correspond to grocery/food businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Your complete NAF code list (keeping the same comprehensive list)
            grocery_naf_codes = [
                "01.1", "01.11", "01.11Z", "01.12", "01.12Z", "01.13", "01.13Z",
                "01.14", "01.14Z", "01.16", "01.16Z", "01.19", "01.19Z", "01.2",
                "01.21", "01.21Z", "01.22", "01.22Z", "01.23", "01.23Z", "01.24",
                "01.24Z", "01.25", "01.25Z", "01.26", "01.26Z", "01.27", "01.27Z",
                "01.28", "01.28Z", "01.4", "01.41", "01.44", "01.44Z", "01.45",
                "01.45Z", "01.46", "01.46Z", "01.47", "01.47Z", "01.5", "01.50",
                "01.50Z", "02.3", "02.30", "02.30Z", "03", "03.11Z", "03.12",
                "03.12Z", "10.3", "10.31", "10.31Z", "10.39A", "10.39B", "10.4",
                "10.41", "10.41A", "10.41B", "10.42", "10.42Z", "10.5", "10.51",
                "10.51A", "10.89Z", "11.07", "47.11A", "47.11B", "47.11C", "47.11D",
                "47.11E", "47.11F", "47.19", "47.19A", "47.19B", "47.2", "47.21",
                "47.21Z", "47.22", "47.22Z", "47.23", "47.23Z", "47.24", "47.24Z",
                "47.29", "47.29Z", "47.78B", "47.78C", "47.79", "47.79Z", "47.8",
                "47.81", "47.81Z", "47.89", "47.89Z", "47.99", "47.99A"
            ]

            if str(x.NAF_CODE).strip() in grocery_naf_codes:
                # Additional check: should be expense, not income
                if x.amt_mean < 0:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_grocery_merchants(x):
            """Enhanced merchant detection with better partial matching"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Your complete merchant list (keeping the same comprehensive list)
            grocery_merchants = [
                "A.S. Watson Group", "Aeon", "Ahold Delhaize", "Ajinomoto", "Albertsons",
                "Albertsons Companies", "Aldi Einkauf & oHG / Aldi International Services & oHG",
                "Alimentation Couche-Tard", "Almarai", "Anheuser-Busch InBev",
                "Anhui Gujing Distillery", "Arca Continental", "Archer Daniels Midland",
                "Asahi Group Holdings", "Asda Group", "Associated British Foods", "ATB-Market",
                "Avenue Supermarts", "Barry Callebaut", "BIM Birlesik Magazalar",
                "BIM Birleşik Mağazalar A.Ş.", "BJ's Wholesale Club", "BJ's Wholesale Club Holdings",
                "British American Tobacco", "Brown-Forman", "Bunge", "Campbell Soup", "Carlsberg",
                "Carrefour", "Casey's General Stores", "Casino Guichard-Perrachon", "Celsius Holdings",
                "Cencosud", "Centres Distributeurs E. Leclerc", "Charoen Pokphand Group",
                "China Mengniu Dairy", "China Resources Beer (Holdings)", "Chyuan Lien Enterprise Co/ PXMart",
                "CJ Cheiljedang", "CJ Corporation", "Co-operative Group", "Coca-Cola",
                "Coca-Cola Europacific Partners", "Coca-Cola HBC", "Coles Group", "Colruyt",
                "Colruyt Group", "Conad Consorzio Nazionale", "Conagra Brands", "Constellation Brands",
                "Coop Danmark VS", "Coop Group", "Coop Italia", "Coop Norge, the Group",
                "Costco Wholesale", "Costco Wholesale Corporation", "Couche Tard", "CP All",
                "CP Axtra", "Dairy Farm International Holdings", "Danone", "Demoulas Super Markets",
                "Diageo", "dion Corporation", "Dirk Rossmann", "Distribuidora Internacional de Alimentación",
                "dm-drogerie markt Verwaltungs-GmbH", "Dollar General", "Dollar General Corporation",
                "Dollar Tree", "Dollarama", "E-mart", "Edeka-Verbund", "EG Group", "Empire",
                "Empire Company", "Endeavour Group", "Esselunga", "Femsa", "FEMSA Comercio",
                "Foshan Haitian Flavouring and Food", "General Mills", "George Weston", "Giant Eagle",
                "Givaudan", "Glencore International", "Grupo Bimbo", "Grupo Comercial Chedraui",
                "Grupo Comercial Chedraui SAB de CV Class B", "Grupo Eroski", "Gruppo Eurospin",
                "Guangdong Haid Group", "H-E-B Grocery Company", "H20 Retailing Corporation",
                "Homeplus", "Hormel Foods", "Hy-Vee", "ICA Gruppen", "Ingles Markets", "Ingredion",
                "Inner Mongolia Yili", "J Sainsbury", "JBS", "JDE Peet's", "Jeronimo Martins",
                "Jerónimo Martins SGPS", "JM Smucker", "Kellanova", "Kerry Group", "Kesko",
                "Kesko Corporation", "Keurig Dr Pepper", "Koninklijke Jumbo Food Groep",
                "Kraft Heinz Company", "Kroger", "Lamb Weston Holdings", "Lawson", "Lenta Group",
                "Lindt & Sprungli", "Loblaw Companies Limited", "Louis Delhaize", "Marfrig Global Foods",
                "MAXIMA GRUPE, UAB", "McCormick", "Meijer", "Mercadona", "Metro", "Metro Group",
                "Migros-Genossenschafts Bund", "Mondelez International", "Monster Beverage",
                "Muyuan Foodstuff", "Nestlé", "New Hope Liuhe", "Nongfu Spring", "NorgesGruppen ASA",
                "OK Corporation", "Olam Group", "Organizacién Soriana, SAB. de C.V.", "PepsiCo",
                "Performance Food Group", "Pick n Pay Stores", "PJSC \"Magnit\"", "President Chain Store Corp.",
                "PT Indomarco Prismatama", "PT Sumber Afaia Tijaya Tok", "Publix Super Markets",
                "Reitan AS", "Rewe Group", "Royal Ahold Delhaize N.V.", "S Group", "Salling Group",
                "Saputo", "Save-On-Foods", "Seven & I Holdings", "Shoprite Holdings",
                "Southeastern Grocers", "Spar Holding", "Sprouts Farmers Market", "SRetail Co",
                "Stater Bros.", "Südzucker", "Suntory Beverage & Food", "Sysco",
                "Système U, Centrale Nationale", "Tengelmann Group", "Tesco", "The Hershey Company",
                "The Kroger", "The Save Mart Companies", "The SPAR Group", "Tyson Foods",
                "Uni-President", "United Natural Foods", "US Foods", "Varun Beverages",
                "Wegmans Food Markets", "Wens Foodstuff Group", "WH Group", "Wilmar International",
                "WinCo Foods", "Wm Morrison Supermarkets", "Woolworths", "Woolworths Limited",
                "Wumart Technology Group", "X5 Retail Group", "Yaoko Co", "Yonghui Superstores"
            ]

            # Check for exact match first
            if merchant_text in grocery_merchants:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            # Enhanced partial matching with word boundaries
            merchant_lower = merchant_text.lower()
            for grocery_merchant in grocery_merchants:
                merchant_words = grocery_merchant.lower().split()
                if len(merchant_words) >= 2:
                    # For multi-word merchants, check if key words are present
                    key_word = merchant_words[0]  # First word is usually the key brand
                    if len(key_word) >= 4 and key_word in merchant_lower:
                        if x.amt_mean < 0:
                            return self.POSITIVE
                else:
                    # Single word merchants
                    if grocery_merchant.lower() in merchant_lower or merchant_lower in grocery_merchant.lower():
                        if x.amt_mean < 0:
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_merchant_keywords(x):
            """Enhanced key grocery brand detection"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            # Combine merchant and text for checking
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Enhanced brand list with French-specific additions
            key_grocery_brands = [
                # International brands
                'carrefour', 'leclerc', 'aldi', 'costco', 'walmart', 'tesco', 'kroger',
                'lidl', 'metro', 'casino', 'auchan', 'intermarche', 'monoprix',
                'sainsbury', 'asda', 'morrisons', 'coop', 'spar', 'edeka',
                'rewe', 'migros', 'ica', 'aeon', 'woolworths', 'coles',

                # French-specific additions
                'franprix', 'leader price', 'simply market', 'grand frais', 'picard',
                'match', 'proxi', 'vival', 'coccimarket', 'u express', 'super u',
                'hyper u', 'marche plus', 'marché plus', 'sherpa', 'netto',

                # Organic/specialty
                'naturalia', 'biocoop', 'la vie claire', 'bio c bon', 'fresh market',
                'whole foods', 'sprouts', 'fresh thyme'
            ]

            for brand in key_grocery_brands:
                if brand in text_to_check:
                    if x.amt_mean < 0:  # Should be expense
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_text_anchor(x):
            """Enhanced FastText similarity with expense validation"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require both similarity and expense pattern
            if similarity >= 0.6 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_spending_pattern(x):
            """Enhanced spending patterns with user profile consideration"""
            if x.amt_mean >= 0:  # Should be expenses (negative)
                return self.ABSTAIN

            # Use dynamic thresholds based on user profile
            min_amount = self.thresholds['min_amount']
            max_amount = self.thresholds['max_amount']
            max_days = self.thresholds['max_days_between']
            min_freq = self.thresholds['min_frequency']

            # Enhanced pattern detection
            is_frequent = x.amt_count >= min_freq
            is_reasonable_amount = min_amount <= x.amt_mean <= max_amount
            is_regular = x.mean_delta_days <= max_days if x.amt_count > 1 else True
            has_reasonable_variance = self.thresholds['min_cv'] <= x.amt_cv <= self.thresholds['max_cv']

            if is_frequent and is_reasonable_amount and is_regular and has_reasonable_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_grocery_weekend_pattern(x):
            """Detect weekend shopping patterns (if date info available)"""
            # This would require date analysis - placeholder for now
            # Could be enhanced if you have day-of-week information
            return self.ABSTAIN

        def lf_grocery_food_keywords(x):
            """Detect specific food-related keywords in transaction text"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_lower = str(x.CLEANED_TEXT).lower()

            # Food-specific keywords
            food_keywords = [
                'alimentaire', 'alimentair', 'aliment', 'nourriture', 'boucher', 'boulanger',
                'epicerie', 'epicier', 'marche', 'marché', 'fresh', 'frais', 'bio',
                'organic', 'fruits', 'legumes', 'légumes', 'viande', 'poisson',
                'lait', 'pain', 'fromage', 'yaourt', 'cereales', 'céréales'
            ]

            if any(keyword in text_lower for keyword in food_keywords):
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_not_grocery_large_amounts(x):
            """Enhanced large amount exclusion"""
            # Very large expenses are unlikely to be groceries
            if x.amt_mean < -800:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_grocery_positive_amounts(x):
            """Positive amounts are income, not grocery expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_grocery_very_infrequent(x):
            """Enhanced infrequency detection"""
            if x.amt_count >= 3 and x.mean_delta_days > 90:  # Very infrequent
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_grocery_single_large(x):
            """Single very large purchases unlikely to be groceries"""
            if x.amt_count == 1 and x.amt_mean < -400:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_grocery_naf_codes", f=lf_grocery_naf_codes),
            LabelingFunction(name="lf_grocery_merchants", f=lf_grocery_merchants),
            LabelingFunction(name="lf_grocery_merchant_keywords", f=lf_grocery_merchant_keywords),
            LabelingFunction(name="lf_grocery_text_anchor", f=lf_grocery_text_anchor),
            LabelingFunction(name="lf_grocery_spending_pattern", f=lf_grocery_spending_pattern),
            LabelingFunction(name="lf_grocery_food_keywords", f=lf_grocery_food_keywords),
            LabelingFunction(name="lf_not_grocery_large_amounts", f=lf_not_grocery_large_amounts),
            LabelingFunction(name="lf_not_grocery_positive_amounts", f=lf_not_grocery_positive_amounts),
            LabelingFunction(name="lf_not_grocery_very_infrequent", f=lf_not_grocery_very_infrequent),
            LabelingFunction(name="lf_not_grocery_single_large", f=lf_not_grocery_single_large),
        ]


# Usage example
def create_groceries_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run groceries classifier"""

    # Create classifier instance
    classifier = EnhancedGroceriesClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results

# Example usage:
"""
groceries_classifier = EnhancedGroceriesClassifier(ft, merchant_agg_df, user_profile)
groceries_results = groceries_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
groceries_excel = extract_lf_results_to_excel(
    groceries_classifier, merchant_agg_df, "groceries_lf_detailed_results.xlsx"
)

print(f"Groceries Results:")
print(f"- Total predicted: {groceries_results['predicted_positive']}")
print(f"- High confidence: {groceries_results['high_confidence_positive']}")
"""

groceries_classifier = EnhancedGroceriesClassifier(ft, merchant_agg_df, user_profile)
groceries_results = groceries_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
groceries_excel = extract_lf_results_to_excel(
    groceries_classifier, merchant_agg_df, "groceries_lf_detailed_results.xlsx"
)

print(f"Groceries Results:")
print(f"- Total predicted: {groceries_results['predicted_positive']}")
print(f"- High confidence: {groceries_results['high_confidence_positive']}")

"""### Rent"""

class RentClassifier(CategoryClassifier):
    """Enhanced rent classifier with strict monthly pattern detection"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Rent", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_rent_thresholds()

        # Rent-specific anchors
        rent_anchors = [
            "loyer", "rent", "location", "appartement", "logement",
            "habitation", "immobilier", "bailleur", "propriétaire",
            "residence", "housing", "lease", "rental"
        ]
        self.setup_anchors(rent_anchors, similarity_threshold=0.7)

    def _calculate_rent_thresholds(self) -> dict:
        """Calculate rent-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -4000,        # Maximum reasonable rent
            'max_amount': -200,         # Minimum reasonable rent
            'monthly_min_days': 28,     # Strict monthly (28-32 days)
            'monthly_max_days': 32,
            'min_frequency': 3,         # Need at least 3 payments to establish pattern
            'max_cv': 0.15,            # Very consistent (rent rarely changes)
            'min_cv': 0.0,             # Can be perfectly consistent
            'typical_min': -2000,       # Typical rent range
            'typical_max': -400,
        }

        # Adjust thresholds based on user income/location
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -6000,      # Higher rent capacity
                    'typical_min': -3000,
                    'typical_max': -600
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -1500,      # Lower rent capacity
                    'typical_min': -800,
                    'max_amount': -150
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create rent-specific labeling functions"""

        def lf_rent_perfect_monthly_pattern(x):
            """HIGH CONFIDENCE: Perfect monthly pattern with consistent amounts"""
            if x.amt_mean >= 0 or x.amt_count < self.thresholds['min_frequency']:
                return self.ABSTAIN

            # Must be in reasonable rent range
            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Strict monthly pattern (28-32 days)
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            # Very consistent amounts (rent rarely changes)
            is_very_consistent = x.amt_cv <= self.thresholds['max_cv']

            # Large enough to be rent
            is_substantial = x.amt_mean <= self.thresholds['typical_max']

            if is_reasonable_amount and is_monthly and is_very_consistent and is_substantial:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_keywords_high_confidence(x):
            """HIGH CONFIDENCE: Direct rent keywords with amount validation"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # High confidence rent keywords
            high_confidence_rent_keywords = [
                'loyer', 'rent', 'rental', 'lease', 'location appartement',
                'location logement', 'bail', 'bailleur', 'propriétaire',
                'logement location', 'appartement location', 'housing rent'
            ]

            # Check for direct keywords
            has_rent_keyword = any(keyword in text_to_check for keyword in high_confidence_rent_keywords)

            if has_rent_keyword:
                # Must be substantial expense in rent range
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_property_management(x):
            """Property management companies and real estate agencies"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            # Property management and real estate companies
            property_companies = [
                'immobilier', 'immo', 'gestion locative', 'syndic',
                'property management', 'real estate', 'estate agency',
                'agence immobiliere', 'cabinet immobilier', 'fonciere',
                'patrimoine', 'residence', 'foncia', 'century21',
                'orpi', 'guy hoquet', 'laforet', 'nexity', 'bouygues immobilier'
            ]

            # Check for property management indicators
            has_property_indicator = any(company in merchant_text for company in property_companies)

            if has_property_indicator:
                # Must be substantial monthly expense
                if (x.amt_mean < 0 and
                    x.amt_mean <= self.thresholds['typical_max'] and
                    x.amt_count >= 2):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_text_anchor(x):
            """FastText similarity with strict requirements for rent"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # High similarity threshold and must be substantial expense
            if (similarity >= 0.75 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['typical_max']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_round_monthly_amounts(x):
            """Round amounts with perfect monthly pattern (common for rent)"""
            if (x.amt_mean >= 0 or
                x.amt_count < 3 or
                x.amt_mean > self.thresholds['max_amount']):
                return self.ABSTAIN

            # Check for round amounts common in rent
            amount_abs = abs(int(x.amt_mean))

            # Common rent amounts (round numbers)
            is_round_rent = (
                amount_abs % 50 == 0 or    # Multiples of 50
                amount_abs % 100 == 0      # Multiples of 100
            ) and amount_abs >= 300        # Minimum rent threshold

            # Must have perfect monthly pattern
            is_perfect_monthly = (
                28 <= x.mean_delta_days <= 32 and
                x.amt_cv <= 0.1  # Very consistent
            )

            if is_round_rent and is_perfect_monthly:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_single_large_monthly(x):
            """Single large payment per month pattern"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency']):
                return self.ABSTAIN

            # Large amount, monthly, very consistent
            is_large_amount = x.amt_mean <= -500  # Substantial amount
            is_monthly_consistent = (
                28 <= x.mean_delta_days <= 32 and
                x.amt_cv <= 0.2  # Reasonably consistent
            )

            # Not too frequent (should be roughly monthly)
            is_appropriate_frequency = x.amt_count <= 15  # Max ~1 year of data

            if is_large_amount and is_monthly_consistent and is_appropriate_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_rent_naf_codes(x):
            """NAF codes related to real estate and property management"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Real estate and property management NAF codes
            real_estate_naf_codes = [
                "68.10Z", "68.20A", "68.20B", "68.31Z", "68.32A", "68.32B",
                "41.10A", "41.10B", "41.10C", "41.10D", "41.20A", "41.20B"
            ]

            if str(x.NAF_CODE).strip() in real_estate_naf_codes:
                # Must be substantial expense
                if (x.amt_mean < 0 and
                    x.amt_mean <= self.thresholds['typical_max']):
                    return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_rent_too_frequent(x):
            """Too frequent to be rent (more than monthly)"""
            if x.amt_count >= 3 and x.mean_delta_days < 20:  # More frequent than monthly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_rent_too_variable(x):
            """Too variable to be rent (amounts change too much)"""
            if x.amt_count >= 3 and x.amt_cv > 0.3:  # Too much variation for rent
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_rent_too_small(x):
            """Too small to be rent"""
            if x.amt_mean > self.thresholds['max_amount']:  # Above -200 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_rent_positive_amounts(x):
            """Positive amounts are income, not rent"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_rent_known_utilities(x):
            """Exclude known utility providers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            utility_providers = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez', 'total', 'electricite', 'gaz'
            ]

            if any(provider in merchant_text for provider in utility_providers):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_rent_known_groceries(x):
            """Exclude known grocery chains"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            grocery_chains = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche'
            ]

            if any(chain in merchant_text for chain in grocery_chains):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_rent_very_frequent_small(x):
            """Very frequent small payments (likely daily expenses)"""
            if (x.amt_count > 20 and
                x.mean_delta_days < 7 and
                x.amt_mean > -100):
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_rent_irregular_timing(x):
            """Very irregular timing unlikely to be rent"""
            if (x.amt_count >= 5 and
                (x.mean_delta_days < 15 or x.mean_delta_days > 45)):
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_rent_perfect_monthly_pattern", f=lf_rent_perfect_monthly_pattern),
            LabelingFunction(name="lf_rent_keywords_high_confidence", f=lf_rent_keywords_high_confidence),
            LabelingFunction(name="lf_rent_property_management", f=lf_rent_property_management),
            LabelingFunction(name="lf_rent_text_anchor", f=lf_rent_text_anchor),
            LabelingFunction(name="lf_rent_round_monthly_amounts", f=lf_rent_round_monthly_amounts),
            LabelingFunction(name="lf_rent_single_large_monthly", f=lf_rent_single_large_monthly),
            LabelingFunction(name="lf_rent_naf_codes", f=lf_rent_naf_codes),
            LabelingFunction(name="lf_not_rent_too_frequent", f=lf_not_rent_too_frequent),
            LabelingFunction(name="lf_not_rent_too_variable", f=lf_not_rent_too_variable),
            LabelingFunction(name="lf_not_rent_too_small", f=lf_not_rent_too_small),
            LabelingFunction(name="lf_not_rent_positive_amounts", f=lf_not_rent_positive_amounts),
            LabelingFunction(name="lf_not_rent_known_utilities", f=lf_not_rent_known_utilities),
            LabelingFunction(name="lf_not_rent_known_groceries", f=lf_not_rent_known_groceries),
            LabelingFunction(name="lf_not_rent_very_frequent_small", f=lf_not_rent_very_frequent_small),
            LabelingFunction(name="lf_not_rent_irregular_timing", f=lf_not_rent_irregular_timing),
        ]


# Usage example
def create_rent_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run rent classifier"""

    # Create classifier instance
    classifier = RentClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.8)

    return classifier, results

# Example usage:
"""
rent_classifier = RentClassifier(ft, merchant_agg_df, user_profile)
rent_results = rent_classifier.run_full_pipeline(confidence_threshold=0.8)

# Export results
rent_excel = extract_lf_results_to_excel(
    rent_classifier, merchant_agg_df, "rent_lf_detailed_results.xlsx"
)

print(f"Rent Results:")
print(f"- Total predicted: {rent_results['predicted_positive']}")
print(f"- High confidence: {rent_results['high_confidence_positive']}")
"""

rent_classifier = RentClassifier(ft, merchant_agg_df, user_profile)
rent_results = rent_classifier.run_full_pipeline(confidence_threshold=0.8)

# Export results
rent_excel = extract_lf_results_to_excel(
    rent_classifier, merchant_agg_df, "rent_lf_detailed_results.xlsx"
)

print(f"Rent Results:")
print(f"- Total predicted: {rent_results['predicted_positive']}")
print(f"- High confidence: {rent_results['high_confidence_positive']}")

"""### Utilities

Energy (Gas, Electricity, Water)
"""

class UtilitiesClassifier(CategoryClassifier):
    """Utilities classifier for electricity, gas, water, internet, phone, waste management"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Utilities", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_utilities_thresholds()

        # Utilities-specific text anchors
        utilities_anchors = [
            "electricite", "electricity", "gaz", "gas", "eau", "water", "internet",
            "telephone", "phone", "mobile", "telecom", "energie", "energy",
            "facture", "bill", "utility", "utilities", "abonnement", "subscription"
        ]
        self.setup_anchors(utilities_anchors, similarity_threshold=0.65)

    def _calculate_utilities_thresholds(self) -> dict:
        """Calculate utilities-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -500,        # Maximum utility bill
            'max_amount': -15,         # Minimum meaningful utility bill
            'typical_min': -250,       # Typical utility range
            'typical_max': -25,
            'monthly_min_days': 25,    # Monthly billing (25-35 days)
            'monthly_max_days': 35,
            'quarterly_min_days': 85,  # Quarterly billing (85-95 days)
            'quarterly_max_days': 95,
            'annual_min_days': 350,    # Annual billing (350-380 days)
            'annual_max_days': 380,
            'min_frequency': 2,        # Minimum transactions to establish pattern
            'max_cv': 0.8,            # Utilities are fairly consistent
            'min_cv': 0.05            # Some variation due to usage/seasons
        }

        # Adjust thresholds based on user income/housing situation
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -800,        # Larger homes, higher bills
                    'typical_min': -400,
                    'typical_max': -40
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -300,        # Smaller apartments, lower bills
                    'typical_min': -150,
                    'typical_max': -15
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create utilities-specific labeling functions"""

        def lf_utilities_naf_codes(x):
            """NAF codes for utilities and telecommunications"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            utilities_naf_codes = [
                # Electricity, gas, steam and air conditioning supply
                "35.11Z",  # Production of electricity
                "35.12Z",  # Transmission of electricity
                "35.13Z",  # Distribution of electricity
                "35.14Z",  # Trade of electricity
                "35.21Z",  # Manufacture of gas
                "35.22Z",  # Distribution of gaseous fuels through mains
                "35.23Z",  # Trade of gas through mains
                "35.30Z",  # Steam and air conditioning supply

                # Water collection, treatment and supply
                "36.00Z",  # Water collection, treatment and supply

                # Sewerage and waste management
                "37.00Z",  # Sewerage
                "38.11Z",  # Collection of non-hazardous waste
                "38.12Z",  # Collection of hazardous waste
                "38.21Z",  # Treatment and disposal of non-hazardous waste
                "38.22Z",  # Treatment and disposal of hazardous waste
                "38.31Z",  # Dismantling of wrecks
                "38.32Z",  # Recovery of sorted materials
                "39.00Z",  # Remediation activities and other waste management services

                # Telecommunications
                "61.10Z",  # Wired telecommunications activities
                "61.20Z",  # Wireless telecommunications activities
                "61.30Z",  # Satellite telecommunications activities
                "61.90Z",  # Other telecommunications activities

                # Computer programming, consultancy (ISPs)
                "62.01Z",  # Computer programming activities
                "62.02A",  # Consulting activities on information systems
                "62.02B",  # Computing technical support activities
                "63.11Z",  # Data processing, hosting and related activities
                "63.12Z",  # Web portals

                # Publishing (ISPs, telecom)
                "58.29A",  # Publishing of computer games
                "58.29B",  # Other software publishing
                "58.29C",  # Publishing of electronic directories and mailing lists

                # Rental and leasing (equipment)
                "77.22Z",  # Renting of video tapes and disks
                "77.29Z",  # Renting and leasing of other consumer goods
            ]

            if str(x.NAF_CODE).strip() in utilities_naf_codes:
                # Should be expense, not income
                if x.amt_mean < 0:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_utilities_major_providers(x):
            """Major utility and telecom providers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Major utility and telecom providers by category
            utility_providers = [
                # French Electricity & Gas
                "EDF", "Engie", "Total Energies", "Total Direct Energie", "Eni",
                "Vattenfall", "Planète OUI", "Mint Energie", "Happ-e", "Cdiscount Energie",
                "Butagaz", "Antargaz", "Primagaz", "Finagaz", "Vitogaz",

                # French Water
                "Veolia", "Suez", "Saur", "Eau de Paris", "Lyonnaise des Eaux",
                "Régie des Eaux", "Eau du Grand Lyon", "Eau de Marseille",

                # French Telecom/Internet
                "Orange", "SFR", "Bouygues Telecom", "Free", "La Poste Mobile",
                "Red by SFR", "Sosh", "B&You", "NRJ Mobile", "Prixtel",
                "Coriolis", "Réglo Mobile", "Syma Mobile", "CIC Mobile",

                # French ISPs
                "Orange", "Free", "SFR", "Bouygues", "Nordnet", "OVH",
                "K-Net", "Coriolis", "Alice", "Numéricable",

                # European Utilities
                "E.ON", "RWE", "Iberdrola", "Enel", "Endesa", "Naturgy",
                "Centrica", "British Gas", "Scottish Power", "EDF Energy",
                "SSE", "Ovo Energy", "Bulb", "Octopus Energy",

                # European Telecom
                "Deutsche Telekom", "Vodafone", "Telefónica", "Telecom Italia",
                "KPN", "Telia", "Telenor", "BT Group", "Virgin Media",
                "Three", "O2", "EE", "Sky", "TalkTalk",

                # US Utilities
                "ConEd", "PG&E", "Southern Company", "Duke Energy", "Exelon",
                "NextEra Energy", "Dominion Energy", "American Electric Power",
                "Xcel Energy", "WEC Energy", "Atmos Energy", "CenterPoint Energy",

                # US Telecom/Internet
                "Verizon", "AT&T", "T-Mobile", "Sprint", "Comcast", "Charter",
                "Cox Communications", "Altice", "CenturyLink", "Lumen",
                "Frontier Communications", "Dish Network", "DirecTV",

                # Waste Management
                "Waste Management", "Republic Services", "Waste Connections",
                "Veolia North America", "Suez North America", "Casella Waste",
                "SITA", "Biffa", "Renewi"
            ]

            # Exact match check
            if merchant_text in utility_providers:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            # Enhanced partial matching for utility companies
            merchant_lower = merchant_text.lower()
            for provider in utility_providers:
                provider_lower = provider.lower()

                # Check if provider name appears in merchant text
                if provider_lower in merchant_lower:
                    if x.amt_mean < 0:
                        return self.POSITIVE

                # Check for key words (for multi-word companies)
                provider_words = provider_lower.split()
                if len(provider_words) >= 2:
                    key_word = provider_words[0]
                    if len(key_word) >= 4 and key_word in merchant_lower:
                        if x.amt_mean < 0:
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_keywords(x):
            """Utility-related keywords in merchant names and transaction text"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            # Combine merchant and text for checking
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Comprehensive utility keywords
            utility_keywords = [
                # Electricity
                'electricite', 'électricité', 'electricity', 'electric', 'power',
                'energie', 'énergie', 'energy', 'edf', 'engie', 'kwh',

                # Gas
                'gaz', 'gas', 'butane', 'propane', 'chauffage', 'heating',

                # Water
                'eau', 'water', 'veolia', 'suez', 'saur', 'assainissement',
                'sewage', 'wastewater', 'distribution eau',

                # Internet/Phone
                'internet', 'wifi', 'adsl', 'fibre', 'fiber', 'broadband',
                'telephone', 'téléphone', 'mobile', 'telecom', 'télécom',
                'forfait', 'abonnement', 'subscription', 'plan',

                # General utilities
                'facture', 'bill', 'billing', 'utility', 'utilities',
                'service public', 'public service', 'municipal',
                'regie', 'régie', 'distribution', 'approvisionnement',

                # Waste management
                'dechets', 'déchets', 'waste', 'garbage', 'recycling',
                'ordures', 'collecte', 'ramassage', 'poubelle'
            ]

            for keyword in utility_keywords:
                if keyword in text_to_check:
                    if x.amt_mean < 0:  # Should be expense
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_text_anchor(x):
            """FastText similarity to utility anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require both similarity and expense pattern
            if similarity >= 0.65 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_monthly_pattern(x):
            """Monthly utility billing pattern"""
            if x.amt_mean >= 0 or x.amt_count < self.thresholds['min_frequency']:
                return self.ABSTAIN

            # Monthly billing pattern
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Utilities are fairly consistent but have some seasonal variation
            has_reasonable_consistency = (self.thresholds['min_cv'] <=
                                        x.amt_cv <=
                                        self.thresholds['max_cv'])

            if is_monthly and is_reasonable_amount and has_reasonable_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_quarterly_pattern(x):
            """Quarterly utility billing pattern (some providers)"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Quarterly billing pattern
            is_quarterly = (self.thresholds['quarterly_min_days'] <=
                           x.mean_delta_days <=
                           self.thresholds['quarterly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Quarterly bills might have more variation due to seasonal usage
            has_reasonable_consistency = x.amt_cv <= self.thresholds['max_cv'] * 1.5

            if is_quarterly and is_reasonable_amount and has_reasonable_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_annual_pattern(x):
            """Annual utility charges (some taxes, connection fees)"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Annual pattern
            is_annual = (self.thresholds['annual_min_days'] <=
                        x.mean_delta_days <=
                        self.thresholds['annual_max_days'])

            is_meaningful_amount = x.amt_mean <= self.thresholds['max_amount']

            # Annual charges tend to be more consistent
            is_consistent = x.amt_cv <= 0.3

            if is_annual and is_meaningful_amount and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_round_amounts(x):
            """Utilities often have round amounts (subscription fees)"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Check if amounts are "round" (ending in 0 or 5)
            amount_str = str(abs(int(x.amt_mean)))
            ends_in_round = amount_str.endswith(('0', '5', '9'))  # Many plans end in .99

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            has_some_regularity = x.amt_count >= 2 and x.mean_delta_days <= 60

            if ends_in_round and is_reasonable_amount and has_some_regularity:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_utilities_very_large(x):
            """Very large amounts unlikely to be utilities"""
            if x.amt_mean < -1000:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_positive_amounts(x):
            """Positive amounts are income, not utility expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_irregular(x):
            """Very irregular payments unlikely to be utilities"""
            if x.amt_count >= 3 and x.amt_cv > 2.0:  # Very high variation
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_frequent(x):
            """Very frequent payments (daily/weekly) unlikely to be utilities"""
            if x.amt_count > 5 and x.mean_delta_days < 14:  # More than weekly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_small(x):
            """Very small amounts unlikely to be utilities"""
            if x.amt_mean > -10:  # Very small expenses
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_utilities_naf_codes", f=lf_utilities_naf_codes),
            LabelingFunction(name="lf_utilities_major_providers", f=lf_utilities_major_providers),
            LabelingFunction(name="lf_utilities_keywords", f=lf_utilities_keywords),
            LabelingFunction(name="lf_utilities_text_anchor", f=lf_utilities_text_anchor),
            LabelingFunction(name="lf_utilities_monthly_pattern", f=lf_utilities_monthly_pattern),
            LabelingFunction(name="lf_utilities_quarterly_pattern", f=lf_utilities_quarterly_pattern),
            LabelingFunction(name="lf_utilities_annual_pattern", f=lf_utilities_annual_pattern),
            LabelingFunction(name="lf_utilities_round_amounts", f=lf_utilities_round_amounts),
            LabelingFunction(name="lf_not_utilities_very_large", f=lf_not_utilities_very_large),
            LabelingFunction(name="lf_not_utilities_positive_amounts", f=lf_not_utilities_positive_amounts),
            LabelingFunction(name="lf_not_utilities_very_irregular", f=lf_not_utilities_very_irregular),
            LabelingFunction(name="lf_not_utilities_very_frequent", f=lf_not_utilities_very_frequent),
            LabelingFunction(name="lf_not_utilities_very_small", f=lf_not_utilities_very_small),
        ]


# Usage example
def create_utilities_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run utilities classifier"""

    # Create classifier instance
    classifier = UtilitiesClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.75)

    return classifier, results

# Example usage:
"""
utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.75)

# Export results
utilities_excel = extract_lf_results_to_excel(
    utilities_classifier, merchant_agg_df, "utilities_lf_detailed_results.xlsx"
)

print(f"Utilities Results:")
print(f"- Total predicted: {utilities_results['predicted_positive']}")
print(f"- High confidence: {utilities_results['high_confidence_positive']}")

# High confidence utilities
high_conf_utilities = utilities_classifier.df[
    (utilities_classifier.df['is_utilities_weak_label'] == 1) &
    (utilities_classifier.df['utilities_confidence'] > 0.8)
][['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'utilities_confidence']]

print("\nHigh confidence utilities:")
print(high_conf_utilities.head())
"""

utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.75)

# Export results
utilities_excel = extract_lf_results_to_excel(
    utilities_classifier, merchant_agg_df, "utilities_lf_detailed_results.xlsx"
)

print(f"Utilities Results:")
print(f"- Total predicted: {utilities_results['predicted_positive']}")
print(f"- High confidence: {utilities_results['high_confidence_positive']}")

# High confidence utilities
high_conf_utilities = utilities_classifier.df[
    (utilities_classifier.df['is_utilities_weak_label'] == 1) &
    (utilities_classifier.df['utilities_confidence'] > 0.8)
][['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'utilities_confidence']]

print("\nHigh confidence utilities:")
print(high_conf_utilities.head())

class UtilitiesClassifier(CategoryClassifier):
    """Refined utilities classifier with better precision for small amounts"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Utilities", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_utilities_thresholds()

        # More specific utilities anchors - removed generic terms
        utilities_anchors = [
            "electricite", "electricity", "gaz", "eau", "internet",
            "telephone", "mobile", "telecom", "energie", "energy",
            "edf", "engie", "orange", "free", "sfr", "bouygues"
        ]
        self.setup_anchors(utilities_anchors, similarity_threshold=0.7)  # Higher threshold

    def _calculate_utilities_thresholds(self) -> dict:
        """Calculate utilities-specific thresholds with better precision"""
        base_thresholds = {
            'min_amount': -500,        # Maximum utility bill
            'max_amount': -20,         # Increased minimum (utilities rarely under 20 EUR)
            'typical_min': -250,
            'typical_max': -25,
            'monthly_min_days': 25,
            'monthly_max_days': 35,
            'quarterly_min_days': 85,
            'quarterly_max_days': 95,
            'annual_min_days': 350,
            'annual_max_days': 380,
            'min_frequency': 3,        # Increased minimum frequency
            'max_cv': 0.6,            # Tighter consistency requirement
            'min_cv': 0.05,
            'small_amount_threshold': -15,  # New: very small amount cutoff
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -800,
                    'max_amount': -30,      # Higher earners have higher utility bills
                    'typical_min': -400,
                    'typical_max': -40
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -300,
                    'max_amount': -15,      # But still meaningful amounts
                    'typical_min': -150,
                    'typical_max': -20
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create refined utilities-specific labeling functions"""

        def lf_utilities_naf_codes(x):
            """NAF codes for utilities - same as before"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            utilities_naf_codes = [
                "35.11Z", "35.12Z", "35.13Z", "35.14Z", "35.21Z", "35.22Z", "35.23Z", "35.30Z",
                "36.00Z", "37.00Z", "38.11Z", "38.12Z", "38.21Z", "38.22Z", "38.31Z", "38.32Z", "39.00Z",
                "61.10Z", "61.20Z", "61.30Z", "61.90Z", "62.01Z", "62.02A", "62.02B", "63.11Z", "63.12Z"
            ]

            if str(x.NAF_CODE).strip() in utilities_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # Added amount check
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_utilities_major_providers(x):
            """Major utility providers - enhanced with amount validation"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Major French providers - more specific list
            major_utility_providers = [
                # Top French utilities (most reliable indicators)
                "EDF", "Engie", "Orange", "Free", "SFR", "Bouygues Telecom",
                "Veolia", "Suez", "Total Energies", "Total Direct Energie",

                # Secondary providers
                "Eni", "Vattenfall", "Planète OUI", "Mint Energie", "Happ-e",
                "Butagaz", "Antargaz", "Primagaz", "Saur", "Lyonnaise des Eaux",
                "Red by SFR", "Sosh", "B&You", "NRJ Mobile", "La Poste Mobile"
            ]

            merchant_lower = merchant_text.lower()
            for provider in major_utility_providers:
                if provider.lower() in merchant_lower:
                    # Must be expense with meaningful amount
                    if (x.amt_mean < 0 and
                        x.amt_mean <= self.thresholds['max_amount'] and
                        x.amt_mean >= self.thresholds['small_amount_threshold']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_specific_keywords(x):
            """More specific utility keywords - reduced false positives"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # More specific keywords - removed generic terms like "facture", "bill"
            specific_utility_keywords = [
                # Electricity - specific terms
                'electricite', 'électricité', 'edf', 'engie', 'kwh', 'compteur electrique',

                # Gas - specific
                'gaz naturel', 'compteur gaz', 'butane', 'propane', 'engie gaz',

                # Water - specific
                'eau potable', 'veolia eau', 'suez eau', 'compteur eau', 'distribution eau',

                # Internet/Telecom - specific
                'internet', 'wifi', 'adsl', 'fibre optique', 'box internet',
                'forfait mobile', 'abonnement mobile', 'ligne telephonique',
                'orange internet', 'free internet', 'sfr box',

                # Waste - specific
                'ordures menageres', 'collecte dechets', 'ramassage poubelles'
            ]

            # Count matches to require stronger signal
            matches = sum(1 for keyword in specific_utility_keywords if keyword in text_to_check)

            if matches >= 1:  # At least one specific match
                if (x.amt_mean < 0 and
                    x.amt_mean <= self.thresholds['max_amount'] and
                    x.amt_mean >= self.thresholds['small_amount_threshold']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_text_anchor(x):
            """FastText similarity with stricter requirements"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher similarity threshold and amount requirements
            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount'] and
                x.amt_mean >= self.thresholds['small_amount_threshold']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_monthly_pattern_strict(x):
            """Stricter monthly pattern with amount requirements"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency'] or
                x.amt_mean > self.thresholds['small_amount_threshold']):  # Added small amount filter
                return self.ABSTAIN

            # Monthly billing pattern
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Stricter consistency requirement
            has_good_consistency = (self.thresholds['min_cv'] <=
                                  x.amt_cv <=
                                  self.thresholds['max_cv'])

            if is_monthly and is_reasonable_amount and has_good_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_provider_and_pattern(x):
            """Combined provider + pattern check for higher confidence"""
            if pd.isna(x.MERCHANT) or x.amt_mean >= 0:
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Key utility indicators
            utility_indicators = ['edf', 'engie', 'orange', 'free', 'sfr', 'veolia', 'suez']
            has_utility_indicator = any(indicator in merchant_lower for indicator in utility_indicators)

            # Must have both utility indicator AND reasonable pattern
            if has_utility_indicator:
                has_reasonable_pattern = (
                    x.amt_count >= 2 and
                    self.thresholds['small_amount_threshold'] <= x.amt_mean <= self.thresholds['max_amount'] and
                    x.mean_delta_days <= 40  # Monthly-ish pattern
                )

                if has_reasonable_pattern:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_round_amounts_strict(x):
            """Much stricter round amounts check"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['small_amount_threshold'] or
                x.amt_count < 3):  # Need at least 3 transactions
                return self.ABSTAIN

            # Check for very specific round amounts typical of utilities
            amount_abs = abs(int(x.amt_mean))

            # Common utility amounts (monthly subscriptions)
            common_utility_amounts = [20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100]
            is_common_amount = amount_abs in common_utility_amounts

            # Or ends in 9 (like 29, 39, 49) which are common for telecom
            ends_in_nine = str(amount_abs).endswith('9')

            is_very_regular = (
                x.amt_cv < 0.1 and  # Very consistent
                20 <= x.mean_delta_days <= 35  # Monthly pattern
            )

            if (is_common_amount or ends_in_nine) and is_very_regular:
                return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_utilities_very_small_strict(x):
            """Stricter small amount exclusion"""
            if x.amt_mean > self.thresholds['small_amount_threshold']:  # More than -15 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_groceries_indicators(x):
            """Exclude transactions that look like groceries"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_restaurant_indicators(x):
            """Exclude restaurant-like transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_very_frequent_small(x):
            """Very frequent small amounts are unlikely utilities"""
            if (x.amt_count > 10 and
                x.mean_delta_days < 7 and  # More than weekly
                x.amt_mean > -50):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_large(x):
            """Very large amounts unlikely to be utilities"""
            if x.amt_mean < -1000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_irregular(x):
            """Very irregular payments unlikely to be utilities"""
            if x.amt_count >= 3 and x.amt_cv > 1.5:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_utilities_naf_codes", f=lf_utilities_naf_codes),
            LabelingFunction(name="lf_utilities_major_providers", f=lf_utilities_major_providers),
            LabelingFunction(name="lf_utilities_specific_keywords", f=lf_utilities_specific_keywords),
            LabelingFunction(name="lf_utilities_text_anchor", f=lf_utilities_text_anchor),
            LabelingFunction(name="lf_utilities_monthly_pattern_strict", f=lf_utilities_monthly_pattern_strict),
            LabelingFunction(name="lf_utilities_provider_and_pattern", f=lf_utilities_provider_and_pattern),
            LabelingFunction(name="lf_utilities_round_amounts_strict", f=lf_utilities_round_amounts_strict),
            LabelingFunction(name="lf_not_utilities_very_small_strict", f=lf_not_utilities_very_small_strict),
            LabelingFunction(name="lf_not_utilities_groceries_indicators", f=lf_not_utilities_groceries_indicators),
            LabelingFunction(name="lf_not_utilities_restaurant_indicators", f=lf_not_utilities_restaurant_indicators),
            LabelingFunction(name="lf_not_utilities_very_frequent_small", f=lf_not_utilities_very_frequent_small),
            LabelingFunction(name="lf_not_utilities_positive_amounts", f=lf_not_utilities_positive_amounts),
            LabelingFunction(name="lf_not_utilities_very_large", f=lf_not_utilities_very_large),
            LabelingFunction(name="lf_not_utilities_very_irregular", f=lf_not_utilities_very_irregular),
        ]

# Test the refined classifier
utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.8)

# Check for improvement in precision
print(f"Total predicted utilities: {utilities_results['predicted_positive']}")
print(f"High confidence utilities: {utilities_results['high_confidence_positive']}")

class UtilitiesClassifier(CategoryClassifier):
    """Refined utilities classifier with better precision for small amounts"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Utilities", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_utilities_thresholds()

        # More specific utilities anchors - removed generic terms
        utilities_anchors = [
            "electricite", "electricity", "gaz", "eau", "internet",
            "telephone", "mobile", "telecom", "energie", "energy",
            "edf", "engie", "orange", "free", "sfr", "bouygues"
        ]
        self.setup_anchors(utilities_anchors, similarity_threshold=0.7)  # Higher threshold

    def _calculate_utilities_thresholds(self) -> dict:
        """Calculate utilities-specific thresholds with your criteria"""
        base_thresholds = {
            'min_amount': -500,        # Maximum utility bill
            'max_amount': -10,         # YOUR RULE: minimum 10 EUR
            'monthly_min_days': 28,    # YOUR RULE: strict monthly (28-32 days)
            'monthly_max_days': 32,
            'min_frequency': 3,        # Need at least 3 transactions to establish pattern
            'max_cv': 0.6,            # Reasonable consistency
            'min_cv': 0.05,
        }

        # No user profile adjustments - keeping it simple
        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create refined utilities-specific labeling functions"""

        def lf_utilities_naf_codes(x):
            """NAF codes for utilities - with 10 EUR minimum"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            utilities_naf_codes = [
                "35.11Z", "35.12Z", "35.13Z", "35.14Z", "35.21Z", "35.22Z", "35.23Z", "35.30Z",
                "36.00Z", "37.00Z", "38.11Z", "38.12Z", "38.21Z", "38.22Z", "38.31Z", "38.32Z", "39.00Z",
                "61.10Z", "61.20Z", "61.30Z", "61.90Z", "62.01Z", "62.02A", "62.02B", "63.11Z", "63.12Z"
            ]

            if str(x.NAF_CODE).strip() in utilities_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # Must be >= 10 EUR
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_utilities_major_providers(x):
            """Major utility providers - enhanced with amount validation"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Major French providers - more specific list
            major_utility_providers = [
                # Top French utilities (most reliable indicators)
                "EDF", "Engie", "Orange", "Free", "SFR", "Bouygues Telecom",
                "Veolia", "Suez", "Total Energies", "Total Direct Energie",

                # Secondary providers
                "Eni", "Vattenfall", "Planète OUI", "Mint Energie", "Happ-e",
                "Butagaz", "Antargaz", "Primagaz", "Saur", "Lyonnaise des Eaux",
                "Red by SFR", "Sosh", "B&You", "NRJ Mobile", "La Poste Mobile"
            ]

            merchant_lower = merchant_text.lower()
            for provider in major_utility_providers:
                if provider.lower() in merchant_lower:
                    # Must be expense >= 10 EUR
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_specific_keywords(x):
            """More specific utility keywords - reduced false positives"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # More specific keywords - removed generic terms like "facture", "bill"
            specific_utility_keywords = [
                # Electricity - specific terms
                'electricite', 'électricité', 'edf', 'engie', 'kwh', 'compteur electrique',

                # Gas - specific
                'gaz naturel', 'compteur gaz', 'butane', 'propane', 'engie gaz',

                # Water - specific
                'eau potable', 'veolia eau', 'suez eau', 'compteur eau', 'distribution eau',

                # Internet/Telecom - specific
                'internet', 'wifi', 'adsl', 'fibre optique', 'box internet',
                'forfait mobile', 'abonnement mobile', 'ligne telephonique',
                'orange internet', 'free internet', 'sfr box',

                # Waste - specific
                'ordures menageres', 'collecte dechets', 'ramassage poubelles'
            ]

            # Count matches to require stronger signal
            matches = sum(1 for keyword in specific_utility_keywords if keyword in text_to_check)

            if matches >= 1:  # At least one specific match
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # >= 10 EUR
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_text_anchor(x):
            """FastText similarity with stricter requirements"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher similarity threshold and must be >= 10 EUR
            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_monthly_pattern_strict(x):
            """YOUR RULES: Monthly pattern (28-32 days) with minimum 10 EUR"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency'] or
                x.amt_mean > self.thresholds['max_amount']):  # Must be >= 10 EUR
                return self.ABSTAIN

            # YOUR STRICT MONTHLY: 28-32 days between payments
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Keep consistency requirement
            has_good_consistency = (self.thresholds['min_cv'] <=
                                  x.amt_cv <=
                                  self.thresholds['max_cv'])

            if is_monthly and is_reasonable_amount and has_good_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_provider_and_pattern(x):
            """Combined provider + pattern check for higher confidence"""
            if pd.isna(x.MERCHANT) or x.amt_mean >= 0:
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Key utility indicators
            utility_indicators = ['edf', 'engie', 'orange', 'free', 'sfr', 'veolia', 'suez']
            has_utility_indicator = any(indicator in merchant_lower for indicator in utility_indicators)

            # Must have both utility indicator AND your rules
            if has_utility_indicator:
                has_your_pattern = (
                    x.amt_count >= 2 and
                    x.amt_mean <= self.thresholds['max_amount'] and  # >= 10 EUR
                    28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
                )

                if has_your_pattern:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_round_amounts_strict(x):
            """Round amounts with YOUR RULES: >= 10 EUR and monthly (28-32 days)"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or  # Must be >= 10 EUR
                x.amt_count < 3):  # Need at least 3 transactions
                return self.ABSTAIN

            # Check for very specific round amounts typical of utilities
            amount_abs = abs(int(x.amt_mean))

            # Common utility amounts (monthly subscriptions)
            common_utility_amounts = [20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100]
            is_common_amount = amount_abs in common_utility_amounts

            # Or ends in 9 (like 29, 39, 49) which are common for telecom
            ends_in_nine = str(amount_abs).endswith('9')

            # YOUR RULES: very consistent + monthly (28-32 days)
            meets_your_criteria = (
                x.amt_cv < 0.1 and  # Very consistent
                28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
            )

            if (is_common_amount or ends_in_nine) and meets_your_criteria:
                return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_utilities_under_10_euros(x):
            """YOUR RULE: Under 10 EUR cannot be utilities"""
            if x.amt_mean > self.thresholds['max_amount']:  # More than -10 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_groceries_indicators(x):
            """Exclude transactions that look like groceries"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_restaurant_indicators(x):
            """Exclude restaurant-like transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_very_frequent_small(x):
            """Very frequent small amounts are unlikely utilities"""
            if (x.amt_count > 10 and
                x.mean_delta_days < 7 and  # More than weekly
                x.amt_mean > -50):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_large(x):
            """Very large amounts unlikely to be utilities"""
            if x.amt_mean < -1000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_irregular(x):
            """Very irregular payments unlikely to be utilities"""
            if x.amt_count >= 3 and x.amt_cv > 1.5:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_utilities_naf_codes", f=lf_utilities_naf_codes),
            LabelingFunction(name="lf_utilities_major_providers", f=lf_utilities_major_providers),
            LabelingFunction(name="lf_utilities_specific_keywords", f=lf_utilities_specific_keywords),
            LabelingFunction(name="lf_utilities_text_anchor", f=lf_utilities_text_anchor),
            LabelingFunction(name="lf_utilities_monthly_pattern_strict", f=lf_utilities_monthly_pattern_strict),
            LabelingFunction(name="lf_utilities_provider_and_pattern", f=lf_utilities_provider_and_pattern),
            LabelingFunction(name="lf_utilities_round_amounts_strict", f=lf_utilities_round_amounts_strict),
            LabelingFunction(name="lf_not_utilities_under_10_euros", f=lf_not_utilities_under_10_euros),
            LabelingFunction(name="lf_not_utilities_groceries_indicators", f=lf_not_utilities_groceries_indicators),
            LabelingFunction(name="lf_not_utilities_restaurant_indicators", f=lf_not_utilities_restaurant_indicators),
            LabelingFunction(name="lf_not_utilities_very_frequent_small", f=lf_not_utilities_very_frequent_small),
            LabelingFunction(name="lf_not_utilities_positive_amounts", f=lf_not_utilities_positive_amounts),
            LabelingFunction(name="lf_not_utilities_very_large", f=lf_not_utilities_very_large),
            LabelingFunction(name="lf_not_utilities_very_irregular", f=lf_not_utilities_very_irregular),
        ]

# Test the refined classifier
utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.8)

# Check for improvement in precision
print(f"Total predicted utilities: {utilities_results['predicted_positive']}")
print(f"High confidence utilities: {utilities_results['high_confidence_positive']}")

class UtilitiesClassifier(CategoryClassifier):
    """Refined utilities classifier with better precision for small amounts"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Utilities", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_utilities_thresholds()

        # More specific utilities anchors - removed generic terms
        utilities_anchors = [
            "electricite", "electricity", "gaz", "eau", "internet",
            "telephone", "mobile", "telecom", "energie", "energy",
            "edf", "engie", "orange", "free", "sfr", "bouygues"
        ]
        self.setup_anchors(utilities_anchors, similarity_threshold=0.7)  # Higher threshold

    def _calculate_utilities_thresholds(self) -> dict:
        """Calculate utilities-specific thresholds with your criteria"""
        base_thresholds = {
            'min_amount': -500,        # Maximum utility bill
            'max_amount': -10,         # YOUR RULE: minimum 10 EUR
            'monthly_min_days': 28,    # YOUR RULE: strict monthly (28-32 days)
            'monthly_max_days': 32,
            'min_frequency': 3,        # Need at least 3 transactions to establish pattern
            'max_cv': 0.6,            # Reasonable consistency
            'min_cv': 0.05,
        }

        # No user profile adjustments - keeping it simple
        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create refined utilities-specific labeling functions"""

        def lf_utilities_naf_codes(x):
            """NAF codes for utilities - with 10 EUR minimum"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            utilities_naf_codes = [
                "35.11Z", "35.12Z", "35.13Z", "35.14Z", "35.21Z", "35.22Z", "35.23Z", "35.30Z",
                "36.00Z", "37.00Z", "38.11Z", "38.12Z", "38.21Z", "38.22Z", "38.31Z", "38.32Z", "39.00Z",
                "61.10Z", "61.20Z", "61.30Z", "61.90Z", "62.01Z", "62.02A", "62.02B", "63.11Z", "63.12Z"
            ]

            if str(x.NAF_CODE).strip() in utilities_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # Must be >= 10 EUR
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_utilities_major_providers(x):
            """Major utility providers - enhanced with amount validation"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Major French providers - more specific list
            major_utility_providers = [
                # Top French utilities (most reliable indicators)
                "EDF", "Engie", "Orange", "Free", "SFR", "Bouygues Telecom",
                "Veolia", "Suez", "Total Energies", "Total Direct Energie",

                # Secondary providers
                "Eni", "Vattenfall", "Planète OUI", "Mint Energie", "Happ-e",
                "Butagaz", "Antargaz", "Primagaz", "Saur", "Lyonnaise des Eaux",
                "Red by SFR", "Sosh", "B&You", "NRJ Mobile", "La Poste Mobile"
            ]

            merchant_lower = merchant_text.lower()
            for provider in major_utility_providers:
                if provider.lower() in merchant_lower:
                    # Must be expense >= 10 EUR
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_major_providers_high_confidence(x):
            """HIGH CONFIDENCE: Major providers with any frequency, no amount condition"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip()

            # Only the most reliable utility providers
            top_utility_providers = [
                "EDF", "Engie", "Orange", "Free", "SFR", "Bouygues Telecom",
                "Veolia", "Suez", "Total Energies", "Total Direct Energie"
            ]

            merchant_lower = merchant_text.lower()
            for provider in top_utility_providers:
                if provider.lower() in merchant_lower:
                    # Only requirement: must be expense (any amount) with some frequency
                    if x.amt_mean < 0 and x.amt_count >= 2:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_specific_keywords(x):
            """More specific utility keywords - reduced false positives"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # More specific keywords - removed generic terms like "facture", "bill"
            specific_utility_keywords = [
                # Electricity - specific terms
                'electricite', 'électricité', 'edf', 'engie', 'kwh', 'compteur electrique',

                # Gas - specific
                'gaz naturel', 'compteur gaz', 'butane', 'propane', 'engie gaz',

                # Water - specific
                'eau potable', 'veolia eau', 'suez eau', 'compteur eau', 'distribution eau',

                # Internet/Telecom - specific
                'internet', 'wifi', 'adsl', 'fibre optique', 'box internet',
                'forfait mobile', 'abonnement mobile', 'ligne telephonique',
                'orange internet', 'free internet', 'sfr box',

                # Waste - specific
                'ordures menageres', 'collecte dechets', 'ramassage poubelles'
            ]

            # Count matches to require stronger signal
            matches = sum(1 for keyword in specific_utility_keywords if keyword in text_to_check)

            if matches >= 1:  # At least one specific match
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # >= 10 EUR
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_text_anchor(x):
            """FastText similarity with stricter requirements"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher similarity threshold and must be >= 10 EUR
            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_monthly_pattern_strict(x):
            """YOUR RULES: Monthly pattern (28-32 days) with minimum 10 EUR"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency'] or
                x.amt_mean > self.thresholds['max_amount']):  # Must be >= 10 EUR
                return self.ABSTAIN

            # YOUR STRICT MONTHLY: 28-32 days between payments
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Keep consistency requirement
            has_good_consistency = (self.thresholds['min_cv'] <=
                                  x.amt_cv <=
                                  self.thresholds['max_cv'])

            if is_monthly and is_reasonable_amount and has_good_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_provider_and_pattern(x):
            """Combined provider + pattern check for higher confidence"""
            if pd.isna(x.MERCHANT) or x.amt_mean >= 0:
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Key utility indicators
            utility_indicators = ['edf', 'engie', 'orange', 'free', 'sfr', 'veolia', 'suez']
            has_utility_indicator = any(indicator in merchant_lower for indicator in utility_indicators)

            # Must have both utility indicator AND your rules
            if has_utility_indicator:
                has_your_pattern = (
                    x.amt_count >= 2 and
                    x.amt_mean <= self.thresholds['max_amount'] and  # >= 10 EUR
                    28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
                )

                if has_your_pattern:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_round_amounts_strict(x):
            """Round amounts with YOUR RULES: >= 10 EUR and monthly (28-32 days)"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or  # Must be >= 10 EUR
                x.amt_count < 3):  # Need at least 3 transactions
                return self.ABSTAIN

            # Check for very specific round amounts typical of utilities
            amount_abs = abs(int(x.amt_mean))

            # Common utility amounts (monthly subscriptions)
            common_utility_amounts = [20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100]
            is_common_amount = amount_abs in common_utility_amounts

            # Or ends in 9 (like 29, 39, 49) which are common for telecom
            ends_in_nine = str(amount_abs).endswith('9')

            # YOUR RULES: very consistent + monthly (28-32 days)
            meets_your_criteria = (
                x.amt_cv < 0.1 and  # Very consistent
                28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
            )

            if (is_common_amount or ends_in_nine) and meets_your_criteria:
                return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_utilities_under_10_euros(x):
            """YOUR RULE: Under 10 EUR cannot be utilities"""
            if x.amt_mean > self.thresholds['max_amount']:  # More than -10 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_groceries_indicators(x):
            """Exclude transactions that look like groceries"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_restaurant_indicators(x):
            """Exclude restaurant-like transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_very_frequent_small(x):
            """Very frequent small amounts are unlikely utilities"""
            if (x.amt_count > 10 and
                x.mean_delta_days < 7 and  # More than weekly
                x.amt_mean > -50):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_large(x):
            """Very large amounts unlikely to be utilities"""
            if x.amt_mean < -1000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_irregular(x):
            """Very irregular payments unlikely to be utilities"""
            if x.amt_count >= 3 and x.amt_cv > 1.5:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_utilities_naf_codes", f=lf_utilities_naf_codes),
            LabelingFunction(name="lf_utilities_major_providers", f=lf_utilities_major_providers),
            LabelingFunction(name="lf_utilities_major_providers_high_confidence", f=lf_utilities_major_providers_high_confidence),
            LabelingFunction(name="lf_utilities_specific_keywords", f=lf_utilities_specific_keywords),
            LabelingFunction(name="lf_utilities_text_anchor", f=lf_utilities_text_anchor),
            LabelingFunction(name="lf_utilities_monthly_pattern_strict", f=lf_utilities_monthly_pattern_strict),
            LabelingFunction(name="lf_utilities_provider_and_pattern", f=lf_utilities_provider_and_pattern),
            LabelingFunction(name="lf_utilities_round_amounts_strict", f=lf_utilities_round_amounts_strict),
            LabelingFunction(name="lf_not_utilities_under_10_euros", f=lf_not_utilities_under_10_euros),
            LabelingFunction(name="lf_not_utilities_groceries_indicators", f=lf_not_utilities_groceries_indicators),
            LabelingFunction(name="lf_not_utilities_restaurant_indicators", f=lf_not_utilities_restaurant_indicators),
            LabelingFunction(name="lf_not_utilities_very_frequent_small", f=lf_not_utilities_very_frequent_small),
            LabelingFunction(name="lf_not_utilities_positive_amounts", f=lf_not_utilities_positive_amounts),
            LabelingFunction(name="lf_not_utilities_very_large", f=lf_not_utilities_very_large),
            LabelingFunction(name="lf_not_utilities_very_irregular", f=lf_not_utilities_very_irregular),
        ]

# Test the refined classifier
utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.6)

# Check for improvement in precision
print(f"Total predicted utilities: {utilities_results['predicted_positive']}")
print(f"High confidence utilities: {utilities_results['high_confidence_positive']}")

class UtilitiesClassifier(CategoryClassifier):
    """Refined utilities classifier with better precision for small amounts"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Utilities", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_utilities_thresholds()

        # More specific utilities anchors - removed generic terms
        utilities_anchors = [
            "electricite", "electricity", "gaz", "eau", "internet",
            "telephone", "mobile", "telecom", "energie", "energy",
            "edf", "engie", "orange", "free", "sfr", "bouygues"
        ]
        self.setup_anchors(utilities_anchors, similarity_threshold=0.7)  # Higher threshold

    def _calculate_utilities_thresholds(self) -> dict:
        """Calculate utilities-specific thresholds with your criteria"""
        base_thresholds = {
            'min_amount': -500,        # Maximum utility bill
            'max_amount': -10,         # YOUR RULE: minimum 10 EUR
            'monthly_min_days': 28,    # YOUR RULE: strict monthly (28-32 days)
            'monthly_max_days': 32,
            'min_frequency': 3,        # Need at least 3 transactions to establish pattern
            'max_cv': 0.6,            # Reasonable consistency
            'min_cv': 0.05,
        }

        # No user profile adjustments - keeping it simple
        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create refined utilities-specific labeling functions"""

        def lf_utilities_naf_codes(x):
            """NAF codes for utilities - with 10 EUR minimum"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            utilities_naf_codes = [
                "35.11Z", "35.12Z", "35.13Z", "35.14Z", "35.21Z", "35.22Z", "35.23Z", "35.30Z",
                "36.00Z", "37.00Z", "38.11Z", "38.12Z", "38.21Z", "38.22Z", "38.31Z", "38.32Z", "39.00Z",
                "61.10Z", "61.20Z", "61.30Z", "61.90Z", "62.01Z", "62.02A", "62.02B", "63.11Z", "63.12Z"
            ]

            if str(x.NAF_CODE).strip() in utilities_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # Must be >= 10 EUR
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_utilities_major_providers(x):
            """Major utility providers - enhanced with amount validation"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()  # Convert to uppercase

            # Extended list of providers (in uppercase)
            major_utility_providers = [
                "EDF", "ENGIE", "ORANGE", "FREE", "SFR", "BOUYGUES",
                "VEOLIA", "SUEZ", "TOTAL", "ENI", "VATTENFALL",
                "PLANETE", "MINT", "HAPP", "BUTAGAZ", "ANTARGAZ",
                "PRIMAGAZ", "SAUR", "LYONNAISE", "RED", "SOSH",
                "NRJ", "POSTE"
            ]

            # Check if any provider name appears in the merchant text
            for provider in major_utility_providers:
                if provider in merchant_text:  # Simple substring match
                    # Must be expense >= 10 EUR
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_major_providers_high_confidence(x):
            """HIGH CONFIDENCE: Major providers with any frequency, no amount condition"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()  # Convert to uppercase for matching

            # Only the most reliable utility providers (in uppercase)
            top_utility_providers = [
                "EDF", "ENGIE", "ORANGE", "FREE", "SFR", "BOUYGUES",
                "VEOLIA", "SUEZ", "TOTAL"
            ]

            # Check if any provider name appears anywhere in the merchant text
            for provider in top_utility_providers:
                if provider in merchant_text:  # Simple substring match
                    # Only requirement: must be expense (any amount) with some frequency
                    if x.amt_mean < 0 and x.amt_count >= 2:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_specific_keywords(x):
            """More specific utility keywords - reduced false positives"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # More specific keywords - removed generic terms like "facture", "bill"
            specific_utility_keywords = [
                # Electricity - specific terms
                'electricite', 'électricité', 'edf', 'engie', 'kwh', 'compteur electrique',

                # Gas - specific
                'gaz naturel', 'compteur gaz', 'butane', 'propane', 'engie gaz',

                # Water - specific
                'eau potable', 'veolia eau', 'suez eau', 'compteur eau', 'distribution eau',

                # Internet/Telecom - specific
                'internet', 'wifi', 'adsl', 'fibre optique', 'box internet',
                'forfait mobile', 'abonnement mobile', 'ligne telephonique',
                'orange internet', 'free internet', 'sfr box',

                # Waste - specific
                'ordures menageres', 'collecte dechets', 'ramassage poubelles'
            ]

            # Count matches to require stronger signal
            matches = sum(1 for keyword in specific_utility_keywords if keyword in text_to_check)

            if matches >= 1:  # At least one specific match
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:  # >= 10 EUR
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_text_anchor(x):
            """FastText similarity with stricter requirements"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Higher similarity threshold and must be >= 10 EUR
            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_monthly_pattern_strict(x):
            """YOUR RULES: Monthly pattern (28-32 days) with minimum 10 EUR"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency'] or
                x.amt_mean > self.thresholds['max_amount']):  # Must be >= 10 EUR
                return self.ABSTAIN

            # YOUR STRICT MONTHLY: 28-32 days between payments
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])

            # Keep consistency requirement
            has_good_consistency = (self.thresholds['min_cv'] <=
                                  x.amt_cv <=
                                  self.thresholds['max_cv'])

            if is_monthly and is_reasonable_amount and has_good_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_provider_and_pattern(x):
            """Combined provider + pattern check for higher confidence"""
            if pd.isna(x.MERCHANT) or x.amt_mean >= 0:
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Key utility indicators
            utility_indicators = ['edf', 'engie', 'orange', 'free', 'sfr', 'veolia', 'suez']
            has_utility_indicator = any(indicator in merchant_lower for indicator in utility_indicators)

            # Must have both utility indicator AND your rules
            if has_utility_indicator:
                has_your_pattern = (
                    x.amt_count >= 2 and
                    x.amt_mean <= self.thresholds['max_amount'] and  # >= 10 EUR
                    28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
                )

                if has_your_pattern:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_utilities_round_amounts_strict(x):
            """Round amounts with YOUR RULES: >= 10 EUR and monthly (28-32 days)"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or  # Must be >= 10 EUR
                x.amt_count < 3):  # Need at least 3 transactions
                return self.ABSTAIN

            # Check for very specific round amounts typical of utilities
            amount_abs = abs(int(x.amt_mean))

            # Common utility amounts (monthly subscriptions)
            common_utility_amounts = [20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100]
            is_common_amount = amount_abs in common_utility_amounts

            # Or ends in 9 (like 29, 39, 49) which are common for telecom
            ends_in_nine = str(amount_abs).endswith('9')

            # YOUR RULES: very consistent + monthly (28-32 days)
            meets_your_criteria = (
                x.amt_cv < 0.1 and  # Very consistent
                28 <= x.mean_delta_days <= 32  # YOUR STRICT MONTHLY
            )

            if (is_common_amount or ends_in_nine) and meets_your_criteria:
                return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_utilities_under_10_euros(x):
            """YOUR RULE: Under 10 EUR cannot be utilities"""
            if x.amt_mean > self.thresholds['max_amount']:  # More than -10 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_groceries_indicators(x):
            """Exclude transactions that look like groceries"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_restaurant_indicators(x):
            """Exclude restaurant-like transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_utilities_very_frequent_small(x):
            """Very frequent small amounts are unlikely utilities"""
            if (x.amt_count > 10 and
                x.mean_delta_days < 7 and  # More than weekly
                x.amt_mean > -50):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_large(x):
            """Very large amounts unlikely to be utilities"""
            if x.amt_mean < -1000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_utilities_very_irregular(x):
            """Very irregular payments unlikely to be utilities"""
            if x.amt_count >= 3 and x.amt_cv > 1.5:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_utilities_naf_codes", f=lf_utilities_naf_codes),
            LabelingFunction(name="lf_utilities_major_providers", f=lf_utilities_major_providers),
            LabelingFunction(name="lf_utilities_major_providers_high_confidence", f=lf_utilities_major_providers_high_confidence),
            LabelingFunction(name="lf_utilities_specific_keywords", f=lf_utilities_specific_keywords),
            LabelingFunction(name="lf_utilities_text_anchor", f=lf_utilities_text_anchor),
            LabelingFunction(name="lf_utilities_monthly_pattern_strict", f=lf_utilities_monthly_pattern_strict),
            LabelingFunction(name="lf_utilities_provider_and_pattern", f=lf_utilities_provider_and_pattern),
            LabelingFunction(name="lf_utilities_round_amounts_strict", f=lf_utilities_round_amounts_strict),
            LabelingFunction(name="lf_not_utilities_under_10_euros", f=lf_not_utilities_under_10_euros),
            LabelingFunction(name="lf_not_utilities_groceries_indicators", f=lf_not_utilities_groceries_indicators),
            LabelingFunction(name="lf_not_utilities_restaurant_indicators", f=lf_not_utilities_restaurant_indicators),
            LabelingFunction(name="lf_not_utilities_very_frequent_small", f=lf_not_utilities_very_frequent_small),
            LabelingFunction(name="lf_not_utilities_positive_amounts", f=lf_not_utilities_positive_amounts),
            LabelingFunction(name="lf_not_utilities_very_large", f=lf_not_utilities_very_large),
            LabelingFunction(name="lf_not_utilities_very_irregular", f=lf_not_utilities_very_irregular),
        ]

# Test the refined classifier
utilities_classifier = UtilitiesClassifier(ft, merchant_agg_df, user_profile)
utilities_results = utilities_classifier.run_full_pipeline(confidence_threshold=0.6)

# Check for improvement in precision
print(f"Total predicted utilities: {utilities_results['predicted_positive']}")
print(f"High confidence utilities: {utilities_results['high_confidence_positive']}")

"""Other

### Telephony

Under Utilities for now

### Household
"""

class HouseholdClassifier(CategoryClassifier):
    """Household/Home Goods classifier for furniture, kitchenware, home improvement"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Household", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_household_thresholds()

        # Household-specific anchors
        household_anchors = [
            "meuble", "furniture", "maison", "home", "decoration", "amenagement",
            "bricolage", "ikea", "castorama", "ustensile", "outil", "renovation",
            "canape", "table", "chaise", "lit", "armoire", "cuisine", "salle",
            "jardin", "garden", "terrasse", "balcon"
        ]
        self.setup_anchors(household_anchors, similarity_threshold=0.65)

    def _calculate_household_thresholds(self) -> dict:
        """Calculate household-specific thresholds"""
        base_thresholds = {
            'min_amount': -3000,        # Large furniture/appliances possible
            'max_amount': -20,          # Minimum meaningful household expense
            'min_days_between': 60,     # At least 2 months between purchases
            'max_days_between': 730,    # Up to 2 years for major items
            'min_frequency': 2,         # Need some pattern
            'max_cv': 2.5,             # Allow high variability
            'min_cv': 0.1,             # Some variance expected
            'seasonal_variance': True   # Expect seasonal patterns
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -5000,    # Higher spending capacity
                    'max_amount': -50       # Higher minimum threshold
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -1500,    # Lower spending capacity
                    'max_amount': -15       # Lower minimum threshold
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create household-specific labeling functions"""

        def lf_household_naf_codes(x):
            """NAF codes for household/furniture retailers"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            household_naf_codes = [
                # Furniture and home goods
                "47.51Z",  # Retail sale of textiles
                "47.52A",  # Hardware stores
                "47.52B",  # DIY stores
                "47.53Z",  # Carpets, rugs, wall/floor coverings
                "47.54Z",  # Household appliances, furniture, lighting
                "47.59A",  # Furniture stores
                "47.59B",  # Other household equipment
                "47.78A",  # Other retail (household goods)
                "47.78B",  # Retail sale via stalls and markets of other goods
                "26.51A",  # Manufacture of instruments and appliances for measuring
                "27.51Z",  # Manufacture of electric domestic appliances
                "31.01Z",  # Manufacture of office and shop furniture
                "31.02Z",  # Manufacture of kitchen furniture
                "31.03Z",  # Manufacture of mattresses
                "31.09A",  # Manufacture of furniture for sitting and lying
                "31.09B",  # Manufacture of other furniture
            ]

            if str(x.NAF_CODE).strip() in household_naf_codes:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_household_major_retailers(x):
            """Major household/furniture retailers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Major household retailers (in uppercase)
            household_retailers = [
                # Furniture
                "IKEA", "BUT", "CONFORAMA", "FLY", "MAISONS DU MONDE",
                "ROCHE BOBOIS", "HABITAT", "WEST ELM", "WAYFAIR", "MADE",
                "LA REDOUTE", "3 SUISSES", "ALINEA", "CASA", "CENTRAKOR",

                # Home improvement
                "LEROY MERLIN", "CASTORAMA", "BRICORAMA", "BRICO DEPOT",
                "BRICO MARCHE", "WELDOM", "POINT P", "GEDIMAT",
                "HOME DEPOT", "LOWE'S", "B&Q", "HOMEBASE",

                # Department stores (home sections)
                "BHV", "SAMARITAINE", "PRINTEMPS MAISON",
                "GALERIES LAFAYETTE MAISON",

                # Appliances/Electronics (for household items)
                "DARTY", "BOULANGER", "FNAC", "ELECTRO DEPOT",

                # Garden centers
                "JARDILAND", "TRUFFAUT", "BOTANIC", "GAMM VERT",

                # Online/Catalog
                "AMAZON", "CDISCOUNT", "RUE DU COMMERCE", "MANOMANO"
            ]

            # Check for retailer match
            for retailer in household_retailers:
                if retailer in merchant_text:
                    if (x.amt_mean < 0 and
                        self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_household_keywords_comprehensive(x):
            """Comprehensive household keywords detection"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Comprehensive household keywords
            household_keywords = {
                # Furniture
                'furniture': ['meuble', 'furniture', 'canape', 'sofa', 'fauteuil', 'armchair',
                             'table', 'chaise', 'chair', 'lit', 'bed', 'matelas', 'mattress',
                             'armoire', 'closet', 'placard', 'etagere', 'shelf', 'bibliotheque',
                             'commode', 'dresser', 'buffet', 'sideboard'],

                # Home textiles
                'textiles': ['rideau', 'curtain', 'voilage', 'tapis', 'carpet', 'moquette',
                            'housse', 'cover', 'coussin', 'pillow', 'oreiller', 'drap', 'sheet',
                            'serviette', 'towel', 'nappe', 'tablecloth', 'linge', 'textile'],

                # Kitchenware (non-food)
                'kitchen': ['casserole', 'poele', 'pan', 'sauteuse', 'assiette', 'plate',
                           'verre', 'glass', 'tasse', 'cup', 'bol', 'bowl', 'couverts', 'cutlery',
                           'fourchette', 'fork', 'couteau', 'knife', 'cuillere', 'spoon',
                           'ustensile', 'cookware', 'batterie cuisine', 'vaisselle', 'dishes'],

                # Home improvement/DIY
                'diy': ['bricolage', 'diy', 'renovation', 'travaux', 'peinture', 'paint',
                       'outil', 'tool', 'perceuse', 'drill', 'marteau', 'hammer',
                       'tournevis', 'screwdriver', 'clou', 'nail', 'vis', 'screw',
                       'materiau', 'material', 'bois', 'wood', 'metal'],

                # Decoration
                'decor': ['decoration', 'deco', 'ornement', 'cadre', 'frame', 'miroir', 'mirror',
                         'luminaire', 'lighting', 'lampe', 'lamp', 'applique', 'lustre',
                         'chandelier', 'bougie', 'candle', 'vase', 'pot', 'plante', 'plant'],

                # Garden/Outdoor
                'garden': ['jardin', 'garden', 'terrasse', 'terrace', 'balcon', 'balcony',
                          'parasol', 'tondeuse', 'mower', 'arrosoir', 'watering', 'pot',
                          'plantation', 'graine', 'seed', 'engrais', 'fertilizer'],

                # Appliances
                'appliances': ['electromenager', 'appliance', 'refrigerateur', 'fridge',
                              'lave', 'washing', 'seche', 'dryer', 'four', 'oven',
                              'micro', 'onde', 'aspirateur', 'vacuum', 'fer', 'iron']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in household_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Require strong signal (multiple matches or specific categories)
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'furniture' in category_matches or  # Furniture is strong signal
                'appliances' in category_matches or  # Appliances are strong signal
                category_matches.get('diy', 0) >= 2  # Multiple DIY matches
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_household_text_anchor(x):
            """FastText similarity for household terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_infrequent_pattern(x):
            """Household pattern: infrequent, variable amounts"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency']):
                return self.ABSTAIN

            # Household characteristics
            is_infrequent = x.mean_delta_days >= self.thresholds['min_days_between']
            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])
            has_acceptable_variance = x.amt_cv <= self.thresholds['max_cv']

            # Not too regular (unlike utilities)
            not_too_regular = x.mean_delta_days > 45  # More than 1.5 months

            if (is_infrequent and is_reasonable_amount and
                has_acceptable_variance and not_too_regular):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_seasonal_large_purchases(x):
            """Detect seasonal/occasional large household purchases"""
            if (x.amt_mean >= 0 or x.amt_count < 2):
                return self.ABSTAIN

            # Large, infrequent purchases (moving, renovation, etc.)
            is_large_purchase = x.amt_mean < -200
            is_very_infrequent = x.mean_delta_days > 120  # More than 4 months
            has_some_consistency = x.amt_cv <= 1.5  # Not completely random

            if is_large_purchase and is_very_infrequent and has_some_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_ikea_pattern(x):
            """Specific pattern for IKEA-like stores (known household retailers)"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Known household furniture stores
            furniture_stores = ['ikea', 'but', 'conforama', 'fly', 'maisons du monde',
                               'habitat', 'alinea', 'casa', 'leroy merlin', 'castorama']

            has_furniture_store = any(store in merchant_lower for store in furniture_stores)

            if has_furniture_store:
                # Any reasonable expense amount and frequency for these stores
                if (x.amt_mean < 0 and
                    x.amt_mean >= -2000 and  # Not extremely large
                    x.amt_count >= 1):  # At least one transaction
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_household_groceries_pattern(x):
            """Exclude grocery-like patterns"""
            if (x.amt_count >= 8 and  # Very frequent
                x.mean_delta_days <= 21 and  # More than every 3 weeks
                -200 <= x.amt_mean <= -10 and  # Grocery-like amounts
                x.amt_cv <= 0.8):  # Too consistent for household
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_utilities_pattern(x):
            """Exclude utility-like patterns"""
            if (x.amt_count >= 6 and  # Regular frequency
                25 <= x.mean_delta_days <= 35 and  # Monthly-ish
                x.amt_cv <= 0.3 and  # Very consistent
                -150 <= x.amt_mean <= -15):  # Utility-like amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_restaurant_indicators(x):
            """Exclude restaurant/food service transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie', 'bistrot',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway', 'burger',
                'delivery', 'livraison', 'takeaway', 'emporter'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_transport_indicators(x):
            """Exclude transport-related transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'gazole', 'carburant', 'fuel', 'station',
                'peage', 'toll', 'parking', 'metro', 'bus', 'train',
                'sncf', 'ratp', 'uber', 'taxi', 'autoroute'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_small_amounts(x):
            """Very small amounts unlikely to be household"""
            if x.amt_mean > self.thresholds['max_amount']:  # Above minimum threshold
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_frequent_small(x):
            """Very frequent small amounts (likely groceries or daily expenses)"""
            if (x.amt_count > 15 and  # Very frequent
                x.mean_delta_days < 10 and  # More than weekly
                x.amt_mean > -100):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_extremely_large(x):
            """Extremely large amounts (likely real estate, cars, etc.)"""
            if x.amt_mean < -10000:  # More than 10k EUR
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_household_naf_codes", f=lf_household_naf_codes),
            LabelingFunction(name="lf_household_major_retailers", f=lf_household_major_retailers),
            LabelingFunction(name="lf_household_keywords_comprehensive", f=lf_household_keywords_comprehensive),
            LabelingFunction(name="lf_household_text_anchor", f=lf_household_text_anchor),
            LabelingFunction(name="lf_household_infrequent_pattern", f=lf_household_infrequent_pattern),
            LabelingFunction(name="lf_household_seasonal_large_purchases", f=lf_household_seasonal_large_purchases),
            LabelingFunction(name="lf_household_ikea_pattern", f=lf_household_ikea_pattern),
            LabelingFunction(name="lf_not_household_groceries_pattern", f=lf_not_household_groceries_pattern),
            LabelingFunction(name="lf_not_household_utilities_pattern", f=lf_not_household_utilities_pattern),
            LabelingFunction(name="lf_not_household_restaurant_indicators", f=lf_not_household_restaurant_indicators),
            LabelingFunction(name="lf_not_household_transport_indicators", f=lf_not_household_transport_indicators),
            LabelingFunction(name="lf_not_household_positive_amounts", f=lf_not_household_positive_amounts),
            LabelingFunction(name="lf_not_household_very_small_amounts", f=lf_not_household_very_small_amounts),
            LabelingFunction(name="lf_not_household_very_frequent_small", f=lf_not_household_very_frequent_small),
            LabelingFunction(name="lf_not_household_extremely_large", f=lf_not_household_extremely_large),
        ]


# Usage function
def create_household_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run household classifier"""

    # Create classifier instance
    classifier = HouseholdClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
household_excel = extract_lf_results_to_excel(
    household_classifier, merchant_agg_df, "household_lf_detailed_results.xlsx"
)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")
"""

household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.7)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")

"""Parce qu'il y a casa dans boutique !"""

class HouseholdClassifier(CategoryClassifier):
    """Household/Home Goods classifier for furniture, kitchenware, home improvement"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Household", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_household_thresholds()

        # Household-specific anchors
        household_anchors = [
            "meuble", "furniture", "maison", "home", "decoration", "amenagement",
            "bricolage", "ikea", "castorama", "ustensile", "outil", "renovation",
            "canape", "table", "chaise", "lit", "armoire", "cuisine", "salle",
            "jardin", "garden", "terrasse", "balcon"
        ]
        self.setup_anchors(household_anchors, similarity_threshold=0.65)

    def _calculate_household_thresholds(self) -> dict:
        """Calculate household-specific thresholds based on user income"""
        base_thresholds = {
            'min_amount': -15000,       # Kitchen renovation possible
            'max_amount': -20,          # Minimum meaningful household expense
            'min_days_between': 60,     # At least 2 months between purchases
            'max_days_between': 730,    # Up to 2 years for major items
            'min_frequency': 2,         # Need some pattern
            'max_cv': 2.5,             # Allow high variability
            'min_cv': 0.1,             # Some variance expected
            'seasonal_variance': True   # Expect seasonal patterns
        }

        # Significantly adjust based on user income for major purchases
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -25000,   # High-end kitchen/renovation possible
                    'max_amount': -50,      # Higher minimum threshold
                    'luxury_threshold': -5000  # For luxury furniture detection
                })
            elif self.user_profile.monthly_income_range == "3000_4000":
                base_thresholds.update({
                    'min_amount': -18000,   # Mid-range renovation possible
                    'max_amount': -30,
                    'luxury_threshold': -3000
                })
            elif self.user_profile.monthly_income_range == "2000_3000":
                base_thresholds.update({
                    'min_amount': -12000,   # Modest renovation possible
                    'max_amount': -25,
                    'luxury_threshold': -2000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -8000,    # Basic renovation only
                    'max_amount': -15,      # Lower minimum threshold
                    'luxury_threshold': -1000
                })
        else:
            # Default for unknown income
            base_thresholds['luxury_threshold'] = -3000

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create household-specific labeling functions"""

        def lf_household_naf_codes(x):
            """NAF codes for household/furniture retailers"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            household_naf_codes = [
                # Furniture and home goods
                "47.51Z",  # Retail sale of textiles
                "47.52A",  # Hardware stores
                "47.52B",  # DIY stores
                "47.53Z",  # Carpets, rugs, wall/floor coverings
                "47.54Z",  # Household appliances, furniture, lighting
                "47.59A",  # Furniture stores
                "47.59B",  # Other household equipment
                "47.78A",  # Other retail (household goods)
                "47.78B",  # Retail sale via stalls and markets of other goods
                "26.51A",  # Manufacture of instruments and appliances for measuring
                "27.51Z",  # Manufacture of electric domestic appliances
                "31.01Z",  # Manufacture of office and shop furniture
                "31.02Z",  # Manufacture of kitchen furniture
                "31.03Z",  # Manufacture of mattresses
                "31.09A",  # Manufacture of furniture for sitting and lying
                "31.09B",  # Manufacture of other furniture
            ]

            if str(x.NAF_CODE).strip() in household_naf_codes:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_household_major_retailers_high_confidence(x):
            """HIGH CONFIDENCE: Major household retailers are strongest indicators"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # STRONGEST household indicators - these merchants are almost exclusively household
            top_household_retailers = [
                # Pure furniture stores
                "IKEA", "BUT", "CONFORAMA", "FLY", "MAISONS DU MONDE",
                "ROCHE BOBOIS", "HABITAT", "ALINEA", "CASA",

                # Pure home improvement
                "LEROY MERLIN", "CASTORAMA", "BRICORAMA", "BRICO DEPOT",
                "BRICO MARCHE", "WELDOM",

                # Garden centers
                "JARDILAND", "TRUFFAUT", "BOTANIC", "GAMM VERT"
            ]

            # For these top retailers, very relaxed criteria
            for retailer in top_household_retailers:
                if retailer in merchant_text:
                    # Only requirements: expense + reasonable amount for the income level
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount'] and  # Income-adjusted max
                        x.amt_count >= 1):  # At least one transaction
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_household_major_retailers(x):
            """Regular confidence: Secondary household retailers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Secondary household retailers (may sell other things too)
            secondary_household_retailers = [
                # Department stores (home sections)
                "BHV", "SAMARITAINE", "PRINTEMPS MAISON",
                "GALERIES LAFAYETTE MAISON",

                # Appliances/Electronics (for household items)
                "DARTY", "BOULANGER", "FNAC", "ELECTRO DEPOT",

                # Online/Catalog (mixed retailers)
                "AMAZON", "CDISCOUNT", "RUE DU COMMERCE", "MANOMANO",
                "LA REDOUTE", "3 SUISSES", "CENTRAKOR"
            ]

            # For secondary retailers, require amount validation
            for retailer in secondary_household_retailers:
                if retailer in merchant_text:
                    if (x.amt_mean < 0 and
                        self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_household_keywords_comprehensive(x):
            """Comprehensive household keywords detection"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Comprehensive household keywords
            household_keywords = {
                # Furniture
                'furniture': ['meuble', 'furniture', 'canape', 'sofa', 'fauteuil', 'armchair',
                             'table', 'chaise', 'chair', 'lit', 'bed', 'matelas', 'mattress',
                             'armoire', 'closet', 'placard', 'etagere', 'shelf', 'bibliotheque',
                             'commode', 'dresser', 'buffet', 'sideboard'],

                # Home textiles
                'textiles': ['rideau', 'curtain', 'voilage', 'tapis', 'carpet', 'moquette',
                            'housse', 'cover', 'coussin', 'pillow', 'oreiller', 'drap', 'sheet',
                            'serviette', 'towel', 'nappe', 'tablecloth', 'linge', 'textile'],

                # Kitchenware (non-food)
                'kitchen': ['casserole', 'poele', 'pan', 'sauteuse', 'assiette', 'plate',
                           'verre', 'glass', 'tasse', 'cup', 'bol', 'bowl', 'couverts', 'cutlery',
                           'fourchette', 'fork', 'couteau', 'knife', 'cuillere', 'spoon',
                           'ustensile', 'cookware', 'batterie cuisine', 'vaisselle', 'dishes'],

                # Home improvement/DIY
                'diy': ['bricolage', 'diy', 'renovation', 'travaux', 'peinture', 'paint',
                       'outil', 'tool', 'perceuse', 'drill', 'marteau', 'hammer',
                       'tournevis', 'screwdriver', 'clou', 'nail', 'vis', 'screw',
                       'materiau', 'material', 'bois', 'wood', 'metal'],

                # Decoration
                'decor': ['decoration', 'deco', 'ornement', 'cadre', 'frame', 'miroir', 'mirror',
                         'luminaire', 'lighting', 'lampe', 'lamp', 'applique', 'lustre',
                         'chandelier', 'bougie', 'candle', 'vase', 'pot', 'plante', 'plant'],

                # Garden/Outdoor
                'garden': ['jardin', 'garden', 'terrasse', 'terrace', 'balcon', 'balcony',
                          'parasol', 'tondeuse', 'mower', 'arrosoir', 'watering', 'pot',
                          'plantation', 'graine', 'seed', 'engrais', 'fertilizer'],

                # Appliances
                'appliances': ['electromenager', 'appliance', 'refrigerateur', 'fridge',
                              'lave', 'washing', 'seche', 'dryer', 'four', 'oven',
                              'micro', 'onde', 'aspirateur', 'vacuum', 'fer', 'iron']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in household_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Require strong signal (multiple matches or specific categories)
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'furniture' in category_matches or  # Furniture is strong signal
                'appliances' in category_matches or  # Appliances are strong signal
                category_matches.get('diy', 0) >= 2  # Multiple DIY matches
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_household_text_anchor(x):
            """FastText similarity for household terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_infrequent_pattern(x):
            """Household pattern: infrequent, variable amounts"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency']):
                return self.ABSTAIN

            # Household characteristics
            is_infrequent = x.mean_delta_days >= self.thresholds['min_days_between']
            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])
            has_acceptable_variance = x.amt_cv <= self.thresholds['max_cv']

            # Not too regular (unlike utilities)
            not_too_regular = x.mean_delta_days > 45  # More than 1.5 months

            if (is_infrequent and is_reasonable_amount and
                has_acceptable_variance and not_too_regular):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_major_renovation_projects(x):
            """Detect major renovation projects (kitchen, bathroom, etc.)"""
            if (x.amt_mean >= 0 or x.amt_count < 1):
                return self.ABSTAIN

            # Large renovation amounts based on income
            luxury_threshold = self.thresholds.get('luxury_threshold', -3000)

            # Very large purchases that could be renovation projects
            is_major_renovation = x.amt_mean < luxury_threshold

            # Check for renovation-related text
            renovation_indicators = []
            if not pd.isna(x.MERCHANT):
                renovation_indicators.append(str(x.MERCHANT).lower())
            if not pd.isna(x.CLEANED_TEXT):
                renovation_indicators.append(str(x.CLEANED_TEXT).lower())

            text_to_check = " ".join(renovation_indicators)

            renovation_keywords = [
                'cuisine', 'kitchen', 'salle de bain', 'bathroom', 'renovation',
                'amenagement', 'travaux', 'installation', 'pose', 'menuiserie',
                'plomberie', 'electricite', 'carrelage', 'parquet', 'peinture'
            ]

            has_renovation_context = any(keyword in text_to_check for keyword in renovation_keywords)

            if is_major_renovation and (has_renovation_context or x.amt_mean < luxury_threshold * 2):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_ikea_pattern(x):
            """Specific pattern for IKEA-like stores (known household retailers)"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Known household furniture stores
            furniture_stores = ['ikea', 'but', 'conforama', 'fly', 'maisons du monde',
                               'habitat', 'alinea', 'casa', 'leroy merlin', 'castorama']

            has_furniture_store = any(store in merchant_lower for store in furniture_stores)

            if has_furniture_store:
                # Any reasonable expense amount and frequency for these stores
                if (x.amt_mean < 0 and
                    x.amt_mean >= -2000 and  # Not extremely large
                    x.amt_count >= 1):  # At least one transaction
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_household_groceries_pattern(x):
            """Exclude grocery-like patterns"""
            if (x.amt_count >= 8 and  # Very frequent
                x.mean_delta_days <= 21 and  # More than every 3 weeks
                -200 <= x.amt_mean <= -10 and  # Grocery-like amounts
                x.amt_cv <= 0.8):  # Too consistent for household
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_utilities_pattern(x):
            """Exclude utility-like patterns"""
            if (x.amt_count >= 6 and  # Regular frequency
                25 <= x.mean_delta_days <= 35 and  # Monthly-ish
                x.amt_cv <= 0.3 and  # Very consistent
                -150 <= x.amt_mean <= -15):  # Utility-like amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_restaurant_indicators(x):
            """Exclude restaurant/food service transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie', 'bistrot',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway', 'burger',
                'delivery', 'livraison', 'takeaway', 'emporter'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_transport_indicators(x):
            """Exclude transport-related transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'gazole', 'carburant', 'fuel', 'station',
                'peage', 'toll', 'parking', 'metro', 'bus', 'train',
                'sncf', 'ratp', 'uber', 'taxi', 'autoroute'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_small_amounts(x):
            """Very small amounts unlikely to be household"""
            if x.amt_mean > self.thresholds['max_amount']:  # Above minimum threshold
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_frequent_small(x):
            """Very frequent small amounts (likely groceries or daily expenses)"""
            if (x.amt_count > 15 and  # Very frequent
                x.mean_delta_days < 10 and  # More than weekly
                x.amt_mean > -100):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_extremely_large(x):
            """Extremely large amounts (likely real estate, cars, etc.)"""
            # Use income-adjusted threshold instead of fixed amount
            max_reasonable = self.thresholds['min_amount'] * 2  # Double the max household threshold

            if x.amt_mean < max_reasonable:  # Beyond reasonable household expense
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_household_naf_codes", f=lf_household_naf_codes),
            LabelingFunction(name="lf_household_major_retailers_high_confidence", f=lf_household_major_retailers_high_confidence),
            LabelingFunction(name="lf_household_major_retailers", f=lf_household_major_retailers),
            LabelingFunction(name="lf_household_keywords_comprehensive", f=lf_household_keywords_comprehensive),
            LabelingFunction(name="lf_household_text_anchor", f=lf_household_text_anchor),
            LabelingFunction(name="lf_household_infrequent_pattern", f=lf_household_infrequent_pattern),
            LabelingFunction(name="lf_household_major_renovation_projects", f=lf_household_major_renovation_projects),
            LabelingFunction(name="lf_household_ikea_pattern", f=lf_household_ikea_pattern),
            LabelingFunction(name="lf_not_household_groceries_pattern", f=lf_not_household_groceries_pattern),
            LabelingFunction(name="lf_not_household_utilities_pattern", f=lf_not_household_utilities_pattern),
            LabelingFunction(name="lf_not_household_restaurant_indicators", f=lf_not_household_restaurant_indicators),
            LabelingFunction(name="lf_not_household_transport_indicators", f=lf_not_household_transport_indicators),
            LabelingFunction(name="lf_not_household_positive_amounts", f=lf_not_household_positive_amounts),
            LabelingFunction(name="lf_not_household_very_frequent_small", f=lf_not_household_very_frequent_small),
            LabelingFunction(name="lf_not_household_extremely_large", f=lf_not_household_extremely_large),
        ]


# Usage function
def create_household_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run household classifier"""

    # Create classifier instance
    classifier = HouseholdClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
household_excel = extract_lf_results_to_excel(
    household_classifier, merchant_agg_df, "household_lf_detailed_results.xlsx"
)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")
"""

household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export results
household_excel = extract_lf_results_to_excel(
    household_classifier, merchant_agg_df, "household_lf_detailed_results.xlsx"
)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")

class HouseholdClassifier(CategoryClassifier):
    """Household/Home Goods classifier for furniture, kitchenware, home improvement"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Household", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_household_thresholds()

        # Household-specific anchors
        household_anchors = [
            "meuble", "furniture", "maison", "home", "decoration", "amenagement",
            "bricolage", "ikea", "castorama", "ustensile", "outil", "renovation",
            "canape", "table", "chaise", "lit", "armoire", "cuisine", "salle",
            "jardin", "garden", "terrasse", "balcon"
        ]
        self.setup_anchors(household_anchors, similarity_threshold=0.65)

    def _calculate_household_thresholds(self) -> dict:
        """Calculate household-specific thresholds based on user income"""
        base_thresholds = {
            'min_amount': -15000,       # Kitchen renovation possible
            'max_amount': -20,          # Minimum meaningful household expense
            'min_days_between': 60,     # At least 2 months between purchases
            'max_days_between': 730,    # Up to 2 years for major items
            'min_frequency': 2,         # Need some pattern
            'max_cv': 2.5,             # Allow high variability
            'min_cv': 0.1,             # Some variance expected
            'seasonal_variance': True   # Expect seasonal patterns
        }

        # Significantly adjust based on user income for major purchases
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -25000,   # High-end kitchen/renovation possible
                    'max_amount': -50,      # Higher minimum threshold
                    'luxury_threshold': -5000  # For luxury furniture detection
                })
            elif self.user_profile.monthly_income_range == "3000_4000":
                base_thresholds.update({
                    'min_amount': -18000,   # Mid-range renovation possible
                    'max_amount': -30,
                    'luxury_threshold': -3000
                })
            elif self.user_profile.monthly_income_range == "2000_3000":
                base_thresholds.update({
                    'min_amount': -12000,   # Modest renovation possible
                    'max_amount': -25,
                    'luxury_threshold': -2000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -8000,    # Basic renovation only
                    'max_amount': -15,      # Lower minimum threshold
                    'luxury_threshold': -1000
                })
        else:
            # Default for unknown income
            base_thresholds['luxury_threshold'] = -3000

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create household-specific labeling functions"""

        def lf_household_naf_codes(x):
            """NAF codes for household/furniture retailers"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            household_naf_codes = [
                # Furniture and home goods
                "47.51Z",  # Retail sale of textiles
                "47.52A",  # Hardware stores
                "47.52B",  # DIY stores
                "47.53Z",  # Carpets, rugs, wall/floor coverings
                "47.54Z",  # Household appliances, furniture, lighting
                "47.59A",  # Furniture stores
                "47.59B",  # Other household equipment
                "47.78A",  # Other retail (household goods)
                "47.78B",  # Retail sale via stalls and markets of other goods
                "26.51A",  # Manufacture of instruments and appliances for measuring
                "27.51Z",  # Manufacture of electric domestic appliances
                "31.01Z",  # Manufacture of office and shop furniture
                "31.02Z",  # Manufacture of kitchen furniture
                "31.03Z",  # Manufacture of mattresses
                "31.09A",  # Manufacture of furniture for sitting and lying
                "31.09B",  # Manufacture of other furniture
            ]

            if str(x.NAF_CODE).strip() in household_naf_codes:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_household_major_retailers_high_confidence(x):
            """HIGH CONFIDENCE: Major household retailers are strongest indicators"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # STRONGEST household indicators - these merchants are almost exclusively household
            top_household_retailers = [
                # Pure furniture stores
                "IKEA", "BUT", "CONFORAMA", "FLY", "MAISONS DU MONDE",
                "ROCHE BOBOIS", "HABITAT", "ALINEA", "CASA",

                # Pure home improvement
                "LEROY MERLIN", "CASTORAMA", "BRICORAMA", "BRICO DEPOT",
                "BRICO MARCHE", "WELDOM",

                # Garden centers
                "JARDILAND", "TRUFFAUT", "BOTANIC", "GAMM VERT"
            ]

            # For these top retailers, very relaxed criteria
            for retailer in top_household_retailers:
                if retailer in merchant_text:
                    # Only requirements: expense + reasonable amount for the income level
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount'] and  # Income-adjusted max
                        x.amt_count >= 1):  # At least one transaction
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_household_major_retailers(x):
            """Regular confidence: Secondary household retailers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Secondary household retailers (may sell other things too)
            secondary_household_retailers = [
                # Department stores (home sections)
                "BHV", "SAMARITAINE", "PRINTEMPS MAISON",
                "GALERIES LAFAYETTE MAISON",

                # Appliances/Electronics (for household items)
                "DARTY", "BOULANGER", "FNAC", "ELECTRO DEPOT",

                # Online/Catalog (mixed retailers)
                "AMAZON", "CDISCOUNT", "RUE DU COMMERCE", "MANOMANO",
                "LA REDOUTE", "3 SUISSES", "CENTRAKOR"
            ]

            # For secondary retailers, only check max amount (not min amount)
            for retailer in secondary_household_retailers:
                if retailer in merchant_text:
                    # SIMPLIFIED: Only check it's an expense within reasonable max range
                    # Don't enforce minimum amount for secondary retailers
                    if (x.amt_mean < 0 and  # Must be expense
                        x.amt_mean >= self.thresholds['min_amount']):  # Not larger than max allowed household expense
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_household_keywords_comprehensive(x):
            """Comprehensive household keywords detection"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Comprehensive household keywords
            household_keywords = {
                # Furniture
                'furniture': ['meuble', 'furniture', 'canape', 'sofa', 'fauteuil', 'armchair',
                             'table', 'chaise', 'chair', 'lit', 'bed', 'matelas', 'mattress',
                             'armoire', 'closet', 'placard', 'etagere', 'shelf', 'bibliotheque',
                             'commode', 'dresser', 'buffet', 'sideboard'],

                # Home textiles
                'textiles': ['rideau', 'curtain', 'voilage', 'tapis', 'carpet', 'moquette',
                            'housse', 'cover', 'coussin', 'pillow', 'oreiller', 'drap', 'sheet',
                            'serviette', 'towel', 'nappe', 'tablecloth', 'linge', 'textile'],

                # Kitchenware (non-food)
                'kitchen': ['casserole', 'poele', 'pan', 'sauteuse', 'assiette', 'plate',
                           'verre', 'glass', 'tasse', 'cup', 'bol', 'bowl', 'couverts', 'cutlery',
                           'fourchette', 'fork', 'couteau', 'knife', 'cuillere', 'spoon',
                           'ustensile', 'cookware', 'batterie cuisine', 'vaisselle', 'dishes'],

                # Home improvement/DIY
                'diy': ['bricolage', 'diy', 'renovation', 'travaux', 'peinture', 'paint',
                       'outil', 'tool', 'perceuse', 'drill', 'marteau', 'hammer',
                       'tournevis', 'screwdriver', 'clou', 'nail', 'vis', 'screw',
                       'materiau', 'material', 'bois', 'wood', 'metal'],

                # Decoration
                'decor': ['decoration', 'deco', 'ornement', 'cadre', 'frame', 'miroir', 'mirror',
                         'luminaire', 'lighting', 'lampe', 'lamp', 'applique', 'lustre',
                         'chandelier', 'bougie', 'candle', 'vase', 'pot', 'plante', 'plant'],

                # Garden/Outdoor
                'garden': ['jardin', 'garden', 'terrasse', 'terrace', 'balcon', 'balcony',
                          'parasol', 'tondeuse', 'mower', 'arrosoir', 'watering', 'pot',
                          'plantation', 'graine', 'seed', 'engrais', 'fertilizer'],

                # Appliances
                'appliances': ['electromenager', 'appliance', 'refrigerateur', 'fridge',
                              'lave', 'washing', 'seche', 'dryer', 'four', 'oven',
                              'micro', 'onde', 'aspirateur', 'vacuum', 'fer', 'iron']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in household_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Require strong signal (multiple matches or specific categories)
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'furniture' in category_matches or  # Furniture is strong signal
                'appliances' in category_matches or  # Appliances are strong signal
                category_matches.get('diy', 0) >= 2  # Multiple DIY matches
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_household_text_anchor(x):
            """FastText similarity for household terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_infrequent_pattern(x):
            """Household pattern: infrequent, variable amounts"""
            if (x.amt_mean >= 0 or
                x.amt_count < self.thresholds['min_frequency']):
                return self.ABSTAIN

            # Household characteristics
            is_infrequent = x.mean_delta_days >= self.thresholds['min_days_between']
            is_reasonable_amount = (self.thresholds['min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['max_amount'])
            has_acceptable_variance = x.amt_cv <= self.thresholds['max_cv']

            # Not too regular (unlike utilities)
            not_too_regular = x.mean_delta_days > 45  # More than 1.5 months

            if (is_infrequent and is_reasonable_amount and
                has_acceptable_variance and not_too_regular):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_major_renovation_projects(x):
            """Detect major renovation projects (kitchen, bathroom, etc.)"""
            if (x.amt_mean >= 0 or x.amt_count < 1):
                return self.ABSTAIN

            # Large renovation amounts based on income
            luxury_threshold = self.thresholds.get('luxury_threshold', -3000)

            # Very large purchases that could be renovation projects
            is_major_renovation = x.amt_mean < luxury_threshold

            # Check for renovation-related text
            renovation_indicators = []
            if not pd.isna(x.MERCHANT):
                renovation_indicators.append(str(x.MERCHANT).lower())
            if not pd.isna(x.CLEANED_TEXT):
                renovation_indicators.append(str(x.CLEANED_TEXT).lower())

            text_to_check = " ".join(renovation_indicators)

            renovation_keywords = [
                'cuisine', 'kitchen', 'salle de bain', 'bathroom', 'renovation',
                'amenagement', 'travaux', 'installation', 'pose', 'menuiserie',
                'plomberie', 'electricite', 'carrelage', 'parquet', 'peinture'
            ]

            has_renovation_context = any(keyword in text_to_check for keyword in renovation_keywords)

            if is_major_renovation and (has_renovation_context or x.amt_mean < luxury_threshold * 2):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_household_ikea_pattern(x):
            """Specific pattern for IKEA-like stores (known household retailers)"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Known household furniture stores
            furniture_stores = ['ikea', 'but', 'conforama', 'fly', 'maisons du monde',
                               'habitat', 'alinea', 'casa', 'leroy merlin', 'castorama']

            has_furniture_store = any(store in merchant_lower for store in furniture_stores)

            if has_furniture_store:
                # Any reasonable expense amount and frequency for these stores
                if (x.amt_mean < 0 and
                    x.amt_mean >= -2000 and  # Not extremely large
                    x.amt_count >= 1):  # At least one transaction
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_household_groceries_pattern(x):
            """Exclude grocery-like patterns"""
            if (x.amt_count >= 8 and  # Very frequent
                x.mean_delta_days <= 21 and  # More than every 3 weeks
                -200 <= x.amt_mean <= -10 and  # Grocery-like amounts
                x.amt_cv <= 0.8):  # Too consistent for household
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_utilities_pattern(x):
            """Exclude utility-like patterns"""
            if (x.amt_count >= 6 and  # Regular frequency
                25 <= x.mean_delta_days <= 35 and  # Monthly-ish
                x.amt_cv <= 0.3 and  # Very consistent
                -150 <= x.amt_mean <= -15):  # Utility-like amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_restaurant_indicators(x):
            """Exclude restaurant/food service transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie', 'bistrot',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway', 'burger',
                'delivery', 'livraison', 'takeaway', 'emporter'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_transport_indicators(x):
            """Exclude transport-related transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'gazole', 'carburant', 'fuel', 'station',
                'peage', 'toll', 'parking', 'metro', 'bus', 'train',
                'sncf', 'ratp', 'uber', 'taxi', 'autoroute'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_household_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_small_amounts(x):
            """Very small amounts unlikely to be household"""
            if x.amt_mean > self.thresholds['max_amount']:  # Above minimum threshold
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_very_frequent_small(x):
            """Very frequent small amounts (likely groceries or daily expenses)"""
            if (x.amt_count > 15 and  # Very frequent
                x.mean_delta_days < 10 and  # More than weekly
                x.amt_mean > -100):  # Small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_household_extremely_large(x):
            """Extremely large amounts (likely real estate, cars, etc.)"""
            # Use income-adjusted threshold instead of fixed amount
            max_reasonable = self.thresholds['min_amount'] * 2  # Double the max household threshold

            if x.amt_mean < max_reasonable:  # Beyond reasonable household expense
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_household_naf_codes", f=lf_household_naf_codes),
            LabelingFunction(name="lf_household_major_retailers_high_confidence", f=lf_household_major_retailers_high_confidence),
            LabelingFunction(name="lf_household_major_retailers", f=lf_household_major_retailers),
            LabelingFunction(name="lf_household_keywords_comprehensive", f=lf_household_keywords_comprehensive),
            LabelingFunction(name="lf_household_text_anchor", f=lf_household_text_anchor),
            LabelingFunction(name="lf_household_infrequent_pattern", f=lf_household_infrequent_pattern),
            LabelingFunction(name="lf_household_major_renovation_projects", f=lf_household_major_renovation_projects),
            LabelingFunction(name="lf_household_ikea_pattern", f=lf_household_ikea_pattern),
            LabelingFunction(name="lf_not_household_groceries_pattern", f=lf_not_household_groceries_pattern),
            LabelingFunction(name="lf_not_household_utilities_pattern", f=lf_not_household_utilities_pattern),
            LabelingFunction(name="lf_not_household_restaurant_indicators", f=lf_not_household_restaurant_indicators),
            LabelingFunction(name="lf_not_household_transport_indicators", f=lf_not_household_transport_indicators),
            LabelingFunction(name="lf_not_household_positive_amounts", f=lf_not_household_positive_amounts),
            LabelingFunction(name="lf_not_household_very_small_amounts", f=lf_not_household_very_small_amounts),
            LabelingFunction(name="lf_not_household_very_frequent_small", f=lf_not_household_very_frequent_small),
            LabelingFunction(name="lf_not_household_extremely_large", f=lf_not_household_extremely_large),
        ]


# Usage function
def create_household_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run household classifier"""

    # Create classifier instance
    classifier = HouseholdClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
household_excel = extract_lf_results_to_excel(
    household_classifier, merchant_agg_df, "household_lf_detailed_results.xlsx"
)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")
"""

household_classifier = HouseholdClassifier(ft, merchant_agg_df, user_profile)
household_results = household_classifier.run_full_pipeline(confidence_threshold=0.6)

# Export results
household_excel = extract_lf_results_to_excel(
    household_classifier, merchant_agg_df, "household_lf_detailed_results.xlsx"
)

print(f"Household Results:")
print(f"- Total predicted: {household_results['predicted_positive']}")
print(f"- High confidence: {household_results['high_confidence_positive']}")

"""### Repairs"""

class RepairsClassifier(CategoryClassifier):
    """Repairs classifier for house and car repairs (excluding tech repairs)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Repairs", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_repairs_thresholds()

        # Repairs-specific anchors (house and car, excluding tech)
        repairs_anchors = [
            # House repairs
            "plombier", "electricien", "chauffage", "reparation", "travaux",
            "bricolage", "renovation", "peinture", "toiture", "menuisier",
            "plumber", "electrician", "heating", "repair", "maintenance",
            "handyman", "contractor", "roofing", "painting", "carpenter",

            # Car repairs
            "garage", "mecanique", "automobile", "voiture", "pneu",
            "mechanic", "automotive", "tire", "auto", "car", "vehicle",
            "service", "brake", "engine", "motor"
        ]
        self.setup_anchors(repairs_anchors, similarity_threshold=0.65)

    def _calculate_repairs_thresholds(self) -> dict:
        """Calculate repairs-specific thresholds"""
        base_thresholds = {
            'min_amount': -5000,        # Maximum repair cost
            'max_amount': -20,          # Minimum meaningful repair
            'typical_min': -2000,       # Typical major repair range
            'typical_max': -30,
            'max_frequency': 20,        # Repairs shouldn't be too frequent
            'min_days_between': 7,      # At least weekly spacing for multiple repairs
            'max_cv': 3.0,             # Can be very variable (different repair types)
            'house_repair_min': -50,    # House repairs usually more expensive
            'car_repair_min': -25,      # Car repairs can be smaller (oil change)
        }

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create repairs-specific labeling functions"""

        def lf_repairs_house_trades_naf(x):
            """NAF codes for house repair trades"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # House repair and construction trades NAF codes
            house_repair_naf_codes = [
                # Construction and specialized trades
                "43.11Z", "43.12A", "43.12B", "43.13Z", "43.21A", "43.21B",
                "43.22A", "43.22B", "43.29A", "43.29B", "43.31Z", "43.32A",
                "43.32B", "43.32C", "43.33Z", "43.34Z", "43.39Z",
                # Plumbing and heating
                "43.22A", "43.22B",
                # Electrical work
                "43.21A", "43.21B",
                # Painting and glazing
                "43.34Z", "43.32C",
                # Roofing and waterproofing
                "43.91A", "43.91B", "43.99A", "43.99B", "43.99C", "43.99D", "43.99Z"
            ]

            if str(x.NAF_CODE).strip() in house_repair_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['house_repair_min']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_car_services_naf(x):
            """NAF codes for car repair and maintenance"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Car repair and maintenance NAF codes
            car_repair_naf_codes = [
                "45.20A", "45.20B",  # Car maintenance and repair
                "45.31Z", "45.32Z",  # Auto parts retail
                "45.40Z",            # Motorcycle maintenance
                "33.17Z",            # Repair of transport equipment
            ]

            if str(x.NAF_CODE).strip() in car_repair_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['car_repair_min']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_house_keywords(x):
            """House repair specific keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # House repair keywords
            house_repair_keywords = [
                # Trades
                'plombier', 'plumber', 'electricien', 'electrician', 'chauffagiste',
                'menuisier', 'carpenter', 'peintre', 'painter', 'couvreur', 'roofer',
                'maçon', 'mason', 'carreleur', 'tiler', 'serrurier', 'locksmith',

                # Services
                'reparation', 'repair', 'travaux', 'renovation', 'bricolage',
                'maintenance', 'entretien', 'depannage', 'installation',
                'pose', 'fixing', 'handyman', 'contractor',

                # Specific repairs
                'chauffage', 'heating', 'climatisation', 'plomberie', 'plumbing',
                'electricite', 'electrical', 'toiture', 'roofing', 'isolation',
                'fenetre', 'window', 'porte', 'door', 'serrure', 'lock',

                # DIY stores (when buying repair materials)
                'leroy merlin', 'castorama', 'brico depot', 'bricorama',
                'home depot', 'lowe', 'menards'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in house_repair_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['house_repair_min']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_car_keywords(x):
            """Car repair specific keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Car repair keywords
            car_repair_keywords = [
                # Services
                'garage', 'mecanique', 'mechanic', 'automobile', 'automotive',
                'reparation auto', 'car repair', 'auto repair', 'service auto',
                'entretien auto', 'maintenance auto', 'depannage auto',

                # Specific repairs
                'pneu', 'tire', 'pneumatique', 'freins', 'brake', 'moteur', 'engine',
                'transmission', 'embrayage', 'clutch', 'batterie', 'battery',
                'alternateur', 'alternator', 'demarreur', 'starter', 'radiateur',
                'vidange', 'oil change', 'courroie', 'belt', 'amortisseur', 'shock',

                # Car parts stores
                'norauto', 'feu vert', 'speedy', 'midas', 'euromaster',
                'autozone', 'advance auto', 'napa', 'o reilly',

                # Car brands (when at dealership for service)
                'peugeot service', 'renault service', 'citroen service',
                'ford service', 'toyota service', 'bmw service'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in car_repair_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['car_repair_min']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_text_anchor(x):
            """FastText similarity for repair-related text"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Moderate similarity threshold (repairs have diverse vocabulary)
            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_irregular_moderate_amounts(x):
            """Irregular payments of moderate amounts (typical repair pattern)"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Moderate amounts (not too small, not too large)
            is_moderate_amount = (-1000 <= x.amt_mean <= -30)

            # Irregular pattern (not monthly, not weekly)
            is_irregular = (
                x.amt_count <= self.thresholds['max_frequency'] and
                (x.mean_delta_days < 20 or x.mean_delta_days > 45) and
                x.amt_cv > 0.3  # Some variability expected
            )

            # Not too frequent (repairs aren't daily)
            reasonable_frequency = x.mean_delta_days >= self.thresholds['min_days_between']

            if is_moderate_amount and is_irregular and reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_repairs_emergency_pattern(x):
            """Single large transactions that might be emergency repairs"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Single or very few large transactions
            is_emergency_pattern = (
                x.amt_count <= 3 and
                x.amt_mean <= -200  # Substantial amount
            )

            if is_emergency_pattern:
                return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_repairs_tech_keywords(x):
            """Exclude tech repairs (phones, computers, etc.)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Tech repair keywords to exclude
            tech_repair_keywords = [
                'phone repair', 'mobile repair', 'iphone repair', 'samsung repair',
                'computer repair', 'laptop repair', 'pc repair', 'mac repair',
                'tablet repair', 'ipad repair', 'screen repair', 'ecran',
                'apple store', 'genius bar', 'microsoft store',
                'reparation telephone', 'reparation mobile', 'reparation ecran',
                'reparation ordinateur', 'informatique', 'depannage informatique'
            ]

            if any(keyword in text_to_check for keyword in tech_repair_keywords):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_repairs_regular_monthly(x):
            """Exclude regular monthly payments (not repair pattern)"""
            if (x.amt_count >= 5 and
                25 <= x.mean_delta_days <= 35 and  # Monthly pattern
                x.amt_cv < 0.2):  # Very consistent
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_repairs_very_frequent_small(x):
            """Exclude very frequent small amounts"""
            if (x.amt_count > 15 and
                x.mean_delta_days < 10 and
                x.amt_mean > -50):
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_repairs_known_groceries(x):
            """Exclude known grocery stores"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            grocery_chains = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche'
            ]

            if any(chain in merchant_text for chain in grocery_chains):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_repairs_known_utilities(x):
            """Exclude known utilities"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            utility_providers = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez'
            ]

            if any(provider in merchant_text for provider in utility_providers):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_repairs_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_repairs_very_large(x):
            """Very large amounts unlikely to be repairs"""
            if x.amt_mean < -5000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_repairs_very_small(x):
            """Very small amounts unlikely to be repairs"""
            if x.amt_mean > -15:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_repairs_daily_pattern(x):
            """Daily patterns not typical for repairs"""
            if (x.amt_count > 10 and
                x.mean_delta_days < 3):
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_repairs_house_trades_naf", f=lf_repairs_house_trades_naf),
            LabelingFunction(name="lf_repairs_car_services_naf", f=lf_repairs_car_services_naf),
            LabelingFunction(name="lf_repairs_house_keywords", f=lf_repairs_house_keywords),
            LabelingFunction(name="lf_repairs_car_keywords", f=lf_repairs_car_keywords),
            LabelingFunction(name="lf_repairs_text_anchor", f=lf_repairs_text_anchor),
            LabelingFunction(name="lf_repairs_irregular_moderate_amounts", f=lf_repairs_irregular_moderate_amounts),
            LabelingFunction(name="lf_repairs_emergency_pattern", f=lf_repairs_emergency_pattern),
            LabelingFunction(name="lf_not_repairs_tech_keywords", f=lf_not_repairs_tech_keywords),
            LabelingFunction(name="lf_not_repairs_regular_monthly", f=lf_not_repairs_regular_monthly),
            LabelingFunction(name="lf_not_repairs_very_frequent_small", f=lf_not_repairs_very_frequent_small),
            LabelingFunction(name="lf_not_repairs_known_groceries", f=lf_not_repairs_known_groceries),
            LabelingFunction(name="lf_not_repairs_known_utilities", f=lf_not_repairs_known_utilities),
            LabelingFunction(name="lf_not_repairs_positive_amounts", f=lf_not_repairs_positive_amounts),
            LabelingFunction(name="lf_not_repairs_very_large", f=lf_not_repairs_very_large),
            LabelingFunction(name="lf_not_repairs_very_small", f=lf_not_repairs_very_small),
            LabelingFunction(name="lf_not_repairs_daily_pattern", f=lf_not_repairs_daily_pattern),
        ]


# Usage example
def create_repairs_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run repairs classifier"""

    # Create classifier instance
    classifier = RepairsClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results

# Example usage:
"""
repairs_classifier = RepairsClassifier(ft, merchant_agg_df, user_profile)
repairs_results = repairs_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
repairs_excel = extract_lf_results_to_excel(
    repairs_classifier, merchant_agg_df, "repairs_lf_detailed_results.xlsx"
)

print(f"Repairs Results:")
print(f"- Total predicted: {repairs_results['predicted_positive']}")
print(f"- High confidence: {repairs_results['high_confidence_positive']}")
"""

repairs_classifier = RepairsClassifier(ft, merchant_agg_df, user_profile)
repairs_results = repairs_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
repairs_excel = extract_lf_results_to_excel(
    repairs_classifier, merchant_agg_df, "repairs_lf_detailed_results.xlsx"
)

print(f"Repairs Results:")
print(f"- Total predicted: {repairs_results['predicted_positive']}")
print(f"- High confidence: {repairs_results['high_confidence_positive']}")

"""## Services"""

class HomeServicesClassifier(CategoryClassifier):
    """Home/Household services classifier (cleaning, maintenance, etc.)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("HomeServices", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_home_services_thresholds()

        # Home services specific anchors
        home_services_anchors = [
            "nettoyage", "menage", "cleaning", "maintenance", "reparation",
            "plombier", "electricien", "chauffage", "jardinage", "peinture",
            "serrurerie", "vitrier", "demenagement", "garde", "baby"
        ]
        self.setup_anchors(home_services_anchors, similarity_threshold=0.65)

    def _calculate_home_services_thresholds(self) -> dict:
        """Calculate home services specific thresholds"""
        base_thresholds = {
            'min_amount': -1000,        # Max home service (major repairs)
            'max_amount': -20,          # Minimum meaningful service
            'typical_min': -500,        # Typical service range
            'typical_max': -30,
            'max_frequency': 24,        # Max twice monthly
            'min_frequency': 2,         # Need some regularity for patterns
            'max_cv': 1.2,             # Can vary (different services)
            'regular_max_days': 90,     # Quarterly services acceptable
            'oneoff_min_amount': -100,  # One-off services minimum
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -2000,        # Can afford more expensive services
                    'typical_min': -800,
                    'oneoff_min_amount': -200
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -500,         # More budget-conscious
                    'typical_min': -300,
                    'max_amount': -15,
                    'oneoff_min_amount': -50
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create home services specific labeling functions"""

        def lf_home_services_naf_codes(x):
            """NAF codes for home services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            home_services_naf_codes = [
                # Cleaning services
                "81.21Z",  # General cleaning of buildings
                "81.22Z",  # Other building and industrial cleaning
                "81.29A",  # Disinfection, pest control services
                "81.29B",  # Other cleaning services

                # Construction/maintenance services
                "43.11Z",  # Demolition
                "43.12A",  # Earthwork
                "43.21A",  # Electrical installation
                "43.21B",  # Electrical installation in other construction
                "43.22A",  # Plumbing
                "43.22B",  # Heating and air conditioning installation
                "43.31Z",  # Plastering
                "43.32A",  # Carpentry and joinery installation
                "43.32B",  # Carpentry and joinery installation except prefabricated
                "43.33Z",  # Floor and wall covering
                "43.34Z",  # Painting and glazing
                "43.39Z",  # Other finishing work

                # Repair services
                "95.21Z",  # Repair of consumer electronics
                "95.22Z",  # Repair of household appliances and home equipment
                "95.23Z",  # Repair of footwear and leather goods
                "95.24Z",  # Repair of furniture and home furnishings
                "95.25Z",  # Repair of watches, clocks and jewelry
                "95.29Z",  # Repair of other personal and household goods

                # Gardening and landscaping
                "81.30Z",  # Landscape service activities

                # Security services
                "80.10Z",  # Private security activities
                "80.20Z",  # Security systems service activities

                # Personal services at home
                "96.09Z",  # Other personal service activities
                "97.00Z",  # Activities of households as employers of domestic personnel
            ]

            if str(x.NAF_CODE).strip() in home_services_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_home_services_keywords_specific(x):
            """Specific home service keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            home_service_keywords = [
                # Cleaning
                'femme menage', 'nettoyage', 'menage', 'cleaning lady', 'house cleaning',
                'entretien maison', 'cleaning service', 'aide menagere',

                # Maintenance/Repair
                'plombier', 'plumbing', 'electricien', 'electrical', 'chauffagiste',
                'reparation', 'maintenance', 'depannage', 'intervention',
                'serrurerie', 'locksmith', 'vitrier', 'glazier',

                # Home improvement
                'peinture', 'painting', 'renovation', 'travaux', 'artisan',
                'carrelage', 'flooring', 'menuiserie', 'carpentry',

                # Garden/Exterior
                'jardinage', 'gardening', 'paysagiste', 'landscaping', 'elagage',
                'tondeuse', 'lawn care', 'entretien jardin',

                # Household services
                'garde enfant', 'babysitting', 'baby sitter', 'nounou',
                'aide domicile', 'home care', 'cours particulier', 'tutoring',
                'pet sitting', 'dog walking', 'garde animaux',

                # Moving/Transport
                'demenagement', 'moving', 'transport', 'livraison meuble',

                # Security
                'alarme', 'security', 'surveillance', 'gardiennage'
            ]

            matches = sum(1 for keyword in home_service_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_home_services_text_anchor(x):
            """FastText similarity for home services"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_home_services_regular_pattern(x):
            """Regular home services (cleaning, maintenance)"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['max_amount']:
                return self.ABSTAIN

            # Regular services like weekly/monthly cleaning
            is_frequent_enough = x.amt_count >= self.thresholds['min_frequency']
            is_reasonable_amount = (self.thresholds['typical_max'] <= x.amt_mean <= self.thresholds['typical_min'])
            is_regular = x.mean_delta_days <= self.thresholds['regular_max_days']
            has_reasonable_variance = x.amt_cv <= self.thresholds['max_cv']

            if is_frequent_enough and is_reasonable_amount and is_regular and has_reasonable_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_home_services_oneoff_substantial(x):
            """One-off substantial home services (repairs, renovations)"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # One-off or rare substantial services
            is_infrequent = x.amt_count <= 3
            is_substantial = x.amt_mean <= self.thresholds['oneoff_min_amount']

            if is_infrequent and is_substantial:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_home_services_artisan_pattern(x):
            """Artisan/craftsman service pattern"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            artisan_indicators = [
                'eurl', 'sarl', 'sasu', 'entreprise', 'ets',  # Business types
                'artisan', 'craftsman', 'maitre', 'expert',
                'services', 'solutions', 'pro', 'professionnel'
            ]

            # Combined with home-related terms
            home_terms = [
                'maison', 'home', 'habitat', 'domicile', 'residence',
                'batiment', 'building', 'immeuble'
            ]

            has_artisan = any(indicator in text_to_check for indicator in artisan_indicators)
            has_home_context = any(term in text_to_check for term in home_terms)

            if has_artisan and (has_home_context or x.amt_mean <= -100):  # Substantial amount
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_home_services_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_home_services_very_frequent_small(x):
            """Very frequent small amounts unlikely to be home services"""
            if (x.amt_count > 20 and
                x.amt_mean > -30 and
                x.mean_delta_days < 7):  # More than weekly small amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_home_services_groceries(x):
            """Exclude grocery stores"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino',
                'supermarche', 'hypermarche', 'alimentaire'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_home_services_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = ['edf', 'engie', 'orange', 'free', 'sfr']

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_home_services_naf_codes", f=lf_home_services_naf_codes),
            LabelingFunction(name="lf_home_services_keywords_specific", f=lf_home_services_keywords_specific),
            LabelingFunction(name="lf_home_services_text_anchor", f=lf_home_services_text_anchor),
            LabelingFunction(name="lf_home_services_regular_pattern", f=lf_home_services_regular_pattern),
            LabelingFunction(name="lf_home_services_oneoff_substantial", f=lf_home_services_oneoff_substantial),
            LabelingFunction(name="lf_home_services_artisan_pattern", f=lf_home_services_artisan_pattern),
            LabelingFunction(name="lf_not_home_services_positive_amounts", f=lf_not_home_services_positive_amounts),
            LabelingFunction(name="lf_not_home_services_very_frequent_small", f=lf_not_home_services_very_frequent_small),
            LabelingFunction(name="lf_not_home_services_groceries", f=lf_not_home_services_groceries),
            LabelingFunction(name="lf_not_home_services_utilities", f=lf_not_home_services_utilities),
        ]


class ProfessionalServicesClassifier(CategoryClassifier):
    """Professional/Business services classifier (consulting, legal, etc.)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("ProfessionalServices", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_professional_services_thresholds()

        # Professional services specific anchors
        professional_services_anchors = [
            "conseil", "consulting", "avocat", "comptable", "audit",
            "formation", "expertise", "freelance", "consultant", "cabinet",
            "juridique", "legal", "marketing", "communication", "design"
        ]
        self.setup_anchors(professional_services_anchors, similarity_threshold=0.7)

    def _calculate_professional_services_thresholds(self) -> dict:
        """Calculate professional services specific thresholds"""
        base_thresholds = {
            'min_amount': -10000,       # High-end consulting can be expensive
            'max_amount': -100,         # Professional services are substantial
            'typical_min': -2000,       # Typical project range
            'typical_max': -200,
            'max_frequency': 12,        # Usually project-based, not too frequent
            'min_frequency': 1,         # Can be one-off projects
            'max_cv': 2.0,             # High variance (different project sizes)
            'consultation_min': -150,   # Minimum consultation fee
            'project_min': -500,        # Minimum project fee
        }

        # Adjust based on business context (if user_profile indicates business account)
        if self.user_profile and hasattr(self.user_profile, 'account_type'):
            if self.user_profile.account_type == "business":
                base_thresholds.update({
                    'min_amount': -50000,       # Larger business projects
                    'max_amount': -200,         # Higher minimum for business
                    'typical_min': -5000,
                    'consultation_min': -300,
                    'project_min': -1000
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create professional services specific labeling functions"""

        def lf_professional_services_naf_codes(x):
            """NAF codes for professional services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            professional_services_naf_codes = [
                # Legal and accounting
                "69.10Z",  # Legal activities
                "69.20Z",  # Accounting, bookkeeping and auditing

                # Management consulting
                "70.22Z",  # Business and other management consultancy activities

                # Architectural and engineering
                "71.11Z",  # Architectural activities
                "71.12A",  # Engineering activities and related technical consultancy - general
                "71.12B",  # Engineering activities and related technical consultancy - specialized
                "71.20A",  # Technical testing and analysis
                "71.20B",  # Technical testing and analysis

                # Scientific R&D
                "72.11Z",  # Research and experimental development on biotechnology
                "72.19Z",  # Other research and experimental development
                "72.20Z",  # Research and experimental development on social sciences

                # Advertising and market research
                "73.11Z",  # Advertising agencies
                "73.12Z",  # Media representation
                "73.20Z",  # Market research and public opinion polling

                # Professional, scientific and technical activities
                "74.10Z",  # Specialized design activities
                "74.20Z",  # Photographic activities
                "74.30Z",  # Translation and interpretation activities
                "74.90A",  # Tax consultancy activities
                "74.90B",  # Other professional, scientific and technical activities

                # IT services
                "62.01Z",  # Computer programming activities
                "62.02A",  # Computer consultancy activities
                "62.02B",  # Computer facilities management activities
                "62.03Z",  # Computer facilities management activities
                "62.09Z",  # Other information technology and computer service activities
                "63.11Z",  # Data processing, hosting and related activities

                # Training and education
                "85.59A",  # Vocational training
                "85.59B",  # Other education
            ]

            if str(x.NAF_CODE).strip() in professional_services_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_professional_services_keywords_specific(x):
            """Specific professional service keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            professional_service_keywords = [
                # Consulting
                'conseil', 'consulting', 'consultant', 'expertise', 'expert',
                'advisory', 'strategy', 'management', 'business development',

                # Legal
                'avocat', 'lawyer', 'attorney', 'cabinet juridique', 'legal',
                'notaire', 'notary', 'huissier', 'tribunal',

                # Accounting/Finance
                'comptable', 'accountant', 'audit', 'auditor', 'expert comptable',
                'fiduciaire', 'fiscal', 'tax advisor', 'commissaire compte',

                # IT/Tech services
                'informatique', 'it services', 'web design', 'development',
                'programmer', 'developer', 'software', 'app development',
                'cybersecurity', 'cloud services', 'data analyst',

                # Marketing/Communication
                'marketing', 'communication', 'publicite', 'advertising',
                'digital marketing', 'seo', 'social media', 'branding',
                'graphic design', 'designer', 'agence communication',

                # Training/Education
                'formation', 'training', 'coaching', 'formation professionnelle',
                'seminaire', 'workshop', 'certification',

                # Architecture/Engineering
                'architecte', 'architect', 'ingenieur', 'engineer', 'bureau etude',
                'maitrise oeuvre', 'plans', 'conception',

                # Research/Analysis
                'recherche', 'research', 'etude marche', 'market research',
                'analyse', 'analysis', 'evaluation', 'diagnostic',

                # Freelance/Independent
                'freelance', 'independant', 'auto entrepreneur', 'travailleur independant',
                'prestation', 'mission', 'projet'
            ]

            matches = sum(1 for keyword in professional_service_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_services_text_anchor(x):
            """FastText similarity for professional services"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_services_substantial_infrequent(x):
            """Substantial, infrequent professional services"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Professional services are typically substantial and project-based
            is_substantial = x.amt_mean <= self.thresholds['project_min']
            is_infrequent = x.amt_count <= self.thresholds['max_frequency']

            if is_substantial and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_services_business_entity(x):
            """Business entity indicators + professional context"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            business_entities = [
                'sarl', 'sas', 'sasu', 'eurl', 'sa', 'sci',
                'cabinet', 'office', 'bureau', 'agence', 'societe',
                'consulting', 'services', 'solutions', 'group'
            ]

            professional_context = [
                'conseil', 'expert', 'avocat', 'comptable', 'audit',
                'formation', 'consulting', 'marketing', 'communication'
            ]

            has_business_entity = any(entity in text_to_check for entity in business_entities)
            has_professional_context = any(context in text_to_check for context in professional_context)

            if has_business_entity and has_professional_context:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_services_high_value_irregular(x):
            """High-value irregular payments typical of professional services"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['consultation_min']:
                return self.ABSTAIN

            # High variance + substantial amounts = likely professional services
            is_high_value = x.amt_mean <= self.thresholds['project_min']
            has_high_variance = x.amt_cv > 0.5 if x.amt_count > 1 else True
            is_reasonable_frequency = x.amt_count <= 10

            if is_high_value and has_high_variance and is_reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_services_round_professional_amounts(x):
            """Round amounts typical of professional billing"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['consultation_min']:
                return self.ABSTAIN

            amount_abs = abs(int(x.amt_mean))

            # Professional services often bill in round amounts
            professional_amounts = [
                200, 250, 300, 500, 600, 750, 1000, 1200, 1500, 2000,
                2500, 3000, 4000, 5000, 7500, 10000
            ]

            is_professional_amount = any(abs(amount_abs - price) <= 50 for price in professional_amounts)
            is_infrequent = x.amt_count <= 6

            if is_professional_amount and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_professional_services_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_professional_services_small_amounts(x):
            """Small amounts unlikely to be professional services"""
            if x.amt_mean > self.thresholds['max_amount']:  # Less than 100€
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_professional_services_very_frequent(x):
            """Very frequent payments unlikely to be professional services"""
            if (x.amt_count > 24 or  # More than twice monthly
                (x.amt_count > 10 and x.mean_delta_days < 14)):  # Bi-weekly or more
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_professional_services_groceries(x):
            """Exclude grocery stores"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino',
                'supermarche', 'hypermarche', 'alimentaire'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_services_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'electricite', 'gaz', 'eau', 'internet'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_services_home_services(x):
            """Exclude home services"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            home_service_indicators = [
                'plombier', 'electricien', 'chauffagiste', 'menage',
                'nettoyage', 'jardinage', 'baby sitter', 'garde enfant'
            ]

            if any(indicator in text_to_check for indicator in home_service_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_professional_services_naf_codes", f=lf_professional_services_naf_codes),
            LabelingFunction(name="lf_professional_services_keywords_specific", f=lf_professional_services_keywords_specific),
            LabelingFunction(name="lf_professional_services_text_anchor", f=lf_professional_services_text_anchor),
            LabelingFunction(name="lf_professional_services_substantial_infrequent", f=lf_professional_services_substantial_infrequent),
            LabelingFunction(name="lf_professional_services_business_entity", f=lf_professional_services_business_entity),
            LabelingFunction(name="lf_professional_services_high_value_irregular", f=lf_professional_services_high_value_irregular),
            LabelingFunction(name="lf_professional_services_round_professional_amounts", f=lf_professional_services_round_professional_amounts),
            LabelingFunction(name="lf_not_professional_services_home_services", f=lf_not_professional_services_home_services),
        ]


# Usage functions
def create_home_services_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run home services classifier"""

    # Create classifier instance
    classifier = HomeServicesClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


def create_professional_services_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run professional services classifier"""

    # Create classifier instance
    classifier = ProfessionalServicesClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Home Services
home_services_classifier = HomeServicesClassifier(ft, merchant_agg_df, user_profile)
home_services_results = home_services_classifier.run_full_pipeline(confidence_threshold=0.7)

# Professional Services
professional_services_classifier = ProfessionalServicesClassifier(ft, merchant_agg_df, user_profile)
professional_services_results = professional_services_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
home_services_excel = extract_lf_results_to_excel(
    home_services_classifier, merchant_agg_df, "home_services_lf_detailed_results.xlsx"
)

professional_services_excel = extract_lf_results_to_excel(
    professional_services_classifier, merchant_agg_df, "professional_services_lf_detailed_results.xlsx"
)

print(f"Home Services Results:")
print(f"- Total predicted: {home_services_results['predicted_positive']}")
print(f"- High confidence: {home_services_results['high_confidence_positive']}")

print(f"\nProfessional Services Results:")
print(f"- Total predicted: {professional_services_results['predicted_positive']}")
print(f"- High confidence: {professional_services_results['high_confidence_positive']}")

# Show examples
if len(home_services_results['high_confidence_examples']) > 0:
    print("\nHigh confidence home services examples:")
    display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'homeservices_confidence']
    print(home_services_results['high_confidence_examples'][display_cols].head(10))

if len(professional_services_results['high_confidence_examples']) > 0:
    print("\nHigh confidence professional services examples:")
    display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'professionalservices_confidence']
    print(professional_services_results['high_confidence_examples'][display_cols].head(10))
"""_positive_amounts", f=lf_not_professional_services_positive_amounts),
            LabelingFunction(name="lf_not_professional_services_small_amounts", f=lf_not_professional_services_small_amounts),
            LabelingFunction(name="lf_not_professional_services_very_frequent", f=lf_not_professional_services_very_frequent),
            LabelingFunction(name="lf_not_professional_services_groceries", f=lf_not_professional_services_groceries),
            LabelingFunction(name="lf_not_professional_services_utilities", f=lf_not_professional_services_utilities),
            LabelingFunction(name="lf_not_professional_services

"""## Pets

## Plants

## Professional
"""

class ProfessionalExpensesClassifier(CategoryClassifier):
    """Professional expenses classifier for self-employment (services, supplies, tools)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("ProfessionalExpenses", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_professional_expenses_thresholds()

        # Professional expenses specific anchors
        professional_expenses_anchors = [
            "bureau", "office", "fourniture", "supplies", "materiel",
            "equipment", "outil", "tool", "logiciel", "software",
            "formation", "training", "abonnement", "subscription"
        ]
        self.setup_anchors(professional_expenses_anchors, similarity_threshold=0.65)

    def _calculate_professional_expenses_thresholds(self) -> dict:
        """Calculate professional expenses specific thresholds"""
        base_thresholds = {
            'min_amount': -5000,        # Major equipment purchases
            'max_amount': -5,           # Small office supplies
            'office_supplies_min': -200, # Office supplies range
            'office_supplies_max': -5,
            'equipment_min': -2000,     # Professional equipment
            'equipment_max': -50,
            'software_min': -500,       # Software/subscriptions
            'software_max': -10,
            'max_frequency': 30,        # Can be quite frequent for supplies
            'subscription_max_days': 35, # Monthly subscriptions
            'equipment_max_count': 8,   # Equipment purchases are infrequent
        }

        # Adjust based on profession if available
        if self.user_profile and hasattr(self.user_profile, 'profession'):
            if self.user_profile.profession in ["consultant", "freelancer", "designer"]:
                base_thresholds.update({
                    'software_min': -1000,      # Higher software costs
                    'equipment_min': -3000,     # Better equipment needs
                })
            elif self.user_profile.profession in ["craftsman", "technician"]:
                base_thresholds.update({
                    'equipment_min': -5000,     # Expensive tools
                    'min_amount': -10000,
                    'office_supplies_min': -500, # More materials
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create professional expenses specific labeling functions"""

        def lf_professional_office_supplies_naf(x):
            """NAF codes for office supplies and equipment"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            office_supplies_naf_codes = [
                # Office supplies retail
                "47.62Z",  # Retail sale of newspapers and stationery
                "47.78A",  # Retail sale of optical and photographic equipment
                "47.78B",  # Retail sale of watches, jewelry and bijouterie
                "47.78C",  # Other retail sale of new goods in specialized stores

                # Computer and software
                "47.41Z",  # Retail sale of computers, peripheral units and software
                "62.01Z",  # Computer programming activities
                "62.02A",  # Computer consultancy activities

                # Equipment and machinery
                "47.52A",  # Retail sale of hardware, paints and glass
                "47.52B",  # Retail sale of do-it-yourself supplies
                "47.54Z",  # Retail sale of electrical household appliances
                "47.59A",  # Retail sale of furniture
                "47.59B",  # Retail sale of other household equipment

                # Professional equipment
                "46.66Z",  # Wholesale of other office machinery and equipment
                "46.69A",  # Wholesale of other office machinery and equipment
                "77.32Z",  # Rental and leasing of construction machinery
                "77.39Z",  # Rental and leasing of other machinery and equipment
            ]

            if str(x.NAF_CODE).strip() in office_supplies_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_professional_office_supplies_keywords(x):
            """Office supplies specific keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            office_supplies_keywords = [
                # Stationery
                'papeterie', 'stationery', 'fourniture bureau', 'office supplies',
                'stylo', 'pen', 'crayon', 'pencil', 'papier', 'paper',
                'cahier', 'notebook', 'classeur', 'binder', 'dossier',
                'enveloppe', 'envelope', 'timbre', 'stamp',

                # Office equipment
                'imprimante', 'printer', 'scanner', 'photocopieuse', 'copier',
                'ordinateur', 'computer', 'laptop', 'clavier', 'keyboard',
                'souris', 'mouse', 'ecran', 'monitor', 'bureau', 'desk',
                'chaise bureau', 'office chair', 'fauteuil',

                # Consumables
                'cartouche', 'cartridge', 'encre', 'ink', 'toner',
                'pile', 'battery', 'cable', 'adaptateur', 'adapter',

                # Brands
                'staples', 'bureau vallee', 'lyreco', 'raja', 'manutan',
                'office depot', 'top office', 'maxiburo'
            ]

            matches = sum(1 for keyword in office_supplies_keywords if keyword in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['office_supplies_max'] <= x.amt_mean <= self.thresholds['office_supplies_min']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_software_subscriptions(x):
            """Software and professional subscriptions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            software_keywords = [
                # General software
                'microsoft', 'adobe', 'google workspace', 'office 365',
                'creative cloud', 'photoshop', 'illustrator', 'autocad',
                'canva', 'figma', 'sketch', 'dropbox', 'slack',

                # Professional software
                'quickbooks', 'sage', 'ciel', 'ebp', 'acd systems',
                'salesforce', 'hubspot', 'mailchimp', 'zapier',
                'asana', 'trello', 'notion', 'monday.com',

                # Development tools
                'github', 'gitlab', 'jetbrains', 'visual studio',
                'aws', 'azure', 'heroku', 'digitalocean',

                # Design and media
                'shutterstock', 'getty images', 'unsplash', 'pixabay',
                'envato', 'themeforest', 'codecanyon',

                # Communication
                'zoom', 'teams', 'webex', 'skype business',
                'calendly', 'acuity', 'doodle pro',

                # Keywords
                'logiciel', 'software', 'abonnement', 'subscription',
                'licence', 'license', 'saas', 'cloud', 'app store'
            ]

            if any(keyword in text_to_check for keyword in software_keywords):
                if (x.amt_mean < 0 and
                    self.thresholds['software_max'] <= x.amt_mean <= self.thresholds['software_min']):
                    # Check for subscription pattern (monthly payments)
                    is_subscription_like = (x.amt_count >= 3 and
                                          x.mean_delta_days <= self.thresholds['subscription_max_days'])
                    # Or one-off software purchase
                    is_software_purchase = x.amt_count <= 3

                    if is_subscription_like or is_software_purchase:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_tools_equipment(x):
            """Professional tools and equipment"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            tools_equipment_keywords = [
                # General tools
                'outil', 'tool', 'outillage', 'equipement', 'equipment',
                'materiel', 'material', 'machine', 'appareil',

                # Hand tools
                'tournevis', 'screwdriver', 'marteau', 'hammer', 'cle', 'wrench',
                'pince', 'pliers', 'scie', 'saw', 'perceuse', 'drill',

                # Power tools
                'visseuse', 'ponceuse', 'sander', 'meuleuse', 'grinder',
                'defonceuse', 'router', 'scie circulaire', 'circular saw',

                # Measuring tools
                'metre', 'meter', 'niveau', 'level', 'equerre', 'square',
                'compas', 'compass', 'laser', 'telemetre',

                # Professional equipment by field
                'camera', 'objectif', 'lens', 'trepied', 'tripod',
                'micro', 'microphone', 'eclairage', 'lighting',
                'tablette graphique', 'graphic tablet', 'stylet',

                # Medical/health tools
                'stethoscope', 'tensiometre', 'thermometre', 'balance',

                # Beauty/wellness tools
                'seche cheveux', 'hair dryer', 'fer lisser', 'ciseaux',
                'tondeuse', 'clipper', 'epilateur', 'massage table',

                # Kitchen professional
                'batteur', 'mixer', 'robot cuisine', 'mandoline',
                'balance cuisine', 'thermomix',

                # Brands
                'bosch', 'makita', 'dewalt', 'milwaukee', 'festool',
                'stanley', 'facom', 'würth', 'mannesmann', 'castorama',
                'leroy merlin', 'brico depot', 'mr bricolage'
            ]

            matches = sum(1 for keyword in tools_equipment_keywords if keyword in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['equipment_max'] <= x.amt_mean <= self.thresholds['equipment_min']):
                    # Equipment purchases are typically infrequent
                    if x.amt_count <= self.thresholds['equipment_max_count']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_training_education(x):
            """Professional training and education expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            training_keywords = [
                # General training
                'formation', 'training', 'cours', 'course', 'seminaire', 'seminar',
                'atelier', 'workshop', 'stage', 'certification', 'diplome',

                # Online learning
                'udemy', 'coursera', 'linkedin learning', 'skillshare',
                'pluralsight', 'codecademy', 'treehouse', 'lynda',
                'masterclass', 'brilliant', 'edx', 'khan academy',

                # Professional development
                'coaching', 'mentoring', 'consultation', 'expertise',
                'audit', 'diagnostic', 'evaluation',

                # Conferences and events
                'conference', 'congres', 'colloque', 'symposium',
                'salon professionnel', 'trade show', 'networking',

                # Certification bodies
                'certification', 'accreditation', 'qualification',
                'examen', 'exam', 'test', 'evaluation'
            ]

            if any(keyword in text_to_check for keyword in training_keywords):
                if (x.amt_mean < 0 and
                    x.amt_mean <= -30 and  # Training costs are typically substantial
                    x.amt_count <= 10):    # Not too frequent
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_text_anchor(x):
            """FastText similarity for professional expenses"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_business_supplies_pattern(x):
            """Business supplies purchasing pattern"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount']):
                return self.ABSTAIN

            # Regular small to medium purchases typical of business supplies
            is_business_amount = (self.thresholds['office_supplies_max'] <=
                                x.amt_mean <= -20)  # €5-20+ range
            is_regular_business = (x.amt_count >= 4 and
                                 x.amt_count <= self.thresholds['max_frequency'])
            has_business_variance = x.amt_cv <= 1.5  # Some variance expected

            if is_business_amount and is_regular_business and has_business_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_subscription_pattern(x):
            """Professional subscription pattern (SaaS, tools, etc.)"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or
                x.amt_count < 3):
                return self.ABSTAIN

            # Monthly subscription pattern
            is_monthly_like = (25 <= x.mean_delta_days <= self.thresholds['subscription_max_days'])
            is_consistent = x.amt_cv <= 0.3  # Subscriptions are very consistent
            is_subscription_amount = (self.thresholds['software_max'] <=
                                    x.amt_mean <= -15)  # €10-15+ monthly

            if is_monthly_like and is_consistent and is_subscription_amount:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_professional_equipment_oneoff(x):
            """One-off equipment purchases"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['equipment_max']):
                return self.ABSTAIN

            # Large, infrequent equipment purchases
            is_equipment_amount = x.amt_mean <= self.thresholds['equipment_max']
            is_infrequent = x.amt_count <= 4
            has_gaps = x.mean_delta_days >= 60 if x.amt_count > 1 else True

            if is_equipment_amount and is_infrequent and has_gaps:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_professional_expenses_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_professional_expenses_personal_groceries(x):
            """Exclude personal groceries"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_expenses_utilities(x):
            """Exclude personal utilities (business utilities could be professional)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            personal_utility_indicators = [
                'edf particulier', 'engie particulier', 'orange particulier',
                'free mobile', 'sfr mobile'  # Personal mobile vs business
            ]

            if any(indicator in text_to_check for indicator in personal_utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_expenses_restaurants(x):
            """Exclude restaurant expenses (unless clearly business meals)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'mcdo', 'mcdonald', 'kfc', 'subway'
            ]

            # Only exclude if no business context
            has_restaurant = any(indicator in text_to_check for indicator in restaurant_indicators)
            has_business_context = any(term in text_to_check for term in [
                'business', 'meeting', 'client', 'reunion', 'seminaire'
            ])

            if has_restaurant and not has_business_context:
                # Additional check: very frequent restaurant visits are likely personal
                if x.amt_count > 15 and x.mean_delta_days < 14:
                    return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_expenses_travel_personal(x):
            """Exclude clearly personal travel"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            personal_travel_indicators = [
                'booking.com', 'airbnb', 'expedia', 'hotel vacation',
                'resort', 'cruise', 'holiday', 'vacation'
            ]

            # Only exclude if clearly personal (no business context)
            has_personal_travel = any(indicator in text_to_check for indicator in personal_travel_indicators)
            has_business_context = any(term in text_to_check for term in [
                'business', 'conference', 'meeting', 'professionnel'
            ])

            if has_personal_travel and not has_business_context:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_professional_expenses_very_small_frequent(x):
            """Very small frequent amounts unlikely to be professional expenses"""
            if (x.amt_count > 30 and
                x.amt_mean > -5 and  # Less than 5€
                x.mean_delta_days < 7):  # More than weekly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_professional_expenses_very_large(x):
            """Very large amounts likely to be other categories"""
            if x.amt_mean < -3000:  # More than 3000€ likely major purchases
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_professional_office_supplies_naf", f=lf_professional_office_supplies_naf),
            LabelingFunction(name="lf_professional_office_supplies_keywords", f=lf_professional_office_supplies_keywords),
            LabelingFunction(name="lf_professional_software_subscriptions", f=lf_professional_software_subscriptions),
            LabelingFunction(name="lf_professional_tools_equipment", f=lf_professional_tools_equipment),
            LabelingFunction(name="lf_professional_training_education", f=lf_professional_training_education),
            LabelingFunction(name="lf_professional_text_anchor", f=lf_professional_text_anchor),
            LabelingFunction(name="lf_professional_business_supplies_pattern", f=lf_professional_business_supplies_pattern),
            LabelingFunction(name="lf_professional_subscription_pattern", f=lf_professional_subscription_pattern),
            LabelingFunction(name="lf_professional_equipment_oneoff", f=lf_professional_equipment_oneoff),
            LabelingFunction(name="lf_not_professional_expenses_positive_amounts", f=lf_not_professional_expenses_positive_amounts),
            LabelingFunction(name="lf_not_professional_expenses_personal_groceries", f=lf_not_professional_expenses_personal_groceries),
            LabelingFunction(name="lf_not_professional_expenses_utilities", f=lf_not_professional_expenses_utilities),
            LabelingFunction(name="lf_not_professional_expenses_restaurants", f=lf_not_professional_expenses_restaurants),
            LabelingFunction(name="lf_not_professional_expenses_travel_personal", f=lf_not_professional_expenses_travel_personal),
            LabelingFunction(name="lf_not_professional_expenses_very_small_frequent", f=lf_not_professional_expenses_very_small_frequent),
            LabelingFunction(name="lf_not_professional_expenses_very_large", f=lf_not_professional_expenses_very_large),
        ]


# Usage function
def create_professional_expenses_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run professional expenses classifier"""

    # Create classifier instance
    classifier = ProfessionalExpensesClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
professional_expenses_classifier = ProfessionalExpensesClassifier(ft, merchant_agg_df, user_profile)
professional_expenses_results = professional_expenses_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
professional_expenses_excel = extract_lf_results_to_excel(
    professional_expenses_classifier, merchant_agg_df, "professional_expenses_lf_detailed_results.xlsx"
)

print(f"Professional Expenses Results:")
print(f"- Total predicted: {professional_expenses_results['predicted_positive']}")
print(f"- High confidence: {professional_expenses_results['high_confidence_positive']}")

# Show high confidence examples
if len(professional_expenses_results['high_confidence_examples']) > 0:
    print("\nHigh confidence professional expenses examples:")
    display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'professionalexpenses_confidence']
    print(professional_expenses_results['high_confidence_examples'][display_cols].head(10))

# Break down by subcategory (optional analysis)
high_confidence = professional_expenses_results['high_confidence_examples']

if len(high_confidence) > 0:
    print("\nBreakdown by expense type:")

    # Office supplies (frequent, small amounts)
    office_supplies = high_confidence[
        (high_confidence['amt_mean'] >= -200) &
        (high_confidence['amt_count'] >= 4)
    ]
    print(f"Office supplies: {len(office_supplies)} transactions")

    # Software/subscriptions (regular, monthly)
    subscriptions = high_confidence[
        (high_confidence['amt_mean'] >= -500) &
        (high_confidence['amt_cv'] <= 0.3) &
        (high_confidence['mean_delta_days'] <= 35)
    ]
    print(f"Software/subscriptions: {len(subscriptions)} transactions")

    # Equipment (large, infrequent)
    equipment = high_confidence[
        (high_confidence['amt_mean'] <= -200) &
        (high_confidence['amt_count'] <= 4)
    ]
    print(f"Equipment/tools: {len(equipment)} transactions")
"""

"""## Other

# Tech
"""

class TechClassifier(CategoryClassifier):
    """Tech classifier for hardware, software, and tech repairs"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Tech", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_tech_thresholds()

        # Tech-specific anchors covering hardware, software, and repairs
        tech_anchors = [
            # Hardware
            "ordinateur", "laptop", "telephone", "smartphone", "tablette", "iphone",
            "samsung", "apple", "computer", "phone", "tablet", "ipad", "macbook",
            "dell", "hp", "lenovo", "asus", "acer", "microsoft", "surface",

            # Software/Services
            "software", "logiciel", "application", "subscription", "adobe", "office",
            "cloud", "netflix", "spotify", "dropbox", "google", "amazon",

            # Tech repairs
            "reparation", "repair", "service", "maintenance", "ecran", "screen",
            "batterie", "battery", "support", "technique", "informatique",

            # Tech accessories
            "casque", "headphone", "clavier", "keyboard", "souris", "mouse",
            "cable", "chargeur", "charger", "accessoire"
        ]
        self.setup_anchors(tech_anchors, similarity_threshold=0.65)

    def _calculate_tech_thresholds(self) -> dict:
        """Calculate tech-specific thresholds"""
        base_thresholds = {
            # Hardware thresholds
            'hardware_min': -5000,       # Maximum tech hardware cost
            'hardware_max': -30,         # Minimum meaningful hardware purchase
            'laptop_min': -200,          # Minimum laptop price
            'phone_min': -50,           # Minimum phone/accessory price

            # Software subscription thresholds
            'software_min': -500,        # Maximum software cost
            'software_max': -5,          # Minimum software subscription
            'subscription_max_days': 40, # Monthly subscriptions
            'subscription_min_days': 25,

            # Repair thresholds
            'repair_min': -800,          # Maximum repair cost
            'repair_max': -15,           # Minimum repair cost

            # General
            'max_cv': 2.0,              # Can be variable (different products)
            'min_frequency': 2,          # Need some pattern
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'hardware_min': -8000,      # Higher tech spending
                    'laptop_min': -500,
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'hardware_min': -2000,      # Lower tech spending
                    'laptop_min': -100,
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create tech-specific labeling functions"""

        def lf_tech_hardware_brands(x):
            """Major tech hardware brands"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Major tech brands
            tech_hardware_brands = [
                # Computer brands
                'apple', 'dell', 'hp', 'lenovo', 'asus', 'acer', 'msi', 'alienware',
                'microsoft surface', 'surface', 'macbook', 'imac', 'ipad',

                # Phone brands
                'iphone', 'samsung', 'huawei', 'xiaomi', 'oneplus', 'google pixel',
                'nokia', 'motorola', 'sony xperia', 'lg',

                # Tech retailers
                'apple store', 'best buy', 'fnac', 'darty', 'boulanger', 'cdiscount',
                'amazon', 'ldlc', 'materiel net', 'rue du commerce', 'pixmania',
                'micro center', 'newegg', 'frys', 'staples',

                # Online tech stores
                'dell.com', 'hp.com', 'lenovo.com', 'asus.com'
            ]

            # Check for brand presence
            for brand in tech_hardware_brands:
                if brand in text_to_check:
                    # Must be expense in reasonable tech range
                    if (x.amt_mean < 0 and
                        self.thresholds['hardware_min'] <= x.amt_mean <= self.thresholds['hardware_max']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_software_subscriptions(x):
            """Software and digital service subscriptions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Software and digital services
            software_services = [
                # Professional software
                'adobe', 'microsoft', 'office 365', 'autocad', 'photoshop',
                'creative cloud', 'dropbox', 'google drive', 'onedrive',
                'slack', 'zoom', 'teams', 'notion', 'trello', 'asana',

                # Development tools
                'github', 'gitlab', 'atlassian', 'jetbrains', 'visual studio',
                'aws', 'azure', 'google cloud', 'heroku', 'digitalocean',

                # Productivity
                'evernote', 'todoist', '1password', 'lastpass', 'malwarebytes',
                'norton', 'kaspersky', 'avast', 'bitdefender',

                # App stores
                'app store', 'google play', 'microsoft store', 'steam'
            ]

            for service in software_services:
                if service in text_to_check:
                    # Software subscriptions are usually smaller, regular amounts
                    if (x.amt_mean < 0 and
                        self.thresholds['software_min'] <= x.amt_mean <= self.thresholds['software_max']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_repairs_keywords(x):
            """Tech repair services (phones, computers)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Tech repair keywords
            tech_repair_keywords = [
                # Phone repairs
                'reparation telephone', 'reparation mobile', 'phone repair', 'mobile repair',
                'iphone repair', 'samsung repair', 'ecran casse', 'screen repair',
                'reparation ecran', 'broken screen', 'batterie telephone', 'phone battery',

                # Computer repairs
                'reparation ordinateur', 'computer repair', 'laptop repair', 'pc repair',
                'reparation pc', 'mac repair', 'imac repair', 'macbook repair',
                'depannage informatique', 'computer service', 'tech support',

                # General tech repair
                'service technique', 'technical service', 'informatique', 'geek squad',
                'genius bar', 'apple care', 'warranty', 'garantie'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in tech_repair_keywords if keyword in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['repair_min'] <= x.amt_mean <= self.thresholds['repair_max']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_naf_codes(x):
            """NAF codes for tech retail and services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Tech-related NAF codes
            tech_naf_codes = [
                # Computer and electronics retail
                "47.41Z", "47.42Z", "47.43Z",  # Electronics retail
                "46.51Z", "46.52Z",            # Computer wholesale
                "95.11Z", "95.12Z",            # Computer repair
                "62.01Z", "62.02A", "62.02B",  # Software development
                "63.11Z", "63.12Z",            # IT services
                "58.21Z", "58.29A", "58.29B", "58.29C"  # Software publishing
            ]

            if str(x.NAF_CODE).strip() in tech_naf_codes:
                if x.amt_mean < 0:  # Any tech expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_keywords_general(x):
            """General tech-related keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # General tech keywords
            general_tech_keywords = [
                # Hardware
                'ordinateur', 'computer', 'laptop', 'portable', 'desktop',
                'telephone', 'smartphone', 'mobile', 'tablette', 'tablet',
                'moniteur', 'monitor', 'ecran', 'screen', 'clavier', 'keyboard',
                'souris', 'mouse', 'casque', 'headphone', 'webcam', 'camera',
                'imprimante', 'printer', 'scanner', 'routeur', 'router',

                # Accessories
                'cable', 'chargeur', 'charger', 'adaptateur', 'adapter',
                'coque', 'case', 'protection', 'accessoire', 'accessory',

                # Software
                'logiciel', 'software', 'application', 'app', 'programme',
                'licence', 'license', 'subscription', 'abonnement'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in general_tech_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0:  # Any tech expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_text_anchor(x):
            """FastText similarity for tech-related text"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Moderate similarity threshold
            if (similarity >= 0.65 and
                x.amt_mean < 0):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_subscription_pattern(x):
            """Monthly subscription pattern for software/services"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Small regular amounts (typical of software subscriptions)
            is_subscription_amount = (self.thresholds['software_min'] <=
                                    x.amt_mean <=
                                    self.thresholds['software_max'])

            # Monthly pattern
            is_monthly = (self.thresholds['subscription_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['subscription_max_days'])

            # Reasonably consistent
            is_consistent = x.amt_cv <= 0.3

            if is_subscription_amount and is_monthly and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_app_stores(x):
            """App store and digital marketplace transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            app_stores = [
                'app store', 'apple.com', 'google play', 'microsoft store',
                'steam', 'epic games', 'ubisoft', 'origin', 'battle.net',
                'playstation', 'xbox', 'nintendo eshop'
            ]

            if any(store in text_to_check for store in app_stores):
                if x.amt_mean < 0:  # Any expense
                    return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_tech_groceries(x):
            """Exclude grocery stores"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            grocery_chains = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche'
            ]

            if any(chain in merchant_text for chain in grocery_chains):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_utilities(x):
            """Exclude utilities"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            utility_providers = [
                'edf', 'engie', 'veolia', 'suez', 'electricite', 'gaz'
            ]

            if any(provider in merchant_text for provider in utility_providers):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_restaurants(x):
            """Exclude restaurants and food"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'mcdo', 'mcdonald', 'kfc', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_transport(x):
            """Exclude transport and fuel"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'total', 'shell', 'bp', 'esso', 'station service',
                'carburant', 'essence', 'diesel', 'transport', 'sncf',
                'ratp', 'uber', 'taxi'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_very_large(x):
            """Very large amounts unlikely to be tech (unless enterprise)"""
            if x.amt_mean < -10000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_very_small(x):
            """Very small amounts unlikely to be tech"""
            if x.amt_mean > -2:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_health_medical(x):
            """Exclude health and medical"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            medical_indicators = [
                'pharmacie', 'pharmacy', 'medical', 'hopital', 'hospital',
                'clinique', 'clinic', 'docteur', 'doctor', 'dentiste'
            ]

            if any(indicator in text_to_check for indicator in medical_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_tech_hardware_brands", f=lf_tech_hardware_brands),
            LabelingFunction(name="lf_tech_software_subscriptions", f=lf_tech_software_subscriptions),
            LabelingFunction(name="lf_tech_repairs_keywords", f=lf_tech_repairs_keywords),
            LabelingFunction(name="lf_tech_naf_codes", f=lf_tech_naf_codes),
            LabelingFunction(name="lf_tech_keywords_general", f=lf_tech_keywords_general),
            LabelingFunction(name="lf_tech_text_anchor", f=lf_tech_text_anchor),
            LabelingFunction(name="lf_tech_subscription_pattern", f=lf_tech_subscription_pattern),
            LabelingFunction(name="lf_tech_app_stores", f=lf_tech_app_stores),
            LabelingFunction(name="lf_not_tech_groceries", f=lf_not_tech_groceries),
            LabelingFunction(name="lf_not_tech_utilities", f=lf_not_tech_utilities),
            LabelingFunction(name="lf_not_tech_restaurants", f=lf_not_tech_restaurants),
            LabelingFunction(name="lf_not_tech_transport", f=lf_not_tech_transport),
            LabelingFunction(name="lf_not_tech_positive_amounts", f=lf_not_tech_positive_amounts),
            LabelingFunction(name="lf_not_tech_very_large", f=lf_not_tech_very_large),
            LabelingFunction(name="lf_not_tech_very_small", f=lf_not_tech_very_small),
            LabelingFunction(name="lf_not_tech_health_medical", f=lf_not_tech_health_medical),
        ]


# Usage example
def create_tech_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run tech classifier"""

    # Create classifier instance
    classifier = TechClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results

# Example usage:
"""
tech_classifier = TechClassifier(ft, merchant_agg_df, user_profile)
tech_results = tech_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
tech_excel = extract_lf_results_to_excel(
    tech_classifier, merchant_agg_df, "tech_lf_detailed_results.xlsx"
)

print(f"Tech Results:")
print(f"- Total predicted: {tech_results['predicted_positive']}")
print(f"- High confidence: {tech_results['high_confidence_positive']}")
"""

tech_classifier = TechClassifier(ft, merchant_agg_df, user_profile)
tech_results = tech_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
tech_excel = extract_lf_results_to_excel(
    tech_classifier, merchant_agg_df, "tech_lf_detailed_results.xlsx"
)

print(f"Tech Results:")
print(f"- Total predicted: {tech_results['predicted_positive']}")
print(f"- High confidence: {tech_results['high_confidence_positive']}")

"""It's missing FNAC, and including SFR"""

class TechClassifier(CategoryClassifier):
    """Tech classifier for hardware, software, and tech repairs"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Tech", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_tech_thresholds()

        # Tech-specific anchors covering hardware, software, and repairs
        tech_anchors = [
            # Hardware
            "ordinateur", "laptop", "telephone", "smartphone", "tablette", "iphone",
            "samsung", "apple", "computer", "phone", "tablet", "ipad", "macbook",
            "dell", "hp", "lenovo", "asus", "acer", "microsoft", "surface",

            # Software/Services
            "software", "logiciel", "application", "subscription", "adobe", "office",
            "cloud", "netflix", "spotify", "dropbox", "google", "amazon",

            # Tech repairs
            "reparation", "repair", "service", "maintenance", "ecran", "screen",
            "batterie", "battery", "support", "technique", "informatique",

            # Tech accessories
            "casque", "headphone", "clavier", "keyboard", "souris", "mouse",
            "cable", "chargeur", "charger", "accessoire"
        ]
        self.setup_anchors(tech_anchors, similarity_threshold=0.65)

    def _calculate_tech_thresholds(self) -> dict:
        """Calculate tech-specific thresholds"""
        base_thresholds = {
            # Hardware thresholds
            'hardware_min': -5000,       # Maximum tech hardware cost
            'hardware_max': -30,         # Minimum meaningful hardware purchase
            'laptop_min': -200,          # Minimum laptop price
            'phone_min': -50,           # Minimum phone/accessory price

            # Software subscription thresholds
            'software_min': -500,        # Maximum software cost
            'software_max': -5,          # Minimum software subscription
            'subscription_max_days': 40, # Monthly subscriptions
            'subscription_min_days': 25,

            # Repair thresholds
            'repair_min': -800,          # Maximum repair cost
            'repair_max': -15,           # Minimum repair cost

            # General
            'max_cv': 2.0,              # Can be variable (different products)
            'min_frequency': 2,          # Need some pattern
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'hardware_min': -8000,      # Higher tech spending
                    'laptop_min': -500,
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'hardware_min': -2000,      # Lower tech spending
                    'laptop_min': -100,
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create tech-specific labeling functions"""

        def lf_tech_hardware_brands(x):
            """Major tech hardware brands"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Major tech brands
            tech_hardware_brands = [
                # Computer brands
                'apple', 'dell', 'hp', 'lenovo', 'asus', 'acer', 'msi', 'alienware',
                'microsoft surface', 'surface', 'macbook', 'imac', 'ipad',

                # Phone brands
                'iphone', 'samsung', 'huawei', 'xiaomi', 'oneplus', 'google pixel',
                'nokia', 'motorola', 'sony xperia', 'lg',

                # Tech retailers
                'apple store', 'best buy', 'fnac', 'fnac direct', 'darty', 'boulanger',
                'cdiscount', 'amazon', 'ldlc', 'materiel net', 'materiel.net',
                'rue du commerce', 'pixmania', 'micro center', 'newegg', 'frys', 'staples',

                # Online tech stores
                'dell.com', 'hp.com', 'lenovo.com', 'asus.com'
            ]

            # Check for brand presence
            for brand in tech_hardware_brands:
                if brand in text_to_check:
                    # Must be expense in reasonable tech range
                    if (x.amt_mean < 0 and
                        self.thresholds['hardware_min'] <= x.amt_mean <= self.thresholds['hardware_max']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_software_subscriptions(x):
            """Software and digital service subscriptions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Software and digital services
            software_services = [
                # Professional software
                'adobe', 'microsoft', 'office 365', 'autocad', 'photoshop',
                'creative cloud', 'dropbox', 'google drive', 'onedrive',
                'slack', 'zoom', 'teams', 'notion', 'trello', 'asana',

                # Development tools
                'github', 'gitlab', 'atlassian', 'jetbrains', 'visual studio',
                'aws', 'azure', 'google cloud', 'heroku', 'digitalocean',

                # Productivity
                'evernote', 'todoist', '1password', 'lastpass', 'malwarebytes',
                'norton', 'kaspersky', 'avast', 'bitdefender',

                # App stores
                'app store', 'google play', 'microsoft store', 'steam'
            ]

            for service in software_services:
                if service in text_to_check:
                    # Software subscriptions are usually smaller, regular amounts
                    if (x.amt_mean < 0 and
                        self.thresholds['software_min'] <= x.amt_mean <= self.thresholds['software_max']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_repairs_keywords(x):
            """Tech repair services (phones, computers)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Tech repair keywords
            tech_repair_keywords = [
                # Phone repairs
                'reparation telephone', 'reparation mobile', 'phone repair', 'mobile repair',
                'iphone repair', 'samsung repair', 'ecran casse', 'screen repair',
                'reparation ecran', 'broken screen', 'batterie telephone', 'phone battery',

                # Computer repairs
                'reparation ordinateur', 'computer repair', 'laptop repair', 'pc repair',
                'reparation pc', 'mac repair', 'imac repair', 'macbook repair',
                'depannage informatique', 'computer service', 'tech support',

                # General tech repair
                'service technique', 'technical service', 'informatique', 'geek squad',
                'genius bar', 'apple care', 'warranty', 'garantie'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in tech_repair_keywords if keyword in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['repair_min'] <= x.amt_mean <= self.thresholds['repair_max']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_naf_codes(x):
            """NAF codes for tech retail and services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Tech-related NAF codes
            tech_naf_codes = [
                # Computer and electronics retail
                "47.41Z", "47.42Z", "47.43Z",  # Electronics retail
                "46.51Z", "46.52Z",            # Computer wholesale
                "95.11Z", "95.12Z",            # Computer repair
                "62.01Z", "62.02A", "62.02B",  # Software development
                "63.11Z", "63.12Z",            # IT services
                "58.21Z", "58.29A", "58.29B", "58.29C"  # Software publishing
            ]

            if str(x.NAF_CODE).strip() in tech_naf_codes:
                if x.amt_mean < 0:  # Any tech expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_keywords_general(x):
            """General tech-related keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # General tech keywords
            general_tech_keywords = [
                # Hardware
                'ordinateur', 'computer', 'laptop', 'portable', 'desktop',
                'telephone', 'smartphone', 'mobile', 'tablette', 'tablet',
                'moniteur', 'monitor', 'ecran', 'screen', 'clavier', 'keyboard',
                'souris', 'mouse', 'casque', 'headphone', 'webcam', 'camera',
                'imprimante', 'printer', 'scanner', 'routeur', 'router',

                # Accessories
                'cable', 'chargeur', 'charger', 'adaptateur', 'adapter',
                'coque', 'case', 'protection', 'accessoire', 'accessory',

                # Software
                'logiciel', 'software', 'application', 'app', 'programme',
                'licence', 'license', 'subscription', 'abonnement'
            ]

            # Count matches for stronger signal
            matches = sum(1 for keyword in general_tech_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0:  # Any tech expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_text_anchor(x):
            """FastText similarity for tech-related text"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Moderate similarity threshold
            if (similarity >= 0.65 and
                x.amt_mean < 0):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_subscription_pattern(x):
            """Monthly subscription pattern for software/services with tech keywords"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Small regular amounts (typical of software subscriptions)
            is_subscription_amount = (self.thresholds['software_min'] <=
                                    x.amt_mean <=
                                    self.thresholds['software_max'])

            # Monthly pattern
            is_monthly = (self.thresholds['subscription_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['subscription_max_days'])

            # Reasonably consistent
            is_consistent = x.amt_cv <= 0.3

            # Must have tech-related keywords to avoid fitness/other subscriptions
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Must contain tech-related keywords
            tech_subscription_keywords = [
                'adobe', 'microsoft', 'office', 'google', 'apple', 'amazon',
                'dropbox', 'spotify', 'netflix', 'software', 'cloud',
                'app store', 'play store', 'steam', 'xbox', 'playstation'
            ]

            has_tech_keyword = any(keyword in text_to_check for keyword in tech_subscription_keywords)

            if is_subscription_amount and is_monthly and is_consistent and has_tech_keyword:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_large_infrequent(x):
            """Large infrequent purchases (typical of hardware)"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Large amounts, infrequent (hardware purchases)
            is_large_purchase = x.amt_mean <= -200
            is_infrequent = (x.amt_count <= 5 and
                           (x.mean_delta_days > 60 or x.amt_count == 1))

            if is_large_purchase and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tech_app_stores(x):
            """App store and digital marketplace transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            app_stores = [
                'app store', 'apple.com', 'google play', 'microsoft store',
                'steam', 'epic games', 'ubisoft', 'origin', 'battle.net',
                'playstation', 'xbox', 'nintendo eshop'
            ]

            if any(store in text_to_check for store in app_stores):
                if x.amt_mean < 0:  # Any expense
                    return self.POSITIVE

            return self.ABSTAIN

        # Enhanced negative labeling functions

        def lf_not_tech_groceries(x):
            """Exclude grocery stores"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            grocery_chains = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche'
            ]

            if any(chain in merchant_text for chain in grocery_chains):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_utilities(x):
            """Exclude utilities"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            utility_providers = [
                'edf', 'engie', 'veolia', 'suez', 'electricite', 'gaz'
            ]

            if any(provider in merchant_text for provider in utility_providers):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_restaurants(x):
            """Exclude restaurants and food"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'mcdo', 'mcdonald', 'kfc', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_transport(x):
            """Exclude transport and fuel"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'total', 'shell', 'bp', 'esso', 'station service',
                'carburant', 'essence', 'diesel', 'transport', 'sncf',
                'ratp', 'uber', 'taxi'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_very_large(x):
            """Very large amounts unlikely to be tech (unless enterprise)"""
            if x.amt_mean < -10000:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_very_small(x):
            """Very small amounts unlikely to be tech"""
            if x.amt_mean > -2:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tech_health_medical(x):
            """Exclude health and medical"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            medical_indicators = [
                'pharmacie', 'pharmacy', 'medical', 'hopital', 'hospital',
                'clinique', 'clinic', 'docteur', 'doctor', 'dentiste'
            ]

            if any(indicator in text_to_check for indicator in medical_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_fitness_sports(x):
            """Exclude fitness and sports subscriptions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            fitness_indicators = [
                'fitness', 'gym', 'sport', 'club', 'salle de sport',
                'musculation', 'yoga', 'pilates', 'crossfit',
                'basic fit', 'keep cool', 'l orange bleue', 'neoness'
            ]

            if any(indicator in text_to_check for indicator in fitness_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tech_telecom_providers(x):
            """Exclude major telecom providers (should be utilities, not tech)"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).lower()

            # Major telecom providers that are utilities, not tech purchases
            telecom_providers = [
                'orange', 'free', 'sfr', 'bouygues', 'red', 'sosh',
                'virgin mobile', 'nrj mobile', 'la poste mobile'
            ]

            # Monthly pattern suggests it's a telecom subscription, not tech purchase
            if (any(provider in merchant_text for provider in telecom_providers) and
                x.amt_count >= 3 and
                25 <= x.mean_delta_days <= 35):  # Monthly pattern
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_tech_hardware_brands", f=lf_tech_hardware_brands),
            LabelingFunction(name="lf_tech_software_subscriptions", f=lf_tech_software_subscriptions),
            LabelingFunction(name="lf_tech_repairs_keywords", f=lf_tech_repairs_keywords),
            LabelingFunction(name="lf_tech_naf_codes", f=lf_tech_naf_codes),
            LabelingFunction(name="lf_tech_keywords_general", f=lf_tech_keywords_general),
            LabelingFunction(name="lf_tech_text_anchor", f=lf_tech_text_anchor),
            LabelingFunction(name="lf_tech_subscription_pattern", f=lf_tech_subscription_pattern),
            LabelingFunction(name="lf_tech_large_infrequent", f=lf_tech_large_infrequent),
            LabelingFunction(name="lf_tech_app_stores", f=lf_tech_app_stores),
            LabelingFunction(name="lf_not_tech_groceries", f=lf_not_tech_groceries),
            LabelingFunction(name="lf_not_tech_utilities", f=lf_not_tech_utilities),
            LabelingFunction(name="lf_not_tech_restaurants", f=lf_not_tech_restaurants),
            LabelingFunction(name="lf_not_tech_transport", f=lf_not_tech_transport),
            LabelingFunction(name="lf_not_tech_positive_amounts", f=lf_not_tech_positive_amounts),
            LabelingFunction(name="lf_not_tech_very_large", f=lf_not_tech_very_large),
            LabelingFunction(name="lf_not_tech_very_small", f=lf_not_tech_very_small),
            LabelingFunction(name="lf_not_tech_health_medical", f=lf_not_tech_health_medical),
            LabelingFunction(name="lf_not_tech_fitness_sports", f=lf_not_tech_fitness_sports),
            LabelingFunction(name="lf_not_tech_telecom_providers", f=lf_not_tech_telecom_providers),
        ]


# Usage example
def create_tech_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run tech classifier"""

    # Create classifier instance
    classifier = TechClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results

# Example usage:
"""
tech_classifier = TechClassifier(ft, merchant_agg_df, user_profile)
tech_results = tech_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
tech_excel = extract_lf_results_to_excel(
    tech_classifier, merchant_agg_df, "tech_lf_detailed_results.xlsx"
)

print(f"Tech Results:")
print(f"- Total predicted: {tech_results['predicted_positive']}")
print(f"- High confidence: {tech_results['high_confidence_positive']}")
"""

tech_classifier = TechClassifier(ft, merchant_agg_df, user_profile)
tech_results = tech_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
tech_excel = extract_lf_results_to_excel(
    tech_classifier, merchant_agg_df, "tech_lf_detailed_results.xlsx"
)

print(f"Tech Results:")
print(f"- Total predicted: {tech_results['predicted_positive']}")
print(f"- High confidence: {tech_results['high_confidence_positive']}")

"""# Sport"""

class SportsClassifier(CategoryClassifier):
    """Enhanced sports classifier with multi-pattern detection for gym, equipment, and classes"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Sports", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_sports_thresholds()

        # Multi-tier sports anchors covering different categories
        sports_anchors = [
            # Gym/Fitness facilities
            "fitness", "gym", "musculation", "sport", "entrainement", "salle",
            # Equipment/Sportswear
            "equipment", "sportswear", "vetement", "chaussures", "running",
            # Activities
            "tennis", "football", "natation", "yoga", "pilates", "crossfit",
            # Brands/Retailers
            "decathlon", "intersport", "nike", "adidas", "puma", "reebok"
        ]
        self.setup_anchors(sports_anchors, similarity_threshold=0.6)

    def _calculate_sports_thresholds(self) -> dict:
        """Calculate sports-specific thresholds for different spending patterns"""
        base_thresholds = {
            # Gym subscription thresholds
            'gym_min_amount': -200,        # Maximum gym membership
            'gym_max_amount': -15,         # Minimum gym membership
            'gym_monthly_min_days': 25,    # Monthly subscription range
            'gym_monthly_max_days': 35,

            # Equipment purchase thresholds
            'equipment_min_amount': -1000,  # Maximum equipment purchase
            'equipment_max_amount': -25,    # Minimum equipment purchase

            # Class/session thresholds
            'class_min_amount': -100,       # Maximum class fee
            'class_max_amount': -8,         # Minimum class fee
            'class_weekly_min_days': 6,     # Weekly class range
            'class_weekly_max_days': 8,

            # General patterns
            'min_frequency': 2,             # Minimum transactions to establish pattern
            'max_cv_subscription': 0.4,     # Consistency for subscriptions
            'max_cv_equipment': 2.5,        # High variance for equipment
            'max_cv_classes': 1.0,          # Medium variance for classes
            'min_cv': 0.05,
        }

        # Adjust based on user profile if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'gym_min_amount': -300,      # Higher-end gym memberships
                    'equipment_min_amount': -2000,
                    'class_min_amount': -150
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'gym_min_amount': -80,       # Budget gym memberships
                    'equipment_min_amount': -400,
                    'class_min_amount': -50
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create comprehensive sports-specific labeling functions"""

        def lf_sports_naf_codes(x):
            """NAF codes for sports and fitness businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Sports-related NAF codes
            sports_naf_codes = [
                "85.51Z",  # Sports and recreation education
                "85.52Z",  # Cultural education
                "93.11Z",  # Operation of sports facilities
                "93.12Z",  # Activities of sports clubs
                "93.13Z",  # Fitness facilities
                "93.19Z",  # Other sports activities
                "47.64Z",  # Sporting goods retail
                "77.21Z",  # Sports equipment rental
                "96.04Z",  # Physical well-being activities
            ]

            if str(x.NAF_CODE).strip() in sports_naf_codes:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_sports_major_retailers(x):
            """Major sports retailers and equipment stores"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Comprehensive sports retailers list
            sports_retailers = [
                "DECATHLON", "INTERSPORT", "GO SPORT", "SPORT 2000", "NIKE", "ADIDAS",
                "PUMA", "REEBOK", "UNDER ARMOUR", "COLUMBIA", "QUIKSILVER", "ROXY",
                "SALOMON", "THE NORTH FACE", "PATAGONIA", "ASICS", "NEW BALANCE",
                "CONVERSE", "VANS", "FOOTLOCKER", "JD SPORTS", "SIZE", "SNIPES",
                "ALLTRICKS", "PROBIKESHOP", "EKOSPORT", "SNOWLEADER", "GLISSHOP",
                "TENNIS ACHAT", "TENNIS WAREHOUSE", "WIGGLE", "CHAIN REACTION",
                "BASIC FIT", "FITNESS PARK", "NEONESS", "KEEP COOL", "ORANGE BLEUE",
                "L'APPART FITNESS", "GIGAGYM", "FITNESS BOUTIQUE"
            ]

            # Check for exact or partial match
            for retailer in sports_retailers:
                if retailer in merchant_text:
                    if x.amt_mean < 0:  # Should be expense
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_gym_memberships(x):
            """Detect gym membership patterns - monthly subscriptions"""
            if x.amt_mean >= 0 or x.amt_count < 3:  # Need multiple transactions
                return self.ABSTAIN

            # Check amount range for gym memberships
            is_gym_amount = (self.thresholds['gym_min_amount'] <=
                           x.amt_mean <=
                           self.thresholds['gym_max_amount'])

            # Check monthly pattern (25-35 days)
            is_monthly_pattern = (self.thresholds['gym_monthly_min_days'] <=
                                x.mean_delta_days <=
                                self.thresholds['gym_monthly_max_days'])

            # Should be consistent (low coefficient of variation)
            is_consistent = x.amt_cv <= self.thresholds['max_cv_subscription']

            if is_gym_amount and is_monthly_pattern and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_equipment_purchases(x):
            """Detect sporadic equipment purchases"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Check amount range for equipment
            is_equipment_amount = (self.thresholds['equipment_min_amount'] <=
                                 x.amt_mean <=
                                 self.thresholds['equipment_max_amount'])

            # Equipment purchases can be infrequent and variable
            is_equipment_pattern = (
                (x.amt_count <= 5) or  # Infrequent purchases
                (x.amt_cv <= self.thresholds['max_cv_equipment'])  # Or variable amounts
            )

            if is_equipment_amount and is_equipment_pattern:
                # Additional check: merchant or text should suggest sports
                has_sports_context = False
                if not pd.isna(x.MERCHANT):
                    merchant_lower = str(x.MERCHANT).lower()
                    sports_contexts = ['sport', 'decathlon', 'intersport', 'nike', 'adidas', 'fitness']
                    has_sports_context = any(context in merchant_lower for context in sports_contexts)

                if has_sports_context:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_fitness_classes(x):
            """Detect fitness class payments - weekly or irregular"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Check amount range for classes
            is_class_amount = (self.thresholds['class_min_amount'] <=
                             x.amt_mean <=
                             self.thresholds['class_max_amount'])

            # Check for weekly pattern or reasonable variability
            is_class_pattern = (
                (self.thresholds['class_weekly_min_days'] <=
                 x.mean_delta_days <=
                 self.thresholds['class_weekly_max_days']) or  # Weekly
                (x.amt_cv <= self.thresholds['max_cv_classes'])  # Moderate consistency
            )

            if is_class_amount and is_class_pattern:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_brand_keywords(x):
            """Detect sports brands and fitness keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Sports brands and keywords
            sports_keywords = [
                # Brands
                'nike', 'adidas', 'puma', 'reebok', 'under armour', 'asics', 'new balance',
                'salomon', 'columbia', 'the north face', 'patagonia', 'quiksilver',

                # Fitness facilities
                'fitness', 'gym', 'musculation', 'salle de sport', 'club de sport',
                'basic fit', 'keep cool', 'orange bleue', 'neoness', 'gigagym',

                # Activities
                'yoga', 'pilates', 'crossfit', 'zumba', 'aquagym', 'spinning',
                'tennis', 'football', 'basketball', 'volleyball', 'badminton',
                'natation', 'piscine', 'escalade', 'running', 'jogging',

                # Equipment
                'sport equipment', 'equipement sport', 'materiel sport',
                'chaussures sport', 'vetement sport', 'sportswear',

                # Retailers
                'decathlon', 'intersport', 'go sport', 'sport 2000'
            ]

            matches = sum(1 for keyword in sports_keywords if keyword in text_to_check)

            if matches >= 1:  # At least one match
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_text_anchor(x):
            """FastText similarity with sports anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require good similarity and expense pattern
            if similarity >= 0.6 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_activity_specific(x):
            """Detect specific sports activities and clubs"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Specific activity keywords
            activity_keywords = [
                'club tennis', 'club football', 'club natation', 'club athletisme',
                'centre equestre', 'golf club', 'tennis club', 'yacht club',
                'dojo', 'tatami', 'judo', 'karate', 'boxe', 'mma',
                'studio yoga', 'centre yoga', 'pilates studio',
                'salle escalade', 'mur escalade', 'climbing',
                'piscine municipale', 'centre aquatique'
            ]

            if any(keyword in text_to_check for keyword in activity_keywords):
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_sports_subscription_amounts(x):
            """Detect common sports subscription amounts"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Common monthly sports subscription amounts
            amount_abs = abs(int(x.amt_mean))
            common_sports_amounts = [
                19, 20, 25, 29, 30, 35, 39, 40, 45, 49, 50,
                59, 60, 69, 70, 79, 80, 89, 90, 99, 100
            ]

            is_common_amount = amount_abs in common_sports_amounts
            is_consistent = x.amt_cv <= 0.3  # Very consistent
            is_monthly = 25 <= x.mean_delta_days <= 35  # Monthly pattern

            if is_common_amount and is_consistent and is_monthly:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_sports_positive_amounts(x):
            """Positive amounts are income, not sports expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_sports_groceries(x):
            """Exclude grocery transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_sports_restaurants(x):
            """Exclude restaurant transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_sports_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez', 'electricite', 'gaz', 'eau', 'internet'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_sports_medical(x):
            """Exclude medical/health expenses that might overlap"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            medical_indicators = [
                'pharmacie', 'medecin', 'docteur', 'hopital', 'clinique',
                'kinesitherapeute', 'osteopathe', 'physiotherapie',
                'secu', 'cpam', 'mutuelle', 'assurance sante'
            ]

            if any(indicator in text_to_check for indicator in medical_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_sports_general_clothing(x):
            """Exclude general clothing stores (not sportswear)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            clothing_indicators = [
                'h&m', 'zara', 'uniqlo', 'c&a', 'kiabi', 'primark',
                'galeries lafayette', 'printemps', 'boutique',
                'mode', 'fashion', 'vetement' # Only if no sports context
            ]

            # Check for clothing indicators without sports context
            has_clothing = any(indicator in text_to_check for indicator in clothing_indicators)
            has_sports_context = any(sport in text_to_check for sport in ['sport', 'fitness', 'running'])

            if has_clothing and not has_sports_context:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_sports_very_large(x):
            """Very large amounts unlikely to be sports (except premium equipment)"""
            if x.amt_mean < -1500:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_sports_very_small_frequent(x):
            """Very small frequent amounts unlikely to be sports"""
            if (x.amt_mean > -5 and  # Very small amounts
                x.amt_count > 10 and  # Very frequent
                x.mean_delta_days < 7):  # More than weekly
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            # Positive labeling functions
            LabelingFunction(name="lf_sports_naf_codes", f=lf_sports_naf_codes),
            LabelingFunction(name="lf_sports_major_retailers", f=lf_sports_major_retailers),
            LabelingFunction(name="lf_sports_gym_memberships", f=lf_sports_gym_memberships),
            LabelingFunction(name="lf_sports_equipment_purchases", f=lf_sports_equipment_purchases),
            LabelingFunction(name="lf_sports_fitness_classes", f=lf_sports_fitness_classes),
            LabelingFunction(name="lf_sports_brand_keywords", f=lf_sports_brand_keywords),
            LabelingFunction(name="lf_sports_text_anchor", f=lf_sports_text_anchor),
            LabelingFunction(name="lf_sports_activity_specific", f=lf_sports_activity_specific),
            LabelingFunction(name="lf_sports_subscription_amounts", f=lf_sports_subscription_amounts),

            # Negative labeling functions
            LabelingFunction(name="lf_not_sports_positive_amounts", f=lf_not_sports_positive_amounts),
            LabelingFunction(name="lf_not_sports_groceries", f=lf_not_sports_groceries),
            LabelingFunction(name="lf_not_sports_restaurants", f=lf_not_sports_restaurants),
            LabelingFunction(name="lf_not_sports_utilities", f=lf_not_sports_utilities),
            LabelingFunction(name="lf_not_sports_medical", f=lf_not_sports_medical),
            LabelingFunction(name="lf_not_sports_general_clothing", f=lf_not_sports_general_clothing),
            LabelingFunction(name="lf_not_sports_very_large", f=lf_not_sports_very_large),
            LabelingFunction(name="lf_not_sports_very_small_frequent", f=lf_not_sports_very_small_frequent),
        ]


# Usage functions
def create_sports_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run sports classifier"""

    # Create classifier instance
    classifier = SportsClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Create sports classifier
sports_classifier = SportsClassifier(ft, merchant_agg_df, user_profile)
sports_results = sports_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
sports_excel = extract_lf_results_to_excel(
    sports_classifier, merchant_agg_df, "sports_lf_detailed_results.xlsx"
)

print(f"Sports Results:")
print(f"- Total predicted: {sports_results['predicted_positive']}")
print(f"- High confidence: {sports_results['high_confidence_positive']}")

# Analyze patterns
print(f"\nSports Examples:")
display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'sports_confidence']
print(sports_results['high_confidence_examples'][display_cols].head(10))
"""

# Create sports classifier
sports_classifier = SportsClassifier(ft, merchant_agg_df, user_profile)
sports_results = sports_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
sports_excel = extract_lf_results_to_excel(
    sports_classifier, merchant_agg_df, "sports_lf_detailed_results.xlsx"
)

print(f"Sports Results:")
print(f"- Total predicted: {sports_results['predicted_positive']}")
print(f"- High confidence: {sports_results['high_confidence_positive']}")

# Analyze patterns
print(f"\nSports Examples:")
display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'sports_confidence']
print(sports_results['high_confidence_examples'][display_cols].head(10))

"""# Looks"""

class LooksClassifier(CategoryClassifier):
    """Looks/Beauty classifier for clothing, haircuts, cosmetics, skincare"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Looks", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_looks_thresholds()

        # Looks-specific anchors
        looks_anchors = [
            "vetement", "clothing", "mode", "fashion", "coiffure", "hair", "beaute", "beauty",
            "cosmetique", "cosmetics", "parfum", "perfume", "maquillage", "makeup",
            "soin", "skincare", "salon", "barbier", "barber", "esthetique", "aesthetic",
            "manucure", "pedicure", "massage", "spa", "coiffeur", "hairdresser"
        ]
        self.setup_anchors(looks_anchors, similarity_threshold=0.65)

    def _calculate_looks_thresholds(self) -> dict:
        """Calculate looks-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -3000,        # Designer clothing/luxury beauty
            'max_amount': -5,           # Small beauty products
            'service_min_days': 20,     # Hair/beauty services (3-8 weeks)
            'service_max_days': 60,
            'shopping_min_days': 60,    # Clothing shopping (seasonal)
            'shopping_max_days': 180,
            'min_frequency': 1,         # Single purchases acceptable
            'max_cv': 2.0,             # High variability expected
            'seasonal_patterns': True   # Strong seasonality
        }

        # Adjust based on user profile and lifestyle
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -5000,    # Luxury fashion/beauty treatments
                    'max_amount': -10,      # Higher threshold for premium products
                    'luxury_threshold': -1000  # Designer items
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -800,     # Budget fashion/beauty
                    'max_amount': -3,       # Drugstore cosmetics
                    'luxury_threshold': -200
                })
        else:
            base_thresholds['luxury_threshold'] = -500

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create looks/beauty-specific labeling functions"""

        def lf_looks_naf_codes(x):
            """NAF codes for fashion, beauty, and personal care"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            looks_naf_codes = [
                # Clothing and fashion
                "47.71Z",  # Retail sale of clothing
                "47.72A",  # Retail sale of footwear
                "47.72B",  # Retail sale of leather goods
                "14.11Z",  # Manufacture of leather clothes
                "14.12Z",  # Manufacture of workwear
                "14.13Z",  # Manufacture of other outerwear
                "14.14Z",  # Manufacture of underwear
                "14.19Z",  # Manufacture of other wearing apparel
                "14.20Z",  # Manufacture of articles of fur
                "15.20Z",  # Manufacture of footwear

                # Personal care services
                "96.02A",  # Hairdressing
                "96.02B",  # Beauty treatment
                "96.04Z",  # Physical well-being activities

                # Cosmetics and perfumes
                "20.42Z",  # Manufacture of perfumes and toilet preparations
                "47.75Z",  # Retail sale of cosmetic and toilet articles

                # Jewelry and accessories
                "47.77Z",  # Retail sale of watches and jewelry
                "32.12Z",  # Manufacture of jewelry and related articles
                "32.13Z",  # Manufacture of imitation jewelry

                # Textiles
                "47.51Z",  # Retail sale of textiles
                "13.10Z",  # Preparation and spinning of textile fibres
                "13.20Z",  # Weaving of textiles
            ]

            if str(x.NAF_CODE).strip() in looks_naf_codes:
                if (x.amt_mean < 0 and
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_looks_major_fashion_retailers_high_confidence(x):
            """HIGH CONFIDENCE: Major fashion and beauty retailers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Top fashion/beauty retailers - almost exclusively looks-related
            top_fashion_beauty_retailers = [
                # Fast fashion
                "ZARA", "H&M", "UNIQLO", "MANGO", "BERSHKA", "PULL BEAR",
                "STRADIVARIUS", "MASSIMO DUTTI", "COS", "WEEKDAY",

                # Department stores (fashion)
                "GALERIES LAFAYETTE", "PRINTEMPS", "BHV MARAIS", "BON MARCHE",
                "NORDSTROM", "MACY'S", "BLOOMINGDALE'S",

                # Beauty specialists
                "SEPHORA", "ULTA", "NOCIBE", "MARIONNAUD", "DOUGLAS",
                "BEAUTY SUCCESS", "YVES ROCHER", "BODY SHOP",

                # Luxury fashion
                "CHANEL", "DIOR", "LOUIS VUITTON", "GUCCI", "PRADA", "HERMES",
                "SAINT LAURENT", "GIVENCHY", "BURBERRY", "VERSACE",

                # Sportswear (fashion aspect)
                "NIKE", "ADIDAS", "PUMA", "REEBOK", "UNDER ARMOUR",
                "LULULEMON", "ATHLETA", "FOOT LOCKER",

                # Accessories
                "PANDORA", "SWAROVSKI", "MICHAEL KORS", "KATE SPADE",

                # Online fashion
                "ASOS", "ZALANDO", "AMAZON FASHION", "NET A PORTER",
                "FARFETCH", "SSENSE", "MYTHERESA"
            ]

            # For these retailers, very relaxed criteria
            for retailer in top_fashion_beauty_retailers:
                if retailer in merchant_text:
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_beauty_services(x):
            """Beauty and personal care services"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Beauty service keywords
            beauty_service_keywords = [
                # Hair services
                'coiffeur', 'coiffure', 'hairdresser', 'hair salon', 'salon coiffure',
                'barbier', 'barber', 'barbershop', 'coupe', 'haircut', 'coloration',
                'meche', 'highlights', 'permanente', 'brushing', 'shampoing',

                # Beauty treatments
                'esthetique', 'estheticienne', 'beauty salon', 'institut beaute',
                'soin visage', 'facial', 'epilation', 'waxing', 'massage',
                'manucure', 'manicure', 'pedicure', 'onglerie', 'nail salon',

                # Spa and wellness
                'spa', 'hammam', 'sauna', 'thalasso', 'wellness', 'bien etre',
                'relaxation', 'soins corps', 'body treatment', 'gommage'
            ]

            if any(keyword in text_to_check for keyword in beauty_service_keywords):
                # Services should be reasonable amounts and somewhat regular
                if (x.amt_mean < 0 and
                    -300 <= x.amt_mean <= -15 and  # Service price range
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_comprehensive_keywords(x):
            """Comprehensive fashion and beauty keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            looks_keywords = {
                # Clothing
                'clothing': ['vetement', 'clothing', 'habit', 'robe', 'dress', 'jupe', 'skirt',
                           'pantalon', 'pants', 'jean', 'chemise', 'shirt', 'pull', 'sweater',
                           'veste', 'jacket', 'manteau', 'coat', 'lingerie', 'underwear',
                           'chaussette', 'sock', 'collant', 'tights', 'pyjama'],

                # Footwear
                'shoes': ['chaussure', 'shoes', 'botte', 'boots', 'sneaker', 'basket',
                         'escarpin', 'pump', 'sandale', 'sandal', 'tong', 'flip flop',
                         'talon', 'heel', 'ballerine', 'flat', 'mocassin', 'loafer'],

                # Accessories
                'accessories': ['accessoire', 'sac', 'bag', 'portefeuille', 'wallet',
                              'ceinture', 'belt', 'echarpe', 'scarf', 'chapeau', 'hat',
                              'casquette', 'cap', 'bijou', 'jewelry', 'montre', 'watch',
                              'lunette', 'glasses', 'bague', 'ring', 'collier', 'necklace'],

                # Cosmetics
                'cosmetics': ['maquillage', 'makeup', 'cosmetique', 'cosmetic', 'fond teint',
                            'foundation', 'rouge levres', 'lipstick', 'mascara', 'eye liner',
                            'fard', 'eyeshadow', 'blush', 'poudre', 'powder', 'vernis',
                            'nail polish', 'dissolvant', 'remover'],

                # Skincare
                'skincare': ['soin', 'skincare', 'creme', 'cream', 'serum', 'lotion',
                           'nettoyant', 'cleanser', 'tonique', 'toner', 'hydratant',
                           'moisturizer', 'anti age', 'anti aging', 'protection solaire',
                           'sunscreen', 'gommage', 'scrub', 'masque', 'mask'],

                # Fragrance
                'fragrance': ['parfum', 'perfume', 'eau toilette', 'eau parfum',
                            'fragrance', 'cologne', 'deodorant', 'antiperspirant'],

                # Hair care
                'haircare': ['cheveu', 'hair', 'shampoing', 'shampoo', 'apres shampoing',
                           'conditioner', 'masque cheveu', 'hair mask', 'huile', 'oil',
                           'gel', 'mousse', 'laque', 'hairspray', 'seche cheveu', 'blow dry']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in looks_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Strong signal requirements
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'clothing' in category_matches or  # Clothing is strong signal
                'shoes' in category_matches or  # Footwear is strong signal
                category_matches.get('cosmetics', 0) >= 1 or  # Beauty products
                category_matches.get('skincare', 0) >= 1  # Skincare products
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_text_anchor(x):
            """FastText similarity for looks/beauty terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean >= self.thresholds['min_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_service_pattern(x):
            """Regular beauty service patterns (hair, nails, etc.)"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Regular beauty services (every 3-8 weeks)
            is_regular_service = (
                self.thresholds['service_min_days'] <= x.mean_delta_days <= self.thresholds['service_max_days'] and
                -200 <= x.amt_mean <= -20 and  # Service price range
                x.amt_cv <= 0.8  # Reasonably consistent
            )

            if is_regular_service:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_seasonal_shopping(x):
            """Seasonal clothing shopping patterns"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Seasonal shopping (every 2-6 months)
            is_seasonal_shopping = (
                self.thresholds['shopping_min_days'] <= x.mean_delta_days <= self.thresholds['shopping_max_days'] and
                x.amt_mean <= -50 and  # Substantial clothing purchases
                x.amt_cv <= 1.5  # Some variability allowed
            )

            if is_seasonal_shopping:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_luxury_fashion(x):
            """Luxury fashion and beauty purchases"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            luxury_threshold = self.thresholds.get('luxury_threshold', -500)

            # Large fashion/beauty purchases
            is_luxury_purchase = x.amt_mean < luxury_threshold

            # Check for luxury context
            luxury_indicators = []
            if not pd.isna(x.MERCHANT):
                luxury_indicators.append(str(x.MERCHANT).lower())
            if not pd.isna(x.CLEANED_TEXT):
                luxury_indicators.append(str(x.CLEANED_TEXT).lower())

            text_to_check = " ".join(luxury_indicators)

            luxury_keywords = [
                'luxe', 'luxury', 'designer', 'couture', 'premium', 'haut gamme',
                'chanel', 'dior', 'gucci', 'prada', 'hermes', 'versace',
                'galeries lafayette', 'printemps', 'sephora', 'salon'
            ]

            has_luxury_context = any(keyword in text_to_check for keyword in luxury_keywords)

            if is_luxury_purchase and has_luxury_context:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_looks_drugstore_beauty(x):
            """Drugstore beauty and personal care purchases"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Drugstores and pharmacies that sell beauty products
            drugstore_beauty = [
                'pharmacie', 'pharmacy', 'parapharmacie', 'monoprix', 'carrefour',
                'leclerc', 'auchan', 'super u', 'intermarche', 'casino',
                'dm', 'rossmann', 'douglas', 'boots', 'cvs', 'walgreens'
            ]

            has_drugstore = any(store in merchant_lower for store in drugstore_beauty)

            if has_drugstore:
                # Small to medium beauty/personal care purchases
                if (x.amt_mean < 0 and
                    -100 <= x.amt_mean <= -5 and  # Drugstore price range
                    x.amt_count >= 1):
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_looks_groceries_food(x):
            """Exclude grocery/food transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            food_indicators = [
                'supermarche', 'hypermarche', 'alimentaire', 'epicerie', 'market',
                'carrefour', 'leclerc', 'aldi', 'lidl', 'restaurant', 'cafe',
                'boulangerie', 'patisserie', 'fast food', 'delivery'
            ]

            if any(indicator in text_to_check for indicator in food_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_looks_electronics_tech(x):
            """Exclude electronics and tech purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            tech_indicators = [
                'apple', 'samsung', 'microsoft', 'google', 'amazon tech',
                'fnac', 'darty', 'boulanger', 'phone', 'computer', 'laptop',
                'tablet', 'software', 'app store', 'play store'
            ]

            if any(indicator in text_to_check for indicator in tech_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_looks_transport_fuel(x):
            """Exclude transport and fuel transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'gazole', 'fuel', 'station service', 'total', 'bp',
                'shell', 'esso', 'metro', 'bus', 'train', 'sncf', 'parking',
                'peage', 'toll', 'uber', 'taxi'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_looks_utilities_bills(x):
            """Exclude utility bills and services"""
            if (x.amt_count >= 6 and
                25 <= x.mean_delta_days <= 35 and  # Monthly
                x.amt_cv <= 0.3 and  # Very consistent
                -200 <= x.amt_mean <= -20):  # Utility-like amounts

                # Unless it's clearly beauty subscription
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                beauty_subs = ['sephora', 'beauty', 'subscription', 'box beaute']
                is_beauty_sub = any(sub in text_to_check for sub in beauty_subs)

                if not is_beauty_sub:
                    return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_looks_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_looks_very_large_amounts(x):
            """Very large amounts (likely cars, real estate)"""
            # Use income-adjusted threshold
            max_reasonable = self.thresholds['min_amount'] * 3  # 3x max looks threshold
            if x.amt_mean < max_reasonable:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_looks_household_furniture(x):
            """Exclude household/furniture purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            household_indicators = [
                'ikea', 'castorama', 'leroy merlin', 'but', 'conforama',
                'meuble', 'furniture', 'bricolage', 'diy', 'jardin', 'garden'
            ]

            if any(indicator in text_to_check for indicator in household_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_looks_naf_codes", f=lf_looks_naf_codes),
            LabelingFunction(name="lf_looks_major_fashion_retailers_high_confidence", f=lf_looks_major_fashion_retailers_high_confidence),
            LabelingFunction(name="lf_looks_beauty_services", f=lf_looks_beauty_services),
            LabelingFunction(name="lf_looks_comprehensive_keywords", f=lf_looks_comprehensive_keywords),
            LabelingFunction(name="lf_looks_text_anchor", f=lf_looks_text_anchor),
            LabelingFunction(name="lf_looks_service_pattern", f=lf_looks_service_pattern),
            LabelingFunction(name="lf_looks_seasonal_shopping", f=lf_looks_seasonal_shopping),
            LabelingFunction(name="lf_looks_luxury_fashion", f=lf_looks_luxury_fashion),
            LabelingFunction(name="lf_looks_drugstore_beauty", f=lf_looks_drugstore_beauty),
            LabelingFunction(name="lf_not_looks_groceries_food", f=lf_not_looks_groceries_food),
            LabelingFunction(name="lf_not_looks_electronics_tech", f=lf_not_looks_electronics_tech),
            LabelingFunction(name="lf_not_looks_transport_fuel", f=lf_not_looks_transport_fuel),
            LabelingFunction(name="lf_not_looks_utilities_bills", f=lf_not_looks_utilities_bills),
            LabelingFunction(name="lf_not_looks_positive_amounts", f=lf_not_looks_positive_amounts),
            LabelingFunction(name="lf_not_looks_very_large_amounts", f=lf_not_looks_very_large_amounts),
            LabelingFunction(name="lf_not_looks_household_furniture", f=lf_not_looks_household_furniture),
        ]


# Usage function
def create_looks_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run looks classifier"""

    # Create classifier instance
    classifier = LooksClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
looks_classifier = LooksClassifier(ft, merchant_agg_df, user_profile)
looks_results = looks_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
looks_excel = extract_lf_results_to_excel(
    looks_classifier, merchant_agg_df, "looks_lf_detailed_results.xlsx"
)

print(f"Looks Results:")
print(f"- Total predicted: {looks_results['predicted_positive']}")
print(f"- High confidence: {looks_results['high_confidence_positive']}")
"""

looks_classifier = LooksClassifier(ft, merchant_agg_df, user_profile)
looks_results = looks_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
looks_excel = extract_lf_results_to_excel(
    looks_classifier, merchant_agg_df, "looks_lf_detailed_results.xlsx"
)

print(f"Looks Results:")
print(f"- Total predicted: {looks_results['predicted_positive']}")
print(f"- High confidence: {looks_results['high_confidence_positive']}")

"""# Admin"""

class LegalClassifier(CategoryClassifier):
    """Legal services classifier (lawyers, notaries, legal fees)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Legal", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_legal_thresholds()

        legal_anchors = [
            "avocat", "lawyer", "notaire", "notary", "juridique", "legal",
            "tribunal", "court", "huissier", "cabinet", "droit"
        ]
        self.setup_anchors(legal_anchors, similarity_threshold=0.75)

    def _calculate_legal_thresholds(self) -> dict:
        return {
            'min_amount': -20000,       # Major legal cases
            'max_amount': -50,          # Minimum legal consultation
            'consultation_min': -150,   # Typical consultation fee
            'notary_min': -300,         # Notary services minimum
            'max_frequency': 12,        # Legal services are typically infrequent
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_legal_naf_codes(x):
            """NAF codes for legal services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            legal_naf_codes = [
                "69.10Z",  # Legal activities
                "69.10A",  # Legal activities - lawyers
                "69.10B",  # Legal activities - notaries
                "84.23Z",  # Justice activities
            ]

            if str(x.NAF_CODE).strip() in legal_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_legal_high_confidence_keywords(x):
            """High confidence legal keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            high_confidence_legal = [
                'avocat', 'lawyer', 'attorney', 'cabinet avocat',
                'notaire', 'notary', 'office notarial', 'etude notariale',
                'huissier', 'bailiff', 'commissaire priseur',
                'tribunal', 'court', 'palais justice',
                'ordre avocat', 'barreau', 'chambre notaire'
            ]

            if any(keyword in text_to_check for keyword in high_confidence_legal):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_legal_text_anchor(x):
            """FastText similarity for legal terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.75 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['consultation_min']):  # Higher threshold for anchor
                return self.POSITIVE

            return self.ABSTAIN

        def lf_legal_substantial_infrequent(x):
            """Legal services are typically substantial and infrequent"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['max_amount']:
                return self.ABSTAIN

            is_substantial = x.amt_mean <= self.thresholds['consultation_min']
            is_infrequent = x.amt_count <= self.thresholds['max_frequency']

            if is_substantial and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions
        def lf_not_legal_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_legal_very_frequent(x):
            """Very frequent payments unlikely to be legal"""
            if x.amt_count > 20 or (x.amt_count > 6 and x.mean_delta_days < 30):
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_legal_naf_codes", f=lf_legal_naf_codes),
            LabelingFunction(name="lf_legal_high_confidence_keywords", f=lf_legal_high_confidence_keywords),
            LabelingFunction(name="lf_legal_text_anchor", f=lf_legal_text_anchor),
            LabelingFunction(name="lf_legal_substantial_infrequent", f=lf_legal_substantial_infrequent),
            LabelingFunction(name="lf_not_legal_positive_amounts", f=lf_not_legal_positive_amounts),
            LabelingFunction(name="lf_not_legal_very_frequent", f=lf_not_legal_very_frequent),
        ]


class InsuranceClassifier(CategoryClassifier):
    """Insurance premiums classifier (health, car, home insurance)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Insurance", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_insurance_thresholds()

        insurance_anchors = [
            "assurance", "insurance", "mutuelle", "premium", "police",
            "axa", "allianz", "generali", "maif", "macif", "mgen"
        ]
        self.setup_anchors(insurance_anchors, similarity_threshold=0.7)

    def _calculate_insurance_thresholds(self) -> dict:
        return {
            'min_amount': -2000,        # Annual premiums can be substantial
            'max_amount': -10,          # Minimum insurance payment
            'monthly_min_days': 25,     # Monthly payments
            'monthly_max_days': 35,
            'quarterly_min_days': 85,   # Quarterly payments
            'quarterly_max_days': 95,
            'annual_min_days': 350,     # Annual payments
            'annual_max_days': 380,
            'min_frequency': 2,         # Need pattern recognition
            'max_cv': 0.3,             # Insurance payments are very consistent
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_insurance_naf_codes(x):
            """NAF codes for insurance"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            insurance_naf_codes = [
                "65.11Z",  # Life insurance
                "65.12Z",  # Non-life insurance
                "65.20Z",  # Reinsurance
                "66.21Z",  # Risk and damage evaluation
                "66.22Z",  # Insurance agents and brokers
                "66.29Z",  # Other insurance and pension funding
            ]

            if str(x.NAF_CODE).strip() in insurance_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_insurance_major_providers(x):
            """Major insurance companies"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            major_insurance_providers = [
                "AXA", "ALLIANZ", "GENERALI", "CNP", "CREDIT AGRICOLE ASSURANCES",
                "BNP PARIBAS CARDIF", "GROUPAMA", "MAIF", "MACIF", "MATMUT",
                "MGEN", "HARMONIE MUTUELLE", "MALAKOFF MEDERIC", "AG2R",
                "APRIL", "SWISS LIFE", "AVIVA", "ZURICH", "MMA", "GMF",
                "SMACL", "ASSU 2000", "EUROFIL", "LUKO", "FRIDAY"
            ]

            for provider in major_insurance_providers:
                if provider in merchant_text:
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_insurance_keywords_specific(x):
            """Specific insurance keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            insurance_keywords = [
                # General insurance
                'assurance', 'insurance', 'assurances', 'prime assurance',
                'police assurance', 'cotisation', 'mutuelle',

                # Specific types
                'assurance auto', 'car insurance', 'assurance automobile',
                'assurance habitation', 'home insurance', 'assurance logement',
                'assurance sante', 'health insurance', 'assurance maladie',
                'assurance vie', 'life insurance', 'assurance deces',
                'assurance voyage', 'travel insurance',
                'responsabilite civile', 'liability insurance',

                # Payment terms
                'prime mensuelle', 'monthly premium', 'cotisation annuelle',
                'echeance assurance', 'renouvellement police'
            ]

            if any(keyword in text_to_check for keyword in insurance_keywords):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_insurance_regular_pattern(x):
            """Insurance regular payment patterns"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or
                x.amt_count < self.thresholds['min_frequency']):
                return self.ABSTAIN

            # Check for regular payment patterns
            is_monthly = (self.thresholds['monthly_min_days'] <=
                         x.mean_delta_days <=
                         self.thresholds['monthly_max_days'])

            is_quarterly = (self.thresholds['quarterly_min_days'] <=
                           x.mean_delta_days <=
                           self.thresholds['quarterly_max_days'])

            is_annual = (self.thresholds['annual_min_days'] <=
                        x.mean_delta_days <=
                        self.thresholds['annual_max_days'])

            is_consistent = x.amt_cv <= self.thresholds['max_cv']

            if (is_monthly or is_quarterly or is_annual) and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_insurance_text_anchor(x):
            """FastText similarity for insurance"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions
        def lf_not_insurance_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_insurance_very_irregular(x):
            """Very irregular payments unlikely to be insurance"""
            if x.amt_count >= 3 and x.amt_cv > 0.8:
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_insurance_naf_codes", f=lf_insurance_naf_codes),
            LabelingFunction(name="lf_insurance_major_providers", f=lf_insurance_major_providers),
            LabelingFunction(name="lf_insurance_keywords_specific", f=lf_insurance_keywords_specific),
            LabelingFunction(name="lf_insurance_regular_pattern", f=lf_insurance_regular_pattern),
            LabelingFunction(name="lf_insurance_text_anchor", f=lf_insurance_text_anchor),
            LabelingFunction(name="lf_not_insurance_positive_amounts", f=lf_not_insurance_positive_amounts),
            LabelingFunction(name="lf_not_insurance_very_irregular", f=lf_not_insurance_very_irregular),
        ]


class TaxClassifier(CategoryClassifier):
    """Tax payments classifier (income tax, property tax, excludes accounting fees)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Tax", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_tax_thresholds()

        tax_anchors = [
            "impot", "tax", "taxes", "fiscal", "tresor", "dgfip",
            "taxe", "contribution", "prelevement"
        ]
        self.setup_anchors(tax_anchors, similarity_threshold=0.75)

    def _calculate_tax_thresholds(self) -> dict:
        return {
            'min_amount': -50000,       # High earners can have substantial tax bills
            'max_amount': -20,          # Minimum tax payment
            'substantial_min': -100,    # Substantial tax payments
            'max_frequency': 12,        # Taxes are typically infrequent
            'annual_pattern_days': 300, # Annual tax payments
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_tax_government_entities(x):
            """Government tax entities"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            tax_entities = [
                "DGFIP", "TRESOR PUBLIC", "TRESOR", "CENTRE IMPOTS",
                "RECETTE FINANCES", "PERCEPTEUR", "TAX OFFICE",
                "CENTRE DES FINANCES", "HOTEL IMPOTS", "SIP",
                "SERVICE IMPOTS", "PREFECTURE", "MAIRIE", "COMMUNE"
            ]

            for entity in tax_entities:
                if entity in merchant_text:
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_tax_keywords_specific(x):
            """Specific tax keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            tax_keywords = [
                # Direct taxes
                'impot revenu', 'income tax', 'impot societes', 'corporate tax',
                'taxe habitation', 'property tax', 'taxe fonciere',
                'contribution economique', 'cet', 'cvae', 'cfe',

                # Social contributions
                'urssaf', 'cotisation sociale', 'charges sociales',
                'rsi', 'secu independant', 'cpam',

                # Local taxes
                'taxe ordures', 'taxe assainissement', 'taxe voirie',
                'redevance audiovisuelle', 'contribution audiovisuelle',

                # Vehicle taxes
                'carte grise', 'immatriculation', 'taxe carburant',

                # VAT and other
                'tva', 'vat', 'douane', 'customs', 'octroi mer'
            ]

            if any(keyword in text_to_check for keyword in tax_keywords):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_tax_text_anchor(x):
            """FastText similarity for tax terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.75 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['substantial_min']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_tax_substantial_infrequent(x):
            """Taxes are typically substantial and infrequent"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['max_amount']:
                return self.ABSTAIN

            is_substantial = x.amt_mean <= self.thresholds['substantial_min']
            is_infrequent = x.amt_count <= self.thresholds['max_frequency']
            has_long_gaps = x.mean_delta_days >= 60 if x.amt_count > 1 else True

            if is_substantial and is_infrequent and has_long_gaps:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions excluding accounting fees
        def lf_not_tax_accounting_fees(x):
            """Exclude accounting fees (these go to Professional Services)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            accounting_indicators = [
                'comptable', 'expert comptable', 'cabinet comptable',
                'fiduciaire', 'audit', 'accounting', 'tax preparation'
            ]

            if any(indicator in text_to_check for indicator in accounting_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_tax_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_tax_very_frequent(x):
            """Very frequent payments unlikely to be taxes"""
            if x.amt_count > 15 or (x.amt_count > 8 and x.mean_delta_days < 30):
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_tax_government_entities", f=lf_tax_government_entities),
            LabelingFunction(name="lf_tax_keywords_specific", f=lf_tax_keywords_specific),
            LabelingFunction(name="lf_tax_text_anchor", f=lf_tax_text_anchor),
            LabelingFunction(name="lf_tax_substantial_infrequent", f=lf_tax_substantial_infrequent),
            LabelingFunction(name="lf_not_tax_accounting_fees", f=lf_not_tax_accounting_fees),
            LabelingFunction(name="lf_not_tax_positive_amounts", f=lf_not_tax_positive_amounts),
            LabelingFunction(name="lf_not_tax_very_frequent", f=lf_not_tax_very_frequent),
        ]


class AccountingClassifier(CategoryClassifier):
    """Accounting services classifier (accountant fees, tax preparation)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Accounting", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_accounting_thresholds()

        accounting_anchors = [
            "comptable", "accountant", "audit", "expertise", "fiscal",
            "fiduciaire", "cabinet", "declaration"
        ]
        self.setup_anchors(accounting_anchors, similarity_threshold=0.7)

    def _calculate_accounting_thresholds(self) -> dict:
        return {
            'min_amount': -10000,       # Large business accounting
            'max_amount': -50,          # Minimum accounting service
            'consultation_min': -100,   # Minimum consultation
            'monthly_min': -150,        # Monthly accounting services
            'max_frequency': 15,        # Can be monthly or quarterly
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_accounting_naf_codes(x):
            """NAF codes for accounting services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            accounting_naf_codes = [
                "69.20Z",  # Accounting, bookkeeping and auditing
                "69.20A",  # Accounting activities
                "69.20B",  # Auditing activities
                "74.90A",  # Tax consultancy activities
            ]

            if str(x.NAF_CODE).strip() in accounting_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_accounting_keywords_specific(x):
            """Specific accounting keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            accounting_keywords = [
                # Professional titles
                'expert comptable', 'comptable', 'accountant', 'auditeur',
                'commissaire compte', 'fiduciaire', 'cabinet comptable',

                # Services
                'tenue comptabilite', 'bookkeeping', 'audit', 'expertise comptable',
                'declaration fiscale', 'tax preparation', 'bilan comptable',
                'liasse fiscale', 'revision comptable', 'conseil fiscal',

                # Business entities in accounting context
                'cabinet audit', 'bureau comptable', 'societe expertise',
                'conseil comptable', 'services comptables'
            ]

            if any(keyword in text_to_check for keyword in accounting_keywords):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_accounting_text_anchor(x):
            """FastText similarity for accounting"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_accounting_regular_professional(x):
            """Regular accounting services pattern"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or
                x.amt_count < 2):
                return self.ABSTAIN

            # Monthly or quarterly accounting services
            is_substantial = x.amt_mean <= self.thresholds['consultation_min']
            is_regular = x.amt_count >= 3 and x.mean_delta_days <= 120  # Up to quarterly
            is_professional_frequency = x.amt_count <= self.thresholds['max_frequency']

            if is_substantial and is_regular and is_professional_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions
        def lf_not_accounting_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_accounting_tax_payments(x):
            """Exclude direct tax payments (these go to Tax category)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            tax_payment_indicators = [
                'dgfip', 'tresor public', 'centre impots', 'urssaf',
                'impot revenu', 'taxe habitation', 'taxe fonciere'
            ]

            if any(indicator in text_to_check for indicator in tax_payment_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_accounting_naf_codes", f=lf_accounting_naf_codes),
            LabelingFunction(name="lf_accounting_keywords_specific", f=lf_accounting_keywords_specific),
            LabelingFunction(name="lf_accounting_text_anchor", f=lf_accounting_text_anchor),
            LabelingFunction(name="lf_accounting_regular_professional", f=lf_accounting_regular_professional),
            LabelingFunction(name="lf_not_accounting_positive_amounts", f=lf_not_accounting_positive_amounts),
            LabelingFunction(name="lf_not_accounting_tax_payments", f=lf_not_accounting_tax_payments),
        ]


class BankingClassifier(CategoryClassifier):
    """Banking fees classifier (account fees, ATM fees, overdraft charges)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Banking", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_banking_thresholds()

        banking_anchors = [
            "frais", "commission", "agios", "cotisation", "carte",
            "retrait", "virement", "chequier", "banking"
        ]
        self.setup_anchors(banking_anchors, similarity_threshold=0.7)

    def _calculate_banking_thresholds(self) -> dict:
        return {
            'min_amount': -500,         # Large overdraft fees
            'max_amount': -1,           # Small banking fees exist
            'typical_min': -100,        # Typical fee range
            'typical_max': -2,
            'monthly_pattern_days': 30, # Monthly account fees
            'max_cv': 0.8,             # Banking fees can vary
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_banking_major_banks(x):
            """Major banks charging fees"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            major_banks = [
                "BNP PARIBAS", "CREDIT AGRICOLE", "SOCIETE GENERALE", "LCL",
                "CREDIT MUTUEL", "BANQUE POPULAIRE", "CAISSE EPARGNE",
                "LA BANQUE POSTALE", "CIC", "CREDIT COOPERATIF",
                "HSBC", "ING", "BOURSORAMA", "FORTUNEO", "HELLO BANK",
                "MONABANQ", "N26", "REVOLUT", "ORANGE BANK"
            ]

            for bank in major_banks:
                if bank in merchant_text:
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_banking_fees_keywords(x):
            """Banking fees specific keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            banking_fees_keywords = [
                # Account fees
                'frais tenue compte', 'account maintenance', 'cotisation carte',
                'frais bancaire', 'banking fees', 'commission bancaire',

                # Transaction fees
                'frais virement', 'transfer fee', 'frais change', 'exchange fee',
                'frais retrait', 'withdrawal fee', 'frais distributeur',

                # Card fees
                'cotisation cb', 'carte bancaire', 'frais carte', 'card fee',
                'renouvellement carte', 'opposition carte',

                # Overdraft
                'agios', 'overdraft', 'decouvert', 'frais decouvert',
                'commission intervention', 'incident paiement',

                # Other fees
                'frais courrier', 'frais dossier', 'penalite', 'frais rejet',
                'chequier', 'checkbook', 'rib', 'releve compte'
            ]

            if any(keyword in text_to_check for keyword in banking_fees_keywords):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_banking_text_anchor(x):
            """FastText similarity for banking terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_banking_small_regular_fees(x):
            """Small regular banking fees pattern"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount'] or
                x.amt_count < 2):
                return self.ABSTAIN

            # Small, regular fees like monthly account maintenance
            is_small_fee = self.thresholds['typical_max'] <= x.amt_mean <= self.thresholds['typical_min']
            is_regular = x.amt_count >= 3 and x.mean_delta_days <= 35  # Monthly-ish
            has_reasonable_variance = x.amt_cv <= self.thresholds['max_cv']

            if is_small_fee and is_regular and has_reasonable_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_banking_overdraft_fees(x):
            """Overdraft and incident fees"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount']):
                return self.ABSTAIN

            # Overdraft fees are typically larger and irregular
            is_substantial_fee = x.amt_mean <= -20  # Significant overdraft fees
            is_irregular = x.amt_count <= 6  # Not too frequent

            if is_substantial_fee and is_irregular:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions
        def lf_not_banking_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_banking_large_amounts(x):
            """Very large amounts unlikely to be banking fees"""
            if x.amt_mean < -200:  # More than 200€ unlikely to be bank fees
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_banking_major_banks", f=lf_banking_major_banks),
            LabelingFunction(name="lf_banking_fees_keywords", f=lf_banking_fees_keywords),
            LabelingFunction(name="lf_banking_text_anchor", f=lf_banking_text_anchor),
            LabelingFunction(name="lf_banking_small_regular_fees", f=lf_banking_small_regular_fees),
            LabelingFunction(name="lf_banking_overdraft_fees", f=lf_banking_overdraft_fees),
            LabelingFunction(name="lf_not_banking_positive_amounts", f=lf_not_banking_positive_amounts),
            LabelingFunction(name="lf_not_banking_large_amounts", f=lf_not_banking_large_amounts),
        ]


class PostalClassifier(CategoryClassifier):
    """Postal and courier services classifier (mailing, shipping, courier)"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Postal", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_postal_thresholds()

        postal_anchors = [
            "poste", "postal", "courrier", "colis", "envoi",
            "expedition", "shipping", "fedex", "ups", "dhl"
        ]
        self.setup_anchors(postal_anchors, similarity_threshold=0.7)

    def _calculate_postal_thresholds(self) -> dict:
        return {
            'min_amount': -500,         # Large shipping costs for businesses
            'max_amount': -1,           # Even small postage counts
            'typical_min': -100,        # Typical shipping range
            'typical_max': -2,
            'max_frequency': 50,        # Can be quite frequent for businesses
            'express_min': -15,         # Express shipping minimum
        }

    def create_labeling_functions(self) -> List[LabelingFunction]:

        def lf_postal_major_providers(x):
            """Major postal and courier providers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            postal_providers = [
                # National postal services
                "LA POSTE", "POSTE", "POSTAL SERVICE", "COURRIER",

                # International couriers
                "FEDEX", "UPS", "DHL", "TNT", "CHRONOPOST", "COLISSIMO",
                "MONDIAL RELAY", "RELAIS COLIS", "PICKUP",

                # Local and specialized
                "GEODIS", "CALBERSON", "TRANSPORT", "MESSAGERIE",
                "COURSIER", "COURIER", "EXPRESS", "LIVRAISON"
            ]

            for provider in postal_providers:
                if provider in merchant_text:
                    if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_postal_naf_codes(x):
            """NAF codes for postal and courier services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            postal_naf_codes = [
                "53.10Z",  # Postal activities under universal service
                "53.20Z",  # Other postal and courier activities
                "49.41A",  # Freight transport by road
                "49.41B",  # Furniture removal services
                "49.41C",  # Moving services
            ]

            if str(x.NAF_CODE).strip() in postal_naf_codes:
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_postal_keywords_specific(x):
            """Specific postal and shipping keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            postal_keywords = [
                # Basic postal
                'timbre', 'stamp', 'affranchissement', 'postage',
                'lettre recommandee', 'registered mail', 'courrier',

                # Package shipping
                'colis', 'package', 'paquet', 'envoi', 'expedition',
                'shipping', 'livraison', 'delivery', 'transport colis',

                # Express services
                'chronopost', 'express', 'urgent', 'same day',
                'next day', 'overnight', 'rapide',

                # Shipping methods
                'colissimo', 'mondial relay', 'point relais',
                'domicile', 'home delivery', 'pickup point',

                # International
                'international', 'export', 'douane customs',
                'ems', 'fedex', 'ups', 'dhl',

                # Business shipping
                'frais port', 'shipping costs', 'frais envoi',
                'transport marchandise', 'logistics'
            ]

            if any(keyword in text_to_check for keyword in postal_keywords):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_postal_text_anchor(x):
            """FastText similarity for postal terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.7 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_postal_small_frequent_pattern(x):
            """Small frequent postal expenses (regular mailings)"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount']):
                return self.ABSTAIN

            # Small regular postal expenses
            is_small_postal = self.thresholds['typical_max'] <= x.amt_mean <= -10
            is_frequent = x.amt_count >= 5  # Regular mailing
            is_reasonable_frequency = x.amt_count <= self.thresholds['max_frequency']

            if is_small_postal and is_frequent and is_reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_postal_express_shipping(x):
            """Express shipping pattern"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['max_amount']):
                return self.ABSTAIN

            # Express shipping: more expensive, less frequent
            is_express_amount = x.amt_mean <= self.thresholds['express_min']
            is_reasonable_frequency = x.amt_count <= 20  # Not too frequent

            if is_express_amount and is_reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_postal_round_shipping_amounts(x):
            """Round amounts typical of shipping"""
            if x.amt_mean >= 0 or x.amt_mean > self.thresholds['max_amount']:
                return self.ABSTAIN

            amount_abs = abs(int(x.amt_mean))

            # Common shipping amounts
            common_shipping_amounts = [5, 10, 15, 20, 25, 30, 50, 75, 100]
            is_common_shipping_amount = amount_abs in common_shipping_amounts

            # Not too frequent (shipping is typically occasional)
            is_reasonable_frequency = x.amt_count <= 30

            if is_common_shipping_amount and is_reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative functions
        def lf_not_postal_positive_amounts(x):
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_postal_very_large_amounts(x):
            """Very large amounts unlikely to be postal"""
            if x.amt_mean < -300:  # More than 300€ unlikely postal
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_postal_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr',
                'electricite', 'gaz', 'eau'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_postal_major_providers", f=lf_postal_major_providers),
            LabelingFunction(name="lf_postal_naf_codes", f=lf_postal_naf_codes),
            LabelingFunction(name="lf_postal_keywords_specific", f=lf_postal_keywords_specific),
            LabelingFunction(name="lf_postal_text_anchor", f=lf_postal_text_anchor),
            LabelingFunction(name="lf_postal_small_frequent_pattern", f=lf_postal_small_frequent_pattern),
            LabelingFunction(name="lf_postal_express_shipping", f=lf_postal_express_shipping),
            LabelingFunction(name="lf_postal_round_shipping_amounts", f=lf_postal_round_shipping_amounts),
            LabelingFunction(name="lf_not_postal_positive_amounts", f=lf_not_postal_positive_amounts),
            LabelingFunction(name="lf_not_postal_very_large_amounts", f=lf_not_postal_very_large_amounts),
            LabelingFunction(name="lf_not_postal_utilities", f=lf_not_postal_utilities),
        ]


# Usage functions for all administrative classifiers
def create_admin_classifiers(ft_model, merchant_agg_df, user_profile=None):
    """Create and run all administrative classifiers"""

    results = {}

    # Legal
    legal_classifier = LegalClassifier(ft_model, merchant_agg_df, user_profile)
    results['legal'] = legal_classifier.run_full_pipeline(confidence_threshold=0.7)

    # Insurance
    insurance_classifier = InsuranceClassifier(ft_model, merchant_agg_df, user_profile)
    results['insurance'] = insurance_classifier.run_full_pipeline(confidence_threshold=0.7)

    # Tax
    tax_classifier = TaxClassifier(ft_model, merchant_agg_df, user_profile)
    results['tax'] = tax_classifier.run_full_pipeline(confidence_threshold=0.7)

    # Accounting
    accounting_classifier = AccountingClassifier(ft_model, merchant_agg_df, user_profile)
    results['accounting'] = accounting_classifier.run_full_pipeline(confidence_threshold=0.7)

    # Banking
    banking_classifier = BankingClassifier(ft_model, merchant_agg_df, user_profile)
    results['banking'] = banking_classifier.run_full_pipeline(confidence_threshold=0.7)

    # Postal
    postal_classifier = PostalClassifier(ft_model, merchant_agg_df, user_profile)
    results['postal'] = postal_classifier.run_full_pipeline(confidence_threshold=0.7)

    return {
        'classifiers': {
            'legal': legal_classifier,
            'insurance': insurance_classifier,
            'tax': tax_classifier,
            'accounting': accounting_classifier,
            'banking': banking_classifier,
            'postal': postal_classifier
        },
        'results': results
    }


# Example usage:
"""
# Run all administrative classifiers
admin_results = create_admin_classifiers(ft, merchant_agg_df, user_profile)

# Print summary
for category, result in admin_results['results'].items():
    print(f"\n{category.upper()} Results:")
    print(f"- Total predicted: {result['predicted_positive']}")
    print(f"- High confidence: {result['high_confidence_positive']}")

# Export individual results
for category, classifier in admin_results['classifiers'].items():
    excel_file = extract_lf_results_to_excel(
        classifier, merchant_agg_df, f"{category}_lf_detailed_results.xlsx"
    )
    print(f"Exported {category} results to {excel_file}")

# Show high confidence examples for each category
for category, result in admin_results['results'].items():
    if len(result['high_confidence_examples']) > 0:
        print(f"\nHigh confidence {category} examples:")
        display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', f'{category}_confidence']
        print(result['high_confidence_examples'][display_cols].head(5))
"""

"""## Legal

## Insurance

## Tax

## Accounting

## Banking

Fees

Interest

## Postal

# Transport
"""

class TransportClassifier(CategoryClassifier):
    """Transport classifier for fuel, public transport, Uber, car maintenance"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Transport", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_transport_thresholds()

        # Transport-specific anchors
        transport_anchors = [
            "transport", "carburant", "fuel", "essence", "gazole", "diesel",
            "station", "metro", "bus", "train", "taxi", "uber", "parking",
            "peage", "toll", "autoroute", "sncf", "ratp", "navigo",
            "maintenance", "vidange", "pneu", "tire", "garage"
        ]
        self.setup_anchors(transport_anchors, similarity_threshold=0.65)

    def _calculate_transport_thresholds(self) -> dict:
        """Calculate transport-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -500,         # Large fuel tank or major maintenance
            'max_amount': -1,           # Small public transport tickets
            'fuel_min_days': 3,         # Daily to weekly fuel purchases
            'fuel_max_days': 21,
            'public_transport_max_days': 31,  # Monthly passes
            'maintenance_min_days': 90, # Quarterly maintenance
            'min_frequency': 2,         # Pattern recognition needs multiple
            'max_cv': 1.5,             # Reasonable variability for fuel
            'daily_commute_patterns': True
        }

        # Adjust based on user profile and location
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -800,     # Premium fuel, luxury car maintenance
                    'max_amount': -2        # Higher threshold for premium transport
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -300,     # Budget transport options
                    'max_amount': -1        # Small public transport amounts
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create transport-specific labeling functions"""

        def lf_transport_naf_codes(x):
            """NAF codes for transport-related businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            transport_naf_codes = [
                # Fuel stations
                "47.30Z",  # Retail sale of automotive fuel
                "19.20Z",  # Manufacture of refined petroleum products

                # Public transport
                "49.10Z",  # Passenger rail transport, interurban
                "49.31Z",  # Urban and suburban passenger land transport
                "49.32Z",  # Taxi operation
                "49.39A",  # Other passenger land transport
                "49.39B",  # Other passenger land transport n.e.c.
                "50.10Z",  # Sea and coastal passenger water transport
                "51.10Z",  # Passenger air transport

                # Car services and maintenance
                "45.20A",  # Maintenance and repair of motor vehicles
                "45.20B",  # Maintenance and repair of other motor vehicles
                "45.32Z",  # Retail trade of motor vehicle parts and accessories
                "45.40Z",  # Sale, maintenance and repair of motorcycles

                # Parking and tolls
                "52.21Z",  # Service activities incidental to land transportation
                "52.22Z",  # Service activities incidental to water transportation
                "52.23Z",  # Service activities incidental to air transportation

                # Car rental
                "77.11Z",  # Rental and leasing of cars and light motor vehicles
                "77.12Z",  # Rental and leasing of trucks
            ]

            if str(x.NAF_CODE).strip() in transport_naf_codes:
                if (x.amt_mean < 0 and
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_transport_fuel_stations_high_confidence(x):
            """HIGH CONFIDENCE: Major fuel station chains"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Major fuel station chains - almost exclusively fuel
            major_fuel_stations = [
                # French/European chains
                "TOTAL", "TOTAL ENERGIES", "BP", "SHELL", "ESSO", "EXXON",
                "AGIP", "ENI", "AVIA", "LECLERC CARBURANT", "CARREFOUR STATION",
                "INTERMARCHE STATION", "SUPER U CARBURANT", "CASINO CARBURANT",

                # International chains
                "CHEVRON", "TEXACO", "MOBIL", "PHILLIPS 66", "VALERO",
                "CIRCLE K", "SPEEDWAY", "WAWA", "SHEETZ",

                # Highway/Autoroute stations
                "AUTOROUTE", "AIRE", "STATION SERVICE", "RELAIS",
                "VINCI AUTOROUTES", "APRR", "ASF"
            ]

            # For fuel stations, very relaxed criteria
            for station in major_fuel_stations:
                if station in merchant_text:
                    # Fuel purchases: reasonable amounts and any frequency
                    if (x.amt_mean < 0 and
                        -200 <= x.amt_mean <= -5):  # Reasonable fuel range
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_public_transport_operators(x):
            """Public transport operators and services"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Public transport operators
            public_transport_operators = [
                # French national/regional
                "SNCF", "SNCF CONNECT", "OUIGO", "TGV", "TER", "INTERCITES",
                "RATP", "NAVIGO", "METRO", "RER", "TRAMWAY", "VELIB",

                # Regional French transport
                "TCL", "TAN", "KEOLIS", "TRANSDEV", "TISSÉO", "TAG",
                "TBC", "STAN", "TEC", "CTS", "STAR", "SEMITAN",

                # International
                "DEUTSCHE BAHN", "TRENITALIA", "RENFE", "EUROSTAR",
                "FLIXBUS", "OUIBUS", "BLABLACAR BUS", "ISILINES",

                # Airlines (for transport classification)
                "AIR FRANCE", "EASYJET", "RYANAIR", "LUFTHANSA",
                "KLM", "BRITISH AIRWAYS", "VUELING", "TRANSAVIA",

                # Urban transport
                "CITY MAPPER", "UBER", "LYFT", "BOLT", "FREE NOW",
                "LIME", "BIRD", "TIER", "VOI"
            ]

            for operator in public_transport_operators:
                if operator in merchant_text:
                    # Public transport: small to medium amounts
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_parking_tolls(x):
            """Parking and toll payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            parking_toll_keywords = [
                # Parking
                'parking', 'stationnement', 'garage', 'park', 'vinci park',
                'effia', 'indigo', 'q park', 'apcoa', 'parkimeter',
                'horodateur', 'metre', 'place', 'zone bleue',

                # Tolls
                'peage', 'toll', 'autoroute', 'highway', 'vinci autoroutes',
                'aprr', 'asf', 'sanef', 'area', 'escota', 'cofiroute',
                'telepeage', 'badge', 'liber t', 'bip go'
            ]

            if any(keyword in text_to_check for keyword in parking_toll_keywords):
                # Parking/tolls: small to medium amounts
                if (x.amt_mean < 0 and
                    -100 <= x.amt_mean <= -1 and  # Reasonable parking/toll range
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_comprehensive_keywords(x):
            """Comprehensive transport keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_keywords = {
                # Fuel
                'fuel': ['carburant', 'fuel', 'essence', 'gazole', 'diesel', 'gasoil',
                        'super', 'premium', 'e10', 'e85', 'gpl', 'station service',
                        'pompe', 'distributeur', 'plein', 'litre'],

                # Public transport
                'public': ['transport', 'metro', 'bus', 'tramway', 'train', 'rer',
                          'ticket', 'abonnement', 'passe', 'navigo', 'carte', 'forfait',
                          'ligne', 'station', 'arret', 'correspondance', 'terminus'],

                # Ride sharing / Taxi
                'ride': ['taxi', 'uber', 'lyft', 'bolt', 'kapten', 'free now',
                        'chauffeur', 'vtc', 'course', 'trajet', 'ride', 'transport prive'],

                # Car maintenance
                'maintenance': ['maintenance', 'entretien', 'vidange', 'revision',
                               'controle technique', 'pneu', 'tire', 'pneus', 'garage',
                               'mecanique', 'reparation', 'piece', 'huile', 'filtre',
                               'plaquette', 'frein', 'brake', 'batterie', 'amortisseur'],

                # Parking and tolls
                'parking_tolls': ['parking', 'stationnement', 'peage', 'toll',
                                 'autoroute', 'aire', 'sortie', 'barriere', 'ticket',
                                 'horodateur', 'zone', 'place', 'emplacement'],

                # Vehicle related
                'vehicle': ['voiture', 'car', 'auto', 'vehicule', 'automobile',
                           'moto', 'motorcycle', 'scooter', 'velo', 'bike', 'bicycle',
                           'trottinette', 'scooter electrique', 'mobilite']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in transport_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Strong signal requirements
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'fuel' in category_matches or  # Fuel is strong signal
                'public' in category_matches or  # Public transport
                'ride' in category_matches or  # Ride sharing
                category_matches.get('maintenance', 0) >= 1  # Car maintenance
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_text_anchor(x):
            """FastText similarity for transport terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean >= self.thresholds['min_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_frequent_fuel_pattern(x):
            """Frequent fuel purchase patterns"""
            if x.amt_mean >= 0 or x.amt_count < 4:
                return self.ABSTAIN

            # Regular fuel purchases (daily to weekly)
            is_frequent_fuel = (
                self.thresholds['fuel_min_days'] <= x.mean_delta_days <= self.thresholds['fuel_max_days'] and
                -150 <= x.amt_mean <= -20 and  # Typical fuel range
                x.amt_cv <= self.thresholds['max_cv']  # Some variability expected
            )

            if is_frequent_fuel:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_commute_pattern(x):
            """Daily/weekly commute patterns"""
            if x.amt_mean >= 0 or x.amt_count < 8:
                return self.ABSTAIN

            # Very frequent small amounts (daily commuting)
            is_daily_commute = (
                x.mean_delta_days <= 7 and  # Weekly or more frequent
                -50 <= x.amt_mean <= -2 and  # Small public transport amounts
                x.amt_count >= 10  # Frequent pattern
            )

            if is_daily_commute:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_monthly_pass_pattern(x):
            """Monthly transport pass patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Monthly transport passes
            is_monthly_pass = (
                25 <= x.mean_delta_days <= 35 and  # Monthly pattern
                -200 <= x.amt_mean <= -30 and  # Monthly pass range
                x.amt_cv <= 0.3  # Very consistent amounts
            )

            if is_monthly_pass:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_maintenance_pattern(x):
            """Car maintenance patterns"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Periodic maintenance (quarterly to yearly)
            is_maintenance = (
                x.mean_delta_days >= self.thresholds['maintenance_min_days'] and
                -400 <= x.amt_mean <= -50 and  # Maintenance cost range
                x.amt_cv <= 1.0  # Some variability allowed
            )

            if is_maintenance:
                # Check for maintenance context
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                maintenance_hints = [
                    'garage', 'maintenance', 'vidange', 'pneu', 'revision',
                    'controle', 'mecanique', 'auto', 'service'
                ]

                if any(hint in text_to_check for hint in maintenance_hints):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_transport_ride_sharing_pattern(x):
            """Ride sharing and taxi patterns"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_lower = str(x.MERCHANT).lower()

            # Ride sharing services
            ride_services = ['uber', 'lyft', 'bolt', 'kapten', 'free now', 'taxi']

            has_ride_service = any(service in merchant_lower for service in ride_services)

            if has_ride_service:
                # Occasional ride sharing: reasonable amounts
                if (x.amt_mean < 0 and
                    -100 <= x.amt_mean <= -3 and  # Ride cost range
                    x.amt_count >= 1):
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_transport_groceries_food(x):
            """Exclude grocery and food transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            food_indicators = [
                'supermarche', 'hypermarche', 'alimentaire', 'epicerie',
                'restaurant', 'cafe', 'boulangerie', 'fast food', 'delivery',
                'courses', 'nourriture', 'repas'
            ]

            if any(indicator in text_to_check for indicator in food_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_transport_utilities_bills(x):
            """Exclude utility bills"""
            if (x.amt_count >= 6 and
                25 <= x.mean_delta_days <= 35 and  # Monthly
                x.amt_cv <= 0.2 and  # Very consistent
                -200 <= x.amt_mean <= -30):  # Utility-like amounts

                # Unless it's clearly transport subscription
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                transport_subs = ['navigo', 'pass', 'abonnement', 'transport', 'metro']
                is_transport_sub = any(sub in text_to_check for sub in transport_subs)

                if not is_transport_sub:
                    return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_transport_household_shopping(x):
            """Exclude household and fashion shopping"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            shopping_indicators = [
                'zara', 'h&m', 'ikea', 'amazon', 'fnac', 'darty',
                'vetement', 'mode', 'fashion', 'beaute', 'cosmetique',
                'meuble', 'decoration', 'livre', 'book'
            ]

            if any(indicator in text_to_check for indicator in shopping_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_transport_entertainment(x):
            """Exclude entertainment and leisure"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            entertainment_indicators = [
                'cinema', 'theatre', 'concert', 'spectacle', 'netflix',
                'spotify', 'gaming', 'sport', 'loisir', 'vacances'
            ]

            if any(indicator in text_to_check for indicator in entertainment_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_transport_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_transport_very_large_amounts(x):
            """Very large amounts (likely car purchase, not transport expense)"""
            if x.amt_mean < -1000:  # More than 1000 EUR (likely car purchase)
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_transport_very_small_frequent_groceries(x):
            """Very small frequent amounts that look like groceries"""
            if (x.amt_count > 15 and  # Very frequent
                x.mean_delta_days < 5 and  # More than twice weekly
                -20 <= x.amt_mean <= -2):  # Very small amounts

                # Unless clearly transport related
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                transport_hints = ['metro', 'bus', 'transport', 'ticket', 'navigo']
                is_transport = any(hint in text_to_check for hint in transport_hints)

                if not is_transport:
                    return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_transport_naf_codes", f=lf_transport_naf_codes),
            LabelingFunction(name="lf_transport_fuel_stations_high_confidence", f=lf_transport_fuel_stations_high_confidence),
            LabelingFunction(name="lf_transport_public_transport_operators", f=lf_transport_public_transport_operators),
            LabelingFunction(name="lf_transport_parking_tolls", f=lf_transport_parking_tolls),
            LabelingFunction(name="lf_transport_comprehensive_keywords", f=lf_transport_comprehensive_keywords),
            LabelingFunction(name="lf_transport_text_anchor", f=lf_transport_text_anchor),
            LabelingFunction(name="lf_transport_frequent_fuel_pattern", f=lf_transport_frequent_fuel_pattern),
            LabelingFunction(name="lf_transport_commute_pattern", f=lf_transport_commute_pattern),
            LabelingFunction(name="lf_transport_monthly_pass_pattern", f=lf_transport_monthly_pass_pattern),
            LabelingFunction(name="lf_transport_maintenance_pattern", f=lf_transport_maintenance_pattern),
            LabelingFunction(name="lf_transport_ride_sharing_pattern", f=lf_transport_ride_sharing_pattern),
            LabelingFunction(name="lf_not_transport_groceries_food", f=lf_not_transport_groceries_food),
            LabelingFunction(name="lf_not_transport_utilities_bills", f=lf_not_transport_utilities_bills),
            LabelingFunction(name="lf_not_transport_household_shopping", f=lf_not_transport_household_shopping),
            LabelingFunction(name="lf_not_transport_entertainment", f=lf_not_transport_entertainment),
            LabelingFunction(name="lf_not_transport_positive_amounts", f=lf_not_transport_positive_amounts),
            LabelingFunction(name="lf_not_transport_very_large_amounts", f=lf_not_transport_very_large_amounts),
            LabelingFunction(name="lf_not_transport_very_small_frequent_groceries", f=lf_not_transport_very_small_frequent_groceries),
        ]


# Usage function
def create_transport_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run transport classifier"""

    # Create classifier instance
    classifier = TransportClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
transport_classifier = TransportClassifier(ft, merchant_agg_df, user_profile)
transport_results = transport_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
transport_excel = extract_lf_results_to_excel(
    transport_classifier, merchant_agg_df, "transport_lf_detailed_results.xlsx"
)

print(f"Transport Results:")
print(f"- Total predicted: {transport_results['predicted_positive']}")
print(f"- High confidence: {transport_results['high_confidence_positive']}")
"""

transport_classifier = TransportClassifier(ft, merchant_agg_df, user_profile)
transport_results = transport_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
transport_excel = extract_lf_results_to_excel(
    transport_classifier, merchant_agg_df, "transport_lf_detailed_results.xlsx"
)

print(f"Transport Results:")
print(f"- Total predicted: {transport_results['predicted_positive']}")
print(f"- High confidence: {transport_results['high_confidence_positive']}")

"""# Health"""

class HealthClassifier(CategoryClassifier):
    """Enhanced health classifier for medical expenses, pharmacy, and health supplements"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Health", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_health_thresholds()

        # Health-specific anchors covering medical services and products
        health_anchors = [
            # Medical professionals
            "medecin", "docteur", "pharmacie", "dentiste", "kinesitherapeute",
            # Health services
            "hopital", "clinique", "laboratoire", "radiologie", "medical",
            # Health products
            "medicament", "supplement", "vitamines", "parapharmacie",
            # Specialties
            "ophtalmologie", "cardiologie", "dermatologie", "orthopede"
        ]
        self.setup_anchors(health_anchors, similarity_threshold=0.6)

    def _calculate_health_thresholds(self) -> dict:
        """Calculate health-specific thresholds for different medical expense patterns"""
        base_thresholds = {
            # Pharmacy purchases (frequent, smaller amounts)
            'pharmacy_min_amount': -200,       # Maximum pharmacy purchase
            'pharmacy_max_amount': -3,         # Minimum pharmacy purchase

            # Doctor visits (less frequent, moderate amounts)
            'doctor_min_amount': -300,         # Maximum doctor visit
            'doctor_max_amount': -20,          # Minimum doctor visit

            # Specialist/hospital (infrequent, larger amounts)
            'specialist_min_amount': -2000,    # Maximum specialist/hospital
            'specialist_max_amount': -50,      # Minimum specialist fee

            # Insurance reimbursements (negative expenses = positive amounts)
            'reimbursement_min': 5,            # Minimum reimbursement
            'reimbursement_max': 500,          # Maximum typical reimbursement

            # Patterns
            'min_frequency': 2,                # Minimum transactions
            'max_cv_regular': 1.5,            # For regular medical expenses
            'max_cv_irregular': 3.0,          # For irregular medical expenses
            'pharmacy_max_days': 45,           # Maximum days between pharmacy visits
            'doctor_max_days': 120,            # Maximum days between doctor visits
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'doctor_min_amount': -500,      # Private healthcare
                    'specialist_min_amount': -3000,
                    'pharmacy_min_amount': -300
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'doctor_min_amount': -150,      # Public healthcare
                    'specialist_min_amount': -800,
                    'pharmacy_min_amount': -100
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create comprehensive health-specific labeling functions"""

        def lf_health_naf_codes(x):
            """NAF codes for healthcare and medical services"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Healthcare-related NAF codes
            health_naf_codes = [
                "86.10Z",  # Hospital activities
                "86.21Z",  # General medical practice
                "86.22A",  # Specialist medical practice - activities
                "86.22C",  # Specialist medical practice - other
                "86.23Z",  # Dental practice
                "86.90A",  # Ambulance services
                "86.90B",  # Medical laboratory activities
                "86.90C",  # Ambulatory health care services
                "86.90D",  # Blood collection activities
                "86.90E",  # Paramedical activities
                "86.90F",  # Medical imaging activities
                "47.73Z",  # Dispensing chemist in specialized stores (pharmacy)
                "47.74Z",  # Medical goods retail
                "32.50A",  # Medical equipment manufacturing
                "32.50B",  # Optical instruments manufacturing
                "87.10A",  # Residential nursing care for elderly
                "87.10B",  # Residential nursing care for disabled
                "87.20A",  # Residential care for mental health
                "87.30A",  # Residential care for elderly
                "87.90A",  # Home health care services
                "87.90B",  # Other residential care activities
                "88.10A",  # Home health care services for elderly
                "88.10B",  # Home health care services for disabled
                "88.91A",  # Child care services
                "88.99A",  # Other social work without accommodation
                "96.09Z",  # Other personal service activities (wellness)
            ]

            if str(x.NAF_CODE).strip() in health_naf_codes:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_health_pharmacies(x):
            """Detect pharmacy transactions"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().lower()

            # Pharmacy indicators
            pharmacy_indicators = [
                'pharmacie', 'pharmacy', 'apotheek', 'apotheke',
                'parapharmacie', 'para-pharmacie',
                'pharmacia', 'farmacia', 'farmacie'
            ]

            # Major pharmacy chains
            pharmacy_chains = [
                'pharmaprix', 'jean coutu', 'uniprix', 'familiprix',
                'boots', 'walgreens', 'cvs', 'rite aid',
                'lloyds pharmacy', 'superdrug', 'well pharmacy',
                'pharmavie', 'pharmasimple', 'newpharma',
                'pharmashopdiscount', '1001pharmacies'
            ]

            # Check for pharmacy indicators
            has_pharmacy = any(indicator in merchant_text for indicator in pharmacy_indicators)
            has_chain = any(chain in merchant_text for chain in pharmacy_chains)

            if has_pharmacy or has_chain:
                # Check amount range for pharmacy purchases
                if (x.amt_mean < 0 and
                    self.thresholds['pharmacy_min_amount'] <= x.amt_mean <= self.thresholds['pharmacy_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_health_medical_professionals(x):
            """Detect payments to medical professionals"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Medical professional keywords
            medical_professionals = [
                # General
                'medecin', 'docteur', 'dr ', 'cabinet medical', 'centre medical',

                # Specialists
                'dentiste', 'orthodontiste', 'chirurgien', 'dermatologue',
                'cardiologue', 'neurologue', 'psychiatre', 'psychologue',
                'gynecologie', 'pediatre', 'ophtalmologue', 'orl',
                'radiologue', 'anesthesiste', 'urgentiste', 'generaliste',

                # Allied health
                'kinesitherapeute', 'kine', 'physiotherapeute', 'osteopathe',
                'chiropracteur', 'podologue', 'orthoptiste', 'dieteticien',
                'sage-femme', 'infirmier', 'ergotherapeute',

                # Facilities
                'hopital', 'clinique', 'centre hospitalier', 'chu',
                'dispensaire', 'maison medicale', 'polyclinique'
            ]

            matches = sum(1 for prof in medical_professionals if prof in text_to_check)

            if matches >= 1:
                # Check amount range for medical visits
                if (x.amt_mean < 0 and
                    self.thresholds['doctor_min_amount'] <= x.amt_mean <= self.thresholds['doctor_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_health_medical_keywords(x):
            """Detect health-related keywords in transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Health-related keywords
            health_keywords = [
                # Medical services
                'consultation', 'visite medicale', 'examen medical',
                'analyses', 'laboratoire', 'radiographie', 'scanner',
                'echographie', 'irm', 'prise de sang', 'bilan',

                # Medical products
                'medicament', 'ordonnance', 'prescription', 'traitement',
                'supplement', 'vitamines', 'homeopathie', 'parapharmacie',
                'materiel medical', 'orthese', 'prothese',

                # Health insurance
                'mutuelle', 'complementaire sante', 'assurance maladie',
                'remboursement', 'tiers payant', 'carte vitale',

                # Wellness
                'bien-etre', 'sante', 'medical', 'therapeutic',
                'prevention', 'depistage', 'vaccination'
            ]

            matches = sum(1 for keyword in health_keywords if keyword in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_health_text_anchor(x):
            """FastText similarity with health anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require good similarity and expense pattern
            if similarity >= 0.6 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_health_pharmacy_pattern(x):
            """Detect regular pharmacy purchasing patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Pharmacy amount range
            is_pharmacy_amount = (self.thresholds['pharmacy_min_amount'] <=
                                x.amt_mean <=
                                self.thresholds['pharmacy_max_amount'])

            # Regular but not too frequent (monthly to bi-monthly)
            is_reasonable_frequency = (7 <= x.mean_delta_days <= self.thresholds['pharmacy_max_days'])

            # Moderate consistency (pharmacy purchases can vary)
            is_reasonably_consistent = x.amt_cv <= self.thresholds['max_cv_regular']

            if is_pharmacy_amount and is_reasonable_frequency and is_reasonably_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_health_doctor_visit_pattern(x):
            """Detect doctor visit patterns - less frequent, moderate amounts"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Doctor visit amount range
            is_doctor_amount = (self.thresholds['doctor_min_amount'] <=
                              x.amt_mean <=
                              self.thresholds['doctor_max_amount'])

            # Less frequent visits (monthly to quarterly)
            is_doctor_frequency = (30 <= x.mean_delta_days <= self.thresholds['doctor_max_days'])

            # Can be variable (different types of visits)
            is_reasonable_variance = x.amt_cv <= self.thresholds['max_cv_irregular']

            if is_doctor_amount and is_doctor_frequency and is_reasonable_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_health_specialist_pattern(x):
            """Detect specialist/hospital payments - larger, infrequent"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Specialist amount range (larger amounts)
            is_specialist_amount = (self.thresholds['specialist_min_amount'] <=
                                  x.amt_mean <=
                                  self.thresholds['specialist_max_amount'])

            # Can be very infrequent or one-off
            is_specialist_pattern = (x.amt_count <= 5 or x.mean_delta_days >= 60)

            if is_specialist_amount and is_specialist_pattern:
                # Additional check: should have health context
                has_health_context = False
                if not pd.isna(x.MERCHANT):
                    merchant_lower = str(x.MERCHANT).lower()
                    health_contexts = ['medical', 'clinique', 'hopital', 'centre', 'dr', 'docteur']
                    has_health_context = any(context in merchant_lower for context in health_contexts)

                if has_health_context:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_health_insurance_reimbursements(x):
            """Detect health insurance reimbursements (positive amounts)"""
            if x.amt_mean <= 0:  # Looking for positive amounts (reimbursements)
                return self.ABSTAIN

            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Insurance reimbursement indicators
            reimbursement_indicators = [
                'cpam', 'secu', 'securite sociale', 'assurance maladie',
                'mutuelle', 'complementaire sante', 'remboursement',
                'remb', 'rembours', 'tiers payant', 'carte vitale',
                'mgen', 'maaf', 'macif', 'harmonie', 'malakoff'
            ]

            has_insurance = any(indicator in text_to_check for indicator in reimbursement_indicators)

            if has_insurance:
                # Check reasonable reimbursement amount
                if (self.thresholds['reimbursement_min'] <=
                    x.amt_mean <=
                    self.thresholds['reimbursement_max']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_health_round_medical_amounts(x):
            """Detect common medical consultation amounts"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Common medical consultation amounts in France
            amount_abs = abs(int(x.amt_mean))
            common_medical_amounts = [
                23, 25, 28, 30, 46, 50, 55, 60, 70, 80, 90, 100,  # Consultation fees
                16, 17, 20, 22, 24, 26, 27, 35, 40, 45            # Pharmacy amounts
            ]

            is_common_amount = amount_abs in common_medical_amounts
            is_reasonably_consistent = x.amt_cv <= 0.5  # Medical fees are often standardized

            if is_common_amount and is_reasonably_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_health_positive_income(x):
            """Large positive amounts are likely salary/income, not health reimbursements"""
            if x.amt_mean > self.thresholds['reimbursement_max']:  # Too large for reimbursement
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_health_groceries(x):
            """Exclude grocery transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_health_restaurants(x):
            """Exclude restaurant transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'boulangerie', 'patisserie', 'fast food',
                'mcdo', 'mcdonald', 'kfc', 'quick', 'subway'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_health_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez', 'electricite', 'gaz', 'eau', 'internet'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_health_sports(x):
            """Exclude sports/fitness expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            sports_indicators = [
                'fitness', 'gym', 'sport', 'decathlon', 'intersport',
                'nike', 'adidas', 'basic fit', 'keep cool'
            ]

            if any(indicator in text_to_check for indicator in sports_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_health_very_small_frequent(x):
            """Very small frequent transactions unlikely to be health"""
            if (x.amt_mean > -5 and  # Very small amounts
                x.amt_count > 15 and  # Very frequent
                x.mean_delta_days < 7):  # More than weekly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_health_very_large_negative(x):
            """Very large expenses unlikely to be health (except major surgery)"""
            if x.amt_mean < -5000:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_health_beauty_wellness_ambiguous(x):
            """Exclude beauty/wellness that might be confused with health"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Beauty/wellness without clear medical context
            beauty_indicators = ['coiffeur', 'esthetique', 'beaute', 'spa', 'massage']
            medical_context = ['medical', 'therapeutique', 'kine', 'docteur', 'clinique']

            has_beauty = any(indicator in text_to_check for indicator in beauty_indicators)
            has_medical_context = any(context in text_to_check for context in medical_context)

            if has_beauty and not has_medical_context:
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            # Positive labeling functions
            LabelingFunction(name="lf_health_naf_codes", f=lf_health_naf_codes),
            LabelingFunction(name="lf_health_pharmacies", f=lf_health_pharmacies),
            LabelingFunction(name="lf_health_medical_professionals", f=lf_health_medical_professionals),
            LabelingFunction(name="lf_health_medical_keywords", f=lf_health_medical_keywords),
            LabelingFunction(name="lf_health_text_anchor", f=lf_health_text_anchor),
            LabelingFunction(name="lf_health_pharmacy_pattern", f=lf_health_pharmacy_pattern),
            LabelingFunction(name="lf_health_doctor_visit_pattern", f=lf_health_doctor_visit_pattern),
            LabelingFunction(name="lf_health_specialist_pattern", f=lf_health_specialist_pattern),
            LabelingFunction(name="lf_health_insurance_reimbursements", f=lf_health_insurance_reimbursements),
            LabelingFunction(name="lf_health_round_medical_amounts", f=lf_health_round_medical_amounts),

            # Negative labeling functions
            LabelingFunction(name="lf_not_health_positive_income", f=lf_not_health_positive_income),
            LabelingFunction(name="lf_not_health_groceries", f=lf_not_health_groceries),
            LabelingFunction(name="lf_not_health_restaurants", f=lf_not_health_restaurants),
            LabelingFunction(name="lf_not_health_utilities", f=lf_not_health_utilities),
            LabelingFunction(name="lf_not_health_sports", f=lf_not_health_sports),
            LabelingFunction(name="lf_not_health_very_small_frequent", f=lf_not_health_very_small_frequent),
            LabelingFunction(name="lf_not_health_very_large_negative", f=lf_not_health_very_large_negative),
            LabelingFunction(name="lf_not_health_beauty_wellness_ambiguous", f=lf_not_health_beauty_wellness_ambiguous),
        ]


# Usage functions
def create_health_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run health classifier"""

    # Create classifier instance
    classifier = HealthClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Create health classifier
health_classifier = HealthClassifier(ft, merchant_agg_df, user_profile)
health_results = health_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
health_excel = extract_lf_results_to_excel(
    health_classifier, merchant_agg_df, "health_lf_detailed_results.xlsx"
)

print(f"Health Results:")
print(f"- Total predicted: {health_results['predicted_positive']}")
print(f"- High confidence: {health_results['high_confidence_positive']}")

# Analyze patterns by type
pharmacy_examples = health_results['high_confidence_examples'][
    health_results['high_confidence_examples']['amt_mean'] > -50  # Likely pharmacy
]
doctor_examples = health_results['high_confidence_examples'][
    (health_results['high_confidence_examples']['amt_mean'] <= -50) &
    (health_results['high_confidence_examples']['amt_mean'] > -200)  # Likely doctor visits
]

print(f"\nPharmacy transactions: {len(pharmacy_examples)}")
print(f"Doctor visit transactions: {len(doctor_examples)}")
"""

# Create health classifier
health_classifier = HealthClassifier(ft, merchant_agg_df, user_profile)
health_results = health_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
health_excel = extract_lf_results_to_excel(
    health_classifier, merchant_agg_df, "health_lf_detailed_results.xlsx"
)

print(f"Health Results:")
print(f"- Total predicted: {health_results['predicted_positive']}")
print(f"- High confidence: {health_results['high_confidence_positive']}")

# Analyze patterns by type
pharmacy_examples = health_results['high_confidence_examples'][
    health_results['high_confidence_examples']['amt_mean'] > -50  # Likely pharmacy
]
doctor_examples = health_results['high_confidence_examples'][
    (health_results['high_confidence_examples']['amt_mean'] <= -50) &
    (health_results['high_confidence_examples']['amt_mean'] > -200)  # Likely doctor visits
]

print(f"\nPharmacy transactions: {len(pharmacy_examples)}")
print(f"Doctor visit transactions: {len(doctor_examples)}")

"""# Social"""

class EntertainmentClassifier(CategoryClassifier):
    """Enhanced entertainment classifier for social, cultural, and recreational expenses"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Entertainment", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_entertainment_thresholds()

        # Diverse entertainment anchors covering all recreational activities
        entertainment_anchors = [
            # Dining & Social
            "restaurant", "bar", "cafe", "brasserie", "bistrot",
            # Cultural
            "cinema", "theatre", "musee", "concert", "spectacle",
            # Gaming & Digital
            "gaming", "jeux", "video", "steam", "playstation", "xbox",
            # Hobbies
            "loisirs", "hobby", "livre", "musique", "artisanat",
            # Recreation
            "parc", "zoo", "aquarium", "bowling", "karting", "escape"
        ]
        self.setup_anchors(entertainment_anchors, similarity_threshold=0.6)

    def _calculate_entertainment_thresholds(self) -> dict:
        """Calculate entertainment-specific thresholds for different activity patterns"""
        base_thresholds = {
            # Restaurant/Dining (frequent, variable amounts)
            'dining_min_amount': -300,         # Maximum restaurant bill
            'dining_max_amount': -8,           # Minimum meal cost

            # Bars/Drinks (frequent, smaller amounts)
            'bar_min_amount': -150,            # Maximum bar expense
            'bar_max_amount': -5,              # Minimum drink cost

            # Cultural events (less frequent, moderate amounts)
            'cultural_min_amount': -200,       # Maximum ticket/event cost
            'cultural_max_amount': -10,        # Minimum cultural activity

            # Gaming/Digital (varied frequency, specific amounts)
            'gaming_min_amount': -100,         # Maximum game/subscription
            'gaming_max_amount': -3,           # Minimum digital purchase

            # Hobbies/Equipment (sporadic, variable amounts)
            'hobby_min_amount': -500,          # Maximum hobby expense
            'hobby_max_amount': -10,           # Minimum hobby purchase

            # Recreational memberships (monthly patterns)
            'membership_min_amount': -100,     # Maximum monthly membership
            'membership_max_amount': -5,       # Minimum membership fee

            # Patterns
            'min_frequency': 2,                # Minimum transactions
            'max_cv_regular': 1.8,            # For regular entertainment
            'max_cv_irregular': 3.0,          # For irregular entertainment
            'dining_max_days': 14,             # Maximum days between dining
            'bar_max_days': 21,                # Maximum days between bar visits
            'cultural_max_days': 90,           # Cultural events can be occasional
            'membership_monthly_min': 25,      # Monthly membership pattern
            'membership_monthly_max': 35,
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'dining_min_amount': -500,      # Fine dining
                    'cultural_min_amount': -300,    # Premium events
                    'hobby_min_amount': -1000,      # Expensive hobbies
                    'membership_min_amount': -200   # Premium memberships
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'dining_min_amount': -100,      # Budget dining
                    'cultural_min_amount': -50,     # Budget entertainment
                    'hobby_min_amount': -200,       # Budget hobbies
                    'membership_min_amount': -30    # Budget memberships
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create comprehensive entertainment-specific labeling functions"""

        def lf_entertainment_naf_codes(x):
            """NAF codes for entertainment and recreational businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Entertainment-related NAF codes
            entertainment_naf_codes = [
                # Food & Beverage
                "56.10A",  # Traditional restaurants
                "56.10B",  # Fast food restaurants
                "56.10C",  # Event catering
                "56.21Z",  # Event catering services
                "56.30Z",  # Beverage serving activities (bars, cafes)

                # Arts & Culture
                "90.01Z",  # Performing arts
                "90.02Z",  # Support activities to performing arts
                "90.03A",  # Artistic creation
                "90.03B",  # Other artistic creation
                "90.04Z",  # Operation of arts facilities
                "91.01Z",  # Library activities
                "91.02Z",  # Museum activities
                "91.03Z",  # Operation of historical sites
                "91.04Z",  # Botanical and zoological gardens

                # Entertainment & Recreation
                "92.00Z",  # Gambling and betting activities
                "93.11Z",  # Operation of sports facilities
                "93.12Z",  # Activities of sports clubs
                "93.13Z",  # Fitness facilities
                "93.19Z",  # Other sports activities
                "93.21Z",  # Activities of amusement parks
                "93.29Z",  # Other amusement and recreation

                # Retail for entertainment
                "47.61Z",  # Books retail
                "47.62Z",  # Newspapers and stationery retail
                "47.63Z",  # Music and video recordings retail
                "47.65Z",  # Games and toys retail

                # Digital entertainment
                "58.21Z",  # Computer games publishing
                "62.01Z",  # Computer programming
                "63.12Z",  # Web portals
            ]

            if str(x.NAF_CODE).strip() in entertainment_naf_codes:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_entertainment_restaurants(x):
            """Detect restaurant and dining transactions"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().lower()

            # Restaurant indicators
            restaurant_indicators = [
                'restaurant', 'resto', 'brasserie', 'bistrot', 'pizzeria',
                'creperie', 'boulangerie', 'patisserie', 'traiteur',
                'fast food', 'fastfood', 'snack', 'sandwich',
                'sushi', 'kebab', 'tacos', 'burger', 'grill'
            ]

            # Major restaurant chains
            restaurant_chains = [
                'mcdonald', 'mcdo', 'burger king', 'kfc', 'quick', 'subway',
                'pizza hut', 'domino', 'papa john', 'five guys',
                'starbucks', 'costa coffee', 'paul', 'brioche doree',
                'hippopotamus', 'buffalo grill', 'courtepaille',
                'flunch', 'la criee', 'leon de bruxelles'
            ]

            has_restaurant = any(indicator in merchant_text for indicator in restaurant_indicators)
            has_chain = any(chain in merchant_text for chain in restaurant_chains)

            if has_restaurant or has_chain:
                # Check amount range for dining
                if (x.amt_mean < 0 and
                    self.thresholds['dining_min_amount'] <= x.amt_mean <= self.thresholds['dining_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_bars_cafes(x):
            """Detect bars, cafes, and drinking establishments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Bar and cafe indicators
            bar_cafe_indicators = [
                'bar', 'cafe', 'pub', 'taverne', 'brasserie',
                'wine bar', 'cocktail', 'lounge', 'club',
                'discothèque', 'discotheque', 'nightclub',
                'biere', 'beer', 'vin', 'wine', 'alcool'
            ]

            matches = sum(1 for indicator in bar_cafe_indicators if indicator in text_to_check)

            if matches >= 1:
                # Check amount range for bars
                if (x.amt_mean < 0 and
                    self.thresholds['bar_min_amount'] <= x.amt_mean <= self.thresholds['bar_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_cultural_venues(x):
            """Detect cultural and artistic venues"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Cultural venue indicators
            cultural_indicators = [
                # Venues
                'cinema', 'theatre', 'opera', 'musee', 'galerie',
                'exposition', 'concert', 'spectacle', 'festival',
                'philharmonie', 'auditorium', 'salle de concert',

                # Specific venues
                'louvre', 'orsay', 'pompidou', 'palais garnier',
                'chatelet', 'olympia', 'zenith', 'bercy',

                # Activities
                'billet', 'ticket', 'place', 'reservation',
                'entree', 'visite', 'exposition temporaire'
            ]

            matches = sum(1 for indicator in cultural_indicators if indicator in text_to_check)

            if matches >= 1:
                # Check amount range for cultural activities
                if (x.amt_mean < 0 and
                    self.thresholds['cultural_min_amount'] <= x.amt_mean <= self.thresholds['cultural_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_gaming_digital(x):
            """Detect gaming and digital entertainment"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Gaming and digital indicators
            gaming_indicators = [
                # Platforms
                'steam', 'playstation', 'xbox', 'nintendo', 'epic games',
                'origin', 'battle.net', 'blizzard', 'ubisoft', 'ea games',

                # Services
                'netflix', 'amazon prime', 'disney+', 'spotify', 'deezer',
                'youtube premium', 'twitch', 'apple music',

                # Gaming terms
                'jeux video', 'gaming', 'game', 'console', 'pc gaming',
                'dlc', 'season pass', 'in-app', 'microtransaction',

                # Stores
                'fnac', 'micromania', 'game stop', 'cdiscount jeux'
            ]

            matches = sum(1 for indicator in gaming_indicators if indicator in text_to_check)

            if matches >= 1:
                # Check amount range for gaming
                if (x.amt_mean < 0 and
                    self.thresholds['gaming_min_amount'] <= x.amt_mean <= self.thresholds['gaming_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_hobbies_crafts(x):
            """Detect hobby and craft-related purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Hobby and craft indicators
            hobby_indicators = [
                # Arts & Crafts
                'loisirs creatifs', 'artisanat', 'broderie', 'tricot',
                'peinture', 'dessin', 'sculpture', 'ceramique',
                'scrapbooking', 'couture', 'menuiserie',

                # Books & Media
                'librairie', 'livre', 'bd', 'manga', 'comics',
                'vinyle', 'cd', 'dvd', 'blu-ray',

                # Collectibles
                'collection', 'figurine', 'carte', 'timbre',
                'monnaie', 'antiquite', 'brocante',

                # Music & Photography
                'instrument musique', 'guitare', 'piano', 'batterie',
                'photo', 'appareil photo', 'objectif',

                # Stores
                'cultura', 'action', 'gifi', 'casa', 'maison du monde'
            ]

            matches = sum(1 for indicator in hobby_indicators if indicator in text_to_check)

            if matches >= 1:
                # Check amount range for hobbies
                if (x.amt_mean < 0 and
                    self.thresholds['hobby_min_amount'] <= x.amt_mean <= self.thresholds['hobby_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_recreational_venues(x):
            """Detect recreational venues and activities"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Recreational venue indicators
            recreational_indicators = [
                # Amusement
                'parc attraction', 'parc loisirs', 'luna park', 'foire',
                'disneyland', 'asterix', 'futuroscope', 'puy du fou',

                # Entertainment venues
                'bowling', 'billard', 'karting', 'laser game',
                'escape game', 'paintball', 'accrobranche',
                'mini golf', 'golf practice',

                # Aquatic & Nature
                'piscine', 'aquarium', 'zoo', 'safari',
                'parc animalier', 'ferme pedagogique',

                # Indoor entertainment
                'casino', 'machines sous', 'jeux hasard',
                'salle jeux', 'arcade'
            ]

            matches = sum(1 for indicator in recreational_indicators if indicator in text_to_check)

            if matches >= 1:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_text_anchor(x):
            """FastText similarity with entertainment anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require good similarity and expense pattern
            if similarity >= 0.6 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_dining_pattern(x):
            """Detect regular dining patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Dining amount range
            is_dining_amount = (self.thresholds['dining_min_amount'] <=
                              x.amt_mean <=
                              self.thresholds['dining_max_amount'])

            # Regular dining (weekly to bi-weekly)
            is_regular_dining = (3 <= x.mean_delta_days <= self.thresholds['dining_max_days'])

            # Dining can be variable
            is_reasonable_variance = x.amt_cv <= self.thresholds['max_cv_regular']

            if is_dining_amount and is_regular_dining and is_reasonable_variance:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_subscription_pattern(x):
            """Detect entertainment subscription patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            # Subscription amount range
            is_subscription_amount = (self.thresholds['membership_min_amount'] <=
                                    x.amt_mean <=
                                    self.thresholds['membership_max_amount'])

            # Monthly pattern
            is_monthly = (self.thresholds['membership_monthly_min'] <=
                         x.mean_delta_days <=
                         self.thresholds['membership_monthly_max'])

            # Should be consistent
            is_consistent = x.amt_cv <= 0.3

            if is_subscription_amount and is_monthly and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_entertainment_weekend_leisure(x):
            """Detect weekend leisure spending patterns (if day info available)"""
            # Placeholder for weekend pattern detection
            # Could be enhanced with day-of-week analysis
            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_entertainment_positive_amounts(x):
            """Positive amounts are income, not entertainment expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_entertainment_utilities(x):
            """Exclude utility payments"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez', 'electricite', 'gaz', 'eau', 'internet'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_entertainment_groceries(x):
            """Exclude grocery shopping"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_entertainment_health(x):
            """Exclude health and medical expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            health_indicators = [
                'pharmacie', 'medecin', 'docteur', 'hopital', 'clinique',
                'dentiste', 'kinesitherapeute', 'medical', 'sante'
            ]

            if any(indicator in text_to_check for indicator in health_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_entertainment_business_expenses(x):
            """Exclude business-related expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            business_indicators = [
                'professionnel', 'entreprise', 'business', 'bureau',
                'fourniture bureau', 'papeterie', 'imprimerie',
                'formation', 'conference', 'seminaire', 'networking'
            ]

            if any(indicator in text_to_check for indicator in business_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_entertainment_transport(x):
            """Exclude transportation expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'carburant', 'station service', 'total', 'bp',
                'sncf', 'ratp', 'metro', 'bus', 'taxi', 'uber',
                'parking', 'peage', 'autoroute', 'assurance auto'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_entertainment_very_large(x):
            """Very large amounts unlikely to be entertainment"""
            if x.amt_mean < -1000:  # Very large expenses
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_entertainment_very_small_frequent(x):
            """Very small frequent amounts might be automatic charges"""
            if (x.amt_mean > -3 and  # Very small amounts
                x.amt_count > 20 and  # Very frequent
                x.mean_delta_days < 5):  # Almost daily
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_entertainment_essential_services(x):
            """Exclude essential services"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            essential_indicators = [
                'assurance', 'banque', 'credit', 'pret', 'emprunt',
                'impot', 'taxe', 'cotisation', 'charges',
                'loyer', 'bail', 'syndic', 'copropriete'
            ]

            if any(indicator in text_to_check for indicator in essential_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            # Positive labeling functions
            LabelingFunction(name="lf_entertainment_naf_codes", f=lf_entertainment_naf_codes),
            LabelingFunction(name="lf_entertainment_restaurants", f=lf_entertainment_restaurants),
            LabelingFunction(name="lf_entertainment_bars_cafes", f=lf_entertainment_bars_cafes),
            LabelingFunction(name="lf_entertainment_cultural_venues", f=lf_entertainment_cultural_venues),
            LabelingFunction(name="lf_entertainment_gaming_digital", f=lf_entertainment_gaming_digital),
            LabelingFunction(name="lf_entertainment_hobbies_crafts", f=lf_entertainment_hobbies_crafts),
            LabelingFunction(name="lf_entertainment_recreational_venues", f=lf_entertainment_recreational_venues),
            LabelingFunction(name="lf_entertainment_text_anchor", f=lf_entertainment_text_anchor),
            LabelingFunction(name="lf_entertainment_dining_pattern", f=lf_entertainment_dining_pattern),
            LabelingFunction(name="lf_entertainment_subscription_pattern", f=lf_entertainment_subscription_pattern),

            # Negative labeling functions
            LabelingFunction(name="lf_not_entertainment_positive_amounts", f=lf_not_entertainment_positive_amounts),
            LabelingFunction(name="lf_not_entertainment_utilities", f=lf_not_entertainment_utilities),
            LabelingFunction(name="lf_not_entertainment_groceries", f=lf_not_entertainment_groceries),
            LabelingFunction(name="lf_not_entertainment_health", f=lf_not_entertainment_health),
            LabelingFunction(name="lf_not_entertainment_business_expenses", f=lf_not_entertainment_business_expenses),
            LabelingFunction(name="lf_not_entertainment_transport", f=lf_not_entertainment_transport),
            LabelingFunction(name="lf_not_entertainment_very_large", f=lf_not_entertainment_very_large),
            LabelingFunction(name="lf_not_entertainment_very_small_frequent", f=lf_not_entertainment_very_small_frequent),
            LabelingFunction(name="lf_not_entertainment_essential_services", f=lf_not_entertainment_essential_services),
        ]


# Usage functions
def create_entertainment_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run entertainment classifier"""

    # Create classifier instance
    classifier = EntertainmentClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Create entertainment classifier
entertainment_classifier = EntertainmentClassifier(ft, merchant_agg_df, user_profile)
entertainment_results = entertainment_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
entertainment_excel = extract_lf_results_to_excel(
    entertainment_classifier, merchant_agg_df, "entertainment_lf_detailed_results.xlsx"
)

print(f"Entertainment Results:")
print(f"- Total predicted: {entertainment_results['predicted_positive']}")
print(f"- High confidence: {entertainment_results['high_confidence_positive']}")

# Analyze by subcategory
dining_examples = entertainment_results['high_confidence_examples'][
    entertainment_results['high_confidence_examples']['amt_mean'] <= -15  # Likely meals
]
cultural_examples = entertainment_results['high_confidence_examples'][
    (entertainment_results['high_confidence_examples']['amt_mean'] <= -25) &
    (entertainment_results['high_confidence_examples']['amt_count'] <= 5)  # Likely events
]

print(f"\nDining transactions: {len(dining_examples)}")
print(f"Cultural/Event transactions: {len(cultural_examples)}")
"""

# Create entertainment classifier
entertainment_classifier = EntertainmentClassifier(ft, merchant_agg_df, user_profile)
entertainment_results = entertainment_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
entertainment_excel = extract_lf_results_to_excel(
    entertainment_classifier, merchant_agg_df, "entertainment_lf_detailed_results.xlsx"
)

print(f"Entertainment Results:")
print(f"- Total predicted: {entertainment_results['predicted_positive']}")
print(f"- High confidence: {entertainment_results['high_confidence_positive']}")

# Analyze by subcategory
dining_examples = entertainment_results['high_confidence_examples'][
    entertainment_results['high_confidence_examples']['amt_mean'] <= -15  # Likely meals
]
cultural_examples = entertainment_results['high_confidence_examples'][
    (entertainment_results['high_confidence_examples']['amt_mean'] <= -25) &
    (entertainment_results['high_confidence_examples']['amt_count'] <= 5)  # Likely events
]

print(f"\nDining transactions: {len(dining_examples)}")
print(f"Cultural/Event transactions: {len(cultural_examples)}")

"""# Exceptional expense

Holidays
"""

class HolidaysClassifier(CategoryClassifier):
    """Holiday/Travel expense classifier with clustered spending detection"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Holidays", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_holiday_thresholds()

        # Travel-specific anchors
        travel_anchors = [
            "hotel", "flight", "plane", "airport", "booking", "airbnb",
            "voyage", "travel", "vacation", "holiday", "resort", "hostel",
            "airlines", "avion", "aeroport", "reservation", "sejour",
            "auberge", "gite", "pension", "croisiere", "ferry", "train"
        ]
        self.setup_anchors(travel_anchors, similarity_threshold=0.65)

    def _calculate_holiday_thresholds(self) -> dict:
        """Calculate travel-specific thresholds"""
        base_thresholds = {
            'min_amount': -5000,        # Maximum travel expense (luxury trips)
            'max_amount': -30,          # Minimum meaningful travel expense
            'hotel_min': -40,           # Minimum hotel expense
            'flight_min': -50,          # Minimum flight expense
            'max_frequency': 20,        # Max travel transactions per year
            'min_gap_days': 7,          # Minimum gap between travel periods
            'cluster_window': 14,       # Days to look for travel clusters
            'infrequent_max_count': 8,  # Max count for "infrequent" classification
            'substantial_min': -100,    # Minimum for "substantial" travel expense
        }

        # Adjust based on user income if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -10000,       # Higher travel budget
                    'hotel_min': -80,
                    'flight_min': -100,
                    'substantial_min': -200
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -2000,        # Lower travel budget
                    'max_amount': -20,
                    'hotel_min': -25,
                    'flight_min': -30,
                    'substantial_min': -50
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create travel-specific labeling functions"""

        def lf_travel_major_providers_high_confidence(x):
            """HIGH CONFIDENCE: Major travel platforms and airlines"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Major travel booking platforms and providers
            major_travel_providers = [
                # Booking platforms
                "BOOKING.COM", "BOOKING", "AIRBNB", "EXPEDIA", "HOTELS.COM", "AGODA",
                "TRIVAGO", "KAYAK", "OPODO", "LASTMINUTE", "THOMAS COOK", "TUI",

                # Airlines - major international
                "AIR FRANCE", "LUFTHANSA", "RYANAIR", "EASYJET", "BRITISH AIRWAYS",
                "KLM", "ALITALIA", "IBERIA", "SWISS", "AUSTRIAN", "EMIRATES",
                "TURKISH AIRLINES", "DELTA", "AMERICAN AIRLINES", "UNITED",

                # Airlines - budget/regional
                "VUELING", "TRANSAVIA", "WIZZ AIR", "NORWEGIAN", "FLYBE",
                "VOLOTEA", "HOP", "CORSAIR", "FRENCH BEE",

                # Hotels - major chains
                "MARRIOTT", "HILTON", "ACCOR", "IBIS", "NOVOTEL", "MERCURE",
                "SOFITEL", "PULLMAN", "HOLIDAY INN", "BEST WESTERN", "RADISSON",
                "HYATT", "SHERATON", "WESTIN", "INTERCONTINENTAL",

                # Transportation
                "SNCF", "EUROSTAR", "THALYS", "HERTZ", "AVIS", "EUROPCAR",
                "ENTERPRISE", "SIXT", "BUDGET", "NATIONAL CAR RENTAL",

                # Travel services
                "VIATOR", "GETYOURGUIDE", "KLOOK", "TIQETS"
            ]

            # Check for provider match
            for provider in major_travel_providers:
                if provider in merchant_text:
                    # High confidence - any expense amount, any frequency
                    if x.amt_mean < 0:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_naf_codes(x):
            """NAF codes for tourism and travel industry"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            travel_naf_codes = [
                # Air transport
                "51.10Z", "51.21Z", "51.22Z",

                # Accommodation
                "55.10Z",  # Hotels and similar accommodation
                "55.20Z",  # Holiday and other short-stay accommodation
                "55.30Z",  # Camping grounds, recreational vehicle parks
                "55.90Z",  # Other accommodation

                # Travel agencies and tour operators
                "79.11Z",  # Travel agency activities
                "79.12Z",  # Tour operator activities
                "79.90Z",  # Other reservation service activities

                # Transport rental
                "77.11Z",  # Rental of cars and light motor vehicles
                "77.12Z",  # Rental of trucks
                "77.39Z",  # Rental of other machinery and equipment

                # Water transport
                "50.10Z",  # Sea and coastal passenger water transport
                "50.30Z",  # Inland passenger water transport

                # Tourist transport
                "49.39A",  # Transport by cable cars and funiculars
                "49.39B",  # Other passenger land transport
            ]

            if str(x.NAF_CODE).strip() in travel_naf_codes:
                # Must be expense and above minimum threshold
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_travel_keywords_specific(x):
            """Specific travel keywords with context validation"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Specific travel keywords (avoiding generic terms)
            specific_travel_keywords = [
                # Accommodation specific
                'hotel', 'auberge', 'resort', 'pension', 'gite', 'chambre hote',
                'bed and breakfast', 'hostel', 'motel', 'lodge', 'villa rental',

                # Flight specific
                'billet avion', 'airline ticket', 'flight booking', 'vol retour',
                'compagnie aerienne', 'charter flight', 'vol direct',

                # Transport specific
                'location voiture', 'car rental', 'train ticket', 'billet train',
                'ferry ticket', 'bus tour', 'taxi airport', 'navette aeroport',

                # Activity specific
                'excursion', 'tour guide', 'visite guidee', 'attraction ticket',
                'parc attraction', 'musee entree', 'spectacle voyage',

                # Package/booking specific
                'sejour', 'package holiday', 'voyage organise', 'week end',
                'reservation hotel', 'booking confirmation'
            ]

            # Count specific matches
            matches = sum(1 for keyword in specific_travel_keywords if keyword in text_to_check)

            if matches >= 1:
                # Must be expense above travel threshold
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_text_anchor(x):
            """FastText similarity for travel terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Good similarity + expense + reasonable amount
            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean <= self.thresholds['max_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_infrequent_substantial(x):
            """Infrequent but substantial expenses (typical of travel)"""
            if x.amt_mean >= 0:  # Must be expense
                return self.ABSTAIN

            # Travel pattern: infrequent but substantial
            is_infrequent = x.amt_count <= self.thresholds['infrequent_max_count']
            is_substantial = x.amt_mean <= self.thresholds['substantial_min']  # At least 100€
            has_gaps = x.mean_delta_days >= self.thresholds['min_gap_days'] if x.amt_count > 1 else True

            if is_infrequent and is_substantial and has_gaps:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_hotel_amounts(x):
            """Hotel-typical amounts and patterns"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['hotel_min']):
                return self.ABSTAIN

            # Hotel characteristics
            amount_abs = abs(int(x.amt_mean))

            # Common hotel price points (per night or short stays)
            typical_hotel_amounts = [40, 45, 50, 60, 70, 75, 80, 90, 100, 120, 150, 200, 250, 300]
            is_hotel_amount = any(abs(amount_abs - price) <= 10 for price in typical_hotel_amounts)

            # Hotels are typically infrequent
            is_travel_frequency = x.amt_count <= 12  # Max once per month

            if is_hotel_amount and is_travel_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_flight_amounts(x):
            """Flight-typical amounts"""
            if (x.amt_mean >= 0 or
                x.amt_mean > self.thresholds['flight_min']):
                return self.ABSTAIN

            # Flight characteristics: larger amounts, very infrequent
            is_flight_amount = x.amt_mean <= -50  # Minimum flight cost
            is_very_infrequent = x.amt_count <= 6  # Max 6 flights per year
            has_big_gaps = x.mean_delta_days >= 30 if x.amt_count > 1 else True

            if is_flight_amount and is_very_infrequent and has_big_gaps:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_travel_weekend_pattern(x):
            """Weekend/vacation timing pattern (if date info available)"""
            # Placeholder for date-based analysis
            # Could detect Friday/weekend transactions, seasonal patterns
            return self.ABSTAIN

        def lf_travel_foreign_indicators(x):
            """Foreign transaction indicators"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Foreign/international indicators
            foreign_indicators = [
                # Currency codes
                'usd', 'gbp', 'eur', 'chf', 'cad',

                # Country/city codes
                'london', 'amsterdam', 'madrid', 'rome', 'barcelona',
                'new york', 'tokyo', 'dubai', 'singapore',

                # Airport codes (common ones)
                'cdg', 'orly', 'lhr', 'ams', 'mad', 'bcn', 'fco',

                # International terms
                'international', 'foreign', 'overseas', 'abroad'
            ]

            if any(indicator in text_to_check for indicator in foreign_indicators):
                if x.amt_mean < 0 and x.amt_mean <= self.thresholds['max_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (crucial for travel to avoid false positives)

        def lf_not_travel_positive_amounts(x):
            """Positive amounts are income, not travel expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_travel_very_frequent(x):
            """Very frequent transactions unlikely to be travel"""
            if (x.amt_count > self.thresholds['max_frequency'] or
                (x.amt_count > 10 and x.mean_delta_days < 14)):  # More than bi-weekly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_travel_small_frequent(x):
            """Small frequent amounts unlikely to be travel"""
            if (x.amt_count > 8 and
                x.amt_mean > -30 and  # Small amounts
                x.mean_delta_days < 21):  # Frequent
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_travel_utilities_indicators(x):
            """Exclude utility-like patterns"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'electricite', 'gaz', 'eau', 'internet', 'telephone',
                'facture', 'abonnement mensuel'
            ]

            # Regular monthly pattern + utility keywords = not travel
            is_monthly_like = (x.amt_count >= 3 and
                             25 <= x.mean_delta_days <= 35)
            has_utility_keywords = any(indicator in text_to_check for indicator in utility_indicators)

            if is_monthly_like and has_utility_keywords:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_travel_grocery_indicators(x):
            """Exclude grocery-like transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'market', 'grocery'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_travel_restaurant_frequent(x):
            """Frequent restaurant transactions not travel"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie',
                'pizzeria', 'mcdo', 'mcdonald', 'kfc', 'subway'
            ]

            # Frequent restaurants = not travel (local dining)
            has_restaurant_indicators = any(indicator in text_to_check for indicator in restaurant_indicators)
            is_frequent = x.amt_count > 6 and x.mean_delta_days < 30

            if has_restaurant_indicators and is_frequent:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_travel_very_small_amounts(x):
            """Very small amounts unlikely to be meaningful travel expenses"""
            if x.amt_mean > -20:  # Less than 20€
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_travel_very_regular(x):
            """Very regular patterns unlikely to be travel"""
            if (x.amt_count >= 6 and
                x.amt_cv < 0.2 and  # Very consistent amounts
                20 <= x.mean_delta_days <= 40):  # Regular timing
                return self.NEGATIVE
            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_travel_major_providers_high_confidence", f=lf_travel_major_providers_high_confidence),
            LabelingFunction(name="lf_travel_naf_codes", f=lf_travel_naf_codes),
            LabelingFunction(name="lf_travel_keywords_specific", f=lf_travel_keywords_specific),
            LabelingFunction(name="lf_travel_text_anchor", f=lf_travel_text_anchor),
            LabelingFunction(name="lf_travel_infrequent_substantial", f=lf_travel_infrequent_substantial),
            LabelingFunction(name="lf_travel_hotel_amounts", f=lf_travel_hotel_amounts),
            LabelingFunction(name="lf_travel_flight_amounts", f=lf_travel_flight_amounts),
            LabelingFunction(name="lf_travel_foreign_indicators", f=lf_travel_foreign_indicators),
            LabelingFunction(name="lf_not_travel_positive_amounts", f=lf_not_travel_positive_amounts),
            LabelingFunction(name="lf_not_travel_very_frequent", f=lf_not_travel_very_frequent),
            LabelingFunction(name="lf_not_travel_small_frequent", f=lf_not_travel_small_frequent),
            LabelingFunction(name="lf_not_travel_utilities_indicators", f=lf_not_travel_utilities_indicators),
            LabelingFunction(name="lf_not_travel_grocery_indicators", f=lf_not_travel_grocery_indicators),
            LabelingFunction(name="lf_not_travel_restaurant_frequent", f=lf_not_travel_restaurant_frequent),
            LabelingFunction(name="lf_not_travel_very_small_amounts", f=lf_not_travel_very_small_amounts),
            LabelingFunction(name="lf_not_travel_very_regular", f=lf_not_travel_very_regular),
        ]


# Usage functions
def create_holidays_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run holidays/travel classifier"""

    # Create classifier instance
    classifier = HolidaysClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results

# Example usage:
"""
holidays_classifier = HolidaysClassifier(ft, merchant_agg_df, user_profile)
holidays_results = holidays_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
holidays_excel = extract_lf_results_to_excel(
    holidays_classifier, merchant_agg_df, "holidays_lf_detailed_results.xlsx"
)

print(f"Holidays/Travel Results:")
print(f"- Total predicted: {holidays_results['predicted_positive']}")
print(f"- High confidence: {holidays_results['high_confidence_positive']}")

# Show high confidence examples
if len(holidays_results['high_confidence_examples']) > 0:
    print("\nHigh confidence travel examples:")
    display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'holidays_confidence']
    print(holidays_results['high_confidence_examples'][display_cols].head(10))
"""

holidays_classifier = HolidaysClassifier(ft, merchant_agg_df, user_profile)
holidays_results = holidays_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
holidays_excel = extract_lf_results_to_excel(
    holidays_classifier, merchant_agg_df, "holidays_lf_detailed_results.xlsx"
)

print(f"Holidays/Travel Results:")
print(f"- Total predicted: {holidays_results['predicted_positive']}")
print(f"- High confidence: {holidays_results['high_confidence_positive']}")

# Show high confidence examples
if len(holidays_results['high_confidence_examples']) > 0:
    print("\nHigh confidence travel examples:")
    display_cols = ['CLEANED_TEXT', 'MERCHANT', 'amt_mean', 'amt_count', 'mean_delta_days', 'holidays_confidence']
    print(holidays_results['high_confidence_examples'][display_cols].head(10))

"""Gifts"""

class GiftsClassifier(CategoryClassifier):
    """Enhanced gifts classifier for personal gift purchases while excluding donations"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Gifts", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_gifts_thresholds()

        # Gift-specific anchors focusing on personal gifts and gift-giving
        gifts_anchors = [
            # Gift cards and vouchers
            "cadeau", "gift", "carte", "voucher", "bon", "cheque",
            # Gift occasions
            "anniversaire", "noel", "birthday", "wedding", "valentine",
            # Gift retailers
            "amazon", "fnac", "galeries", "bijouterie", "parfumerie",
            # Gift items
            "fleurs", "flowers", "chocolat", "bijoux", "jewelry"
        ]
        self.setup_anchors(gifts_anchors, similarity_threshold=0.6)

    def _calculate_gifts_thresholds(self) -> dict:
        """Calculate gift-specific thresholds for different gift patterns"""
        base_thresholds = {
            # Gift amount ranges (gifts can vary widely)
            'gift_min_amount': -2000,         # Maximum gift expense
            'gift_max_amount': -5,            # Minimum meaningful gift

            # Gift card specific
            'gift_card_min_amount': -500,     # Maximum gift card
            'gift_card_max_amount': -10,      # Minimum gift card

            # Seasonal patterns (gifts cluster around holidays)
            'seasonal_cluster_days': 60,      # Days around gift-giving seasons
            'max_frequency_per_month': 8,     # Maximum gifts per month (reasonable)

            # Gift characteristics
            'max_cv': 2.5,                    # Gifts can be very variable
            'min_frequency': 1,               # Even single purchases count
            'typical_gift_occasions': 6,      # Major gift occasions per year

            # Exclusion thresholds
            'donation_min_amount': -50,       # Donations typically higher
            'business_gift_min': -100,        # Business gifts typically higher
        }

        # Adjust based on user profile
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'gift_min_amount': -5000,      # Luxury gifts
                    'gift_card_min_amount': -1000,
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'gift_min_amount': -500,       # Budget gifts
                    'gift_card_min_amount': -100,
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create comprehensive gift-specific labeling functions"""

        def lf_gifts_naf_codes(x):
            """NAF codes for gift-related businesses"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            # Gift-related NAF codes
            gifts_naf_codes = [
                # Gift and jewelry retail
                "47.77Z",  # Watches and jewelry retail
                "47.78A",  # Other retail sale of new goods in specialized stores
                "47.78B",  # Other retail sale of new goods in specialized stores
                "47.78C",  # Other retail sale of new goods in specialized stores
                "47.89Z",  # Other retail sale in non-specialized stores

                # Flowers and plants
                "47.76Z",  # Retail sale of flowers, plants

                # Books, music, gifts
                "47.61Z",  # Retail sale of books
                "47.62Z",  # Retail sale of newspapers and stationery
                "47.63Z",  # Retail sale of music and video recordings

                # Perfumery and cosmetics (common gifts)
                "47.75Z",  # Retail sale of cosmetic and toilet articles

                # Toy stores (gifts for children)
                "47.65Z",  # Retail sale of games and toys

                # Department stores (common gift shopping)
                "47.19A",  # Department stores
                "47.19B",  # Other retail sale in non-specialized stores

                # Art and crafts (gift items)
                "47.78A",  # Other retail sale of new goods in specialized stores
                "74.10Z",  # Specialized design activities
                "90.03A",  # Artistic creation
                "90.03B",  # Other artistic creation
            ]

            if str(x.NAF_CODE).strip() in gifts_naf_codes:
                if x.amt_mean < 0:  # Should be expense
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_gifts_gift_cards_explicit(x):
            """Detect explicit gift card purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Explicit gift card indicators
            gift_card_indicators = [
                'gift card', 'carte cadeau', 'carte-cadeau', 'gift-card',
                'bon cadeau', 'bon-cadeau', 'voucher', 'cheque cadeau',
                'cheque-cadeau', 'prepaid card', 'prepayee',
                'amazon gift', 'itunes gift', 'google play gift',
                'steam wallet', 'playstation card', 'xbox card'
            ]

            matches = sum(1 for indicator in gift_card_indicators if indicator in text_to_check)

            if matches >= 1:
                # Check amount range for gift cards
                if (x.amt_mean < 0 and
                    self.thresholds['gift_card_min_amount'] <= x.amt_mean <= self.thresholds['gift_card_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_major_gift_retailers(x):
            """Detect major gift retailers and department stores"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().lower()

            # Major gift retailers
            gift_retailers = [
                # Department stores
                'galeries lafayette', 'printemps', 'bon marche', 'bazar hotel ville',
                'monoprix', 'fnac', 'darty', 'cultura',

                # Online gift platforms
                'amazon', 'cdiscount', 'rue du commerce', 'zalando',
                'vente privee', 'showroomprive',

                # Jewelry and luxury
                'bijouterie', 'joaillerie', 'cartier', 'tiffany',
                'swarovski', 'pandora', 'histoire or',

                # Perfumery and cosmetics
                'sephora', 'marionnaud', 'nocibe', 'douglas',
                'parfumerie', 'yves rocher', 'loccitane',

                # Flowers and plants
                'florajet', 'aquarelle', 'interflora', 'bergamotte',
                'fleuriste', 'jardinerie', 'truffaut',

                # Specialty gift stores
                'nature decouvertes', 'pylones', 'casa',
                'maison du monde', 'gifi', 'action'
            ]

            # Check for gift retailer match
            for retailer in gift_retailers:
                if retailer in merchant_text:
                    if (x.amt_mean < 0 and
                        self.thresholds['gift_min_amount'] <= x.amt_mean <= self.thresholds['gift_max_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_occasion_keywords(x):
            """Detect gift occasion keywords"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Gift occasion keywords
            occasion_keywords = [
                # Celebrations
                'anniversaire', 'birthday', 'noel', 'christmas', 'xmas',
                'saint valentin', 'valentine', 'fete meres', 'fete peres',
                'mother day', 'father day', 'mariage', 'wedding',

                # Gift-related terms
                'cadeau', 'gift', 'presente', 'surprise', 'offrir',
                'pour elle', 'pour lui', 'pour maman', 'pour papa',

                # Gift wrapping and services
                'emballage cadeau', 'gift wrap', 'papier cadeau',
                'livraison cadeau', 'gift delivery'
            ]

            matches = sum(1 for keyword in occasion_keywords if keyword in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['gift_min_amount'] <= x.amt_mean <= self.thresholds['gift_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_typical_gift_items(x):
            """Detect typical gift items and categories"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Typical gift items
            gift_items = [
                # Jewelry and accessories
                'bijoux', 'jewelry', 'collier', 'bague', 'bracelet',
                'montre', 'watch', 'boucles oreilles', 'pendentif',

                # Flowers and plants
                'fleurs', 'flowers', 'bouquet', 'roses', 'orchidee',
                'plante', 'plant', 'composition florale',

                # Perfumes and cosmetics
                'parfum', 'perfume', 'eau de toilette', 'eau de parfum',
                'cosmetique', 'maquillage', 'rouge levre', 'mascara',

                # Books and media
                'livre', 'book', 'bd', 'manga', 'dvd', 'blu-ray',
                'vinyle', 'cd', 'album', 'coffret',

                # Chocolates and gourmet
                'chocolat', 'chocolate', 'confiserie', 'patisserie',
                'coffret gourmand', 'specialite', 'gastronomie',

                # Toys and games
                'jouet', 'toy', 'peluche', 'puzzle', 'jeu societe',
                'lego', 'playmobil', 'figurine',

                # Art and decoration
                'tableau', 'poster', 'cadre', 'vase', 'bougie',
                'decoration', 'artisanat', 'fait main'
            ]

            matches = sum(1 for item in gift_items if item in text_to_check)

            if matches >= 1:
                if (x.amt_mean < 0 and
                    self.thresholds['gift_min_amount'] <= x.amt_mean <= self.thresholds['gift_max_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_text_anchor(x):
            """FastText similarity with gift anchors"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # Require good similarity and expense pattern
            if similarity >= 0.6 and x.amt_mean < 0:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_seasonal_clustering(x):
            """Detect seasonal gift-giving patterns"""
            # This would require date analysis - placeholder for now
            # Could be enhanced with actual date-based seasonal detection
            # Looking for clusters around December (Christmas), February (Valentine's), etc.
            return self.ABSTAIN

        def lf_gifts_round_amounts(x):
            """Detect round gift amounts (people often give round numbers)"""
            if x.amt_mean >= 0 or x.amt_count < 1:
                return self.ABSTAIN

            # Common gift amounts (round numbers)
            amount_abs = abs(int(x.amt_mean))
            common_gift_amounts = [
                10, 15, 20, 25, 30, 40, 50, 75, 100, 150, 200, 250, 300, 500, 1000
            ]

            is_round_amount = amount_abs in common_gift_amounts
            is_reasonable_frequency = x.amt_count <= 12  # Not too frequent (max monthly)

            if is_round_amount and is_reasonable_frequency:
                # Additional context check for gift retailers
                has_gift_context = False
                if not pd.isna(x.MERCHANT):
                    merchant_lower = str(x.MERCHANT).lower()
                    gift_contexts = ['amazon', 'fnac', 'galeries', 'cadeau', 'gift']
                    has_gift_context = any(context in merchant_lower for context in gift_contexts)

                if has_gift_context:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_online_gift_platforms(x):
            """Detect online platforms commonly used for gifts"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().lower()

            # Online platforms commonly used for gifts
            gift_platforms = [
                'amazon', 'fnac', 'cdiscount', 'rue du commerce',
                'zalando', 'asos', 'vente privee', 'showroomprive',
                'etsy', 'leboncoin', 'rakuten', 'priceminister',
                'darty', 'boulanger', 'cultura', 'micromania'
            ]

            has_platform = any(platform in merchant_text for platform in gift_platforms)

            if has_platform:
                # For online platforms, look for gift-like patterns
                is_gift_pattern = (
                    x.amt_count <= 6 and  # Not too frequent (occasional purchases)
                    x.amt_mean <= self.thresholds['gift_max_amount'] and
                    x.amt_mean >= self.thresholds['gift_min_amount']
                )

                if is_gift_pattern:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_gifts_luxury_occasional(x):
            """Detect luxury items purchased occasionally (likely gifts)"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Luxury amount threshold
            is_luxury_amount = x.amt_mean < -200  # Higher-end purchases

            # Should be infrequent
            is_occasional = x.amt_count <= 3

            if is_luxury_amount and is_occasional:
                # Check for luxury/gift context
                has_luxury_context = False
                if not pd.isna(x.MERCHANT):
                    merchant_lower = str(x.MERCHANT).lower()
                    luxury_contexts = [
                        'bijouterie', 'parfumerie', 'galeries lafayette', 'printemps',
                        'cartier', 'tiffany', 'swarovski', 'louis vuitton', 'hermes'
                    ]
                    has_luxury_context = any(context in merchant_lower for context in luxury_contexts)

                if has_luxury_context:
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions

        def lf_not_gifts_positive_amounts(x):
            """Positive amounts are income, not gift expenses"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_gifts_donations_charities(x):
            """Exclude charitable donations and NGOs"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Charity and donation indicators
            charity_indicators = [
                'don', 'donation', 'charity', 'association', 'fondation',
                'ong', 'ngo', 'humanitaire', 'benevolat', 'solidarite',
                'unicef', 'croix rouge', 'medecins sans frontieres',
                'resto du coeur', 'secours populaire', 'emmaus',
                'wwf', 'greenpeace', 'amnesty', 'oxfam'
            ]

            if any(indicator in text_to_check for indicator in charity_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_business_purchases(x):
            """Exclude business-related purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            business_indicators = [
                'professionnel', 'entreprise', 'business', 'bureau',
                'fourniture bureau', 'papeterie entreprise', 'formation',
                'conference', 'seminaire', 'networking', 'corporate'
            ]

            if any(indicator in text_to_check for indicator in business_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_personal_care_routine(x):
            """Exclude routine personal care purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            # Routine personal care (not gifts)
            routine_care = [
                'coiffeur', 'salon coiffure', 'barbier', 'esthetique',
                'manucure', 'pedicure', 'epilation', 'massage',
                'soin visage', 'soin corps'
            ]

            # Check if it's routine (frequent) personal care
            has_routine_care = any(indicator in text_to_check for indicator in routine_care)
            is_frequent = x.amt_count > 6  # More than 6 times suggests routine

            if has_routine_care and is_frequent:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_utilities_bills(x):
            """Exclude utility bills and essential services"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            utility_indicators = [
                'edf', 'engie', 'orange', 'free', 'sfr', 'bouygues',
                'veolia', 'suez', 'electricite', 'gaz', 'eau', 'internet',
                'assurance', 'mutuelle', 'banque', 'credit'
            ]

            if any(indicator in text_to_check for indicator in utility_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_groceries_food(x):
            """Exclude grocery and food purchases"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            grocery_indicators = [
                'carrefour', 'leclerc', 'aldi', 'lidl', 'casino', 'auchan',
                'monoprix', 'franprix', 'supermarche', 'hypermarche',
                'alimentaire', 'epicerie', 'boucherie', 'boulangerie'
            ]

            if any(indicator in text_to_check for indicator in grocery_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_transport_fuel(x):
            """Exclude transport and fuel expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'carburant', 'station service', 'total', 'bp', 'shell',
                'sncf', 'ratp', 'metro', 'bus', 'taxi', 'uber',
                'parking', 'peage', 'autoroute'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_gifts_very_frequent(x):
            """Very frequent purchases are unlikely to be gifts"""
            if (x.amt_count > 20 and  # Very frequent
                x.mean_delta_days < 7):  # More than weekly
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_gifts_very_small_amounts(x):
            """Very small amounts unlikely to be meaningful gifts"""
            if x.amt_mean > -5:  # Less than 5 EUR
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_gifts_medical_health(x):
            """Exclude medical and health expenses"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            health_indicators = [
                'pharmacie', 'medecin', 'docteur', 'hopital', 'clinique',
                'dentiste', 'kinesitherapeute', 'medical', 'sante'
            ]

            if any(indicator in text_to_check for indicator in health_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        return [
            # Positive labeling functions
            LabelingFunction(name="lf_gifts_naf_codes", f=lf_gifts_naf_codes),
            LabelingFunction(name="lf_gifts_gift_cards_explicit", f=lf_gifts_gift_cards_explicit),
            LabelingFunction(name="lf_gifts_major_gift_retailers", f=lf_gifts_major_gift_retailers),
            LabelingFunction(name="lf_gifts_occasion_keywords", f=lf_gifts_occasion_keywords),
            LabelingFunction(name="lf_gifts_typical_gift_items", f=lf_gifts_typical_gift_items),
            LabelingFunction(name="lf_gifts_text_anchor", f=lf_gifts_text_anchor),
            LabelingFunction(name="lf_gifts_round_amounts", f=lf_gifts_round_amounts),
            LabelingFunction(name="lf_gifts_online_gift_platforms", f=lf_gifts_online_gift_platforms),
            LabelingFunction(name="lf_gifts_luxury_occasional", f=lf_gifts_luxury_occasional),

            # Negative labeling functions
            LabelingFunction(name="lf_not_gifts_positive_amounts", f=lf_not_gifts_positive_amounts),
            LabelingFunction(name="lf_not_gifts_donations_charities", f=lf_not_gifts_donations_charities),
            LabelingFunction(name="lf_not_gifts_business_purchases", f=lf_not_gifts_business_purchases),
            LabelingFunction(name="lf_not_gifts_personal_care_routine", f=lf_not_gifts_personal_care_routine),
            LabelingFunction(name="lf_not_gifts_utilities_bills", f=lf_not_gifts_utilities_bills),
            LabelingFunction(name="lf_not_gifts_groceries_food", f=lf_not_gifts_groceries_food),
            LabelingFunction(name="lf_not_gifts_transport_fuel", f=lf_not_gifts_transport_fuel),
            LabelingFunction(name="lf_not_gifts_very_frequent", f=lf_not_gifts_very_frequent),
            LabelingFunction(name="lf_not_gifts_very_small_amounts", f=lf_not_gifts_very_small_amounts),
            LabelingFunction(name="lf_not_gifts_medical_health", f=lf_not_gifts_medical_health),
        ]


# Usage functions
def create_gifts_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run gifts classifier"""

    # Create classifier instance
    classifier = GiftsClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Create gifts classifier
gifts_classifier = GiftsClassifier(ft, merchant_agg_df, user_profile)
gifts_results = gifts_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
gifts_excel = extract_lf_results_to_excel(
    gifts_classifier, merchant_agg_df, "gifts_lf_detailed_results.xlsx"
)

print(f"Gifts Results:")
print(f"- Total predicted: {gifts_results['predicted_positive']}")
print(f"- High confidence: {gifts_results['high_confidence_positive']}")

# Analyze by gift type
gift_card_examples = gifts_results['high_confidence_examples'][
    gifts_results['high_confidence_examples']['CLEANED_TEXT'].str.contains('gift|cadeau', case=False, na=False)
]
luxury_gift_examples = gifts_results['high_confidence_examples'][
    gifts_results['high_confidence_examples']['amt_mean'] < -200  # Expensive gifts
]

print(f"\nGift card transactions: {len(gift_card_examples)}")
print(f"Luxury gift transactions: {len(luxury_gift_examples)}")
"""

# Create gifts classifier
gifts_classifier = GiftsClassifier(ft, merchant_agg_df, user_profile)
gifts_results = gifts_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
gifts_excel = extract_lf_results_to_excel(
    gifts_classifier, merchant_agg_df, "gifts_lf_detailed_results.xlsx"
)

print(f"Gifts Results:")
print(f"- Total predicted: {gifts_results['predicted_positive']}")
print(f"- High confidence: {gifts_results['high_confidence_positive']}")

# Analyze by gift type
gift_card_examples = gifts_results['high_confidence_examples'][
    gifts_results['high_confidence_examples']['CLEANED_TEXT'].str.contains('gift|cadeau', case=False, na=False)
]
luxury_gift_examples = gifts_results['high_confidence_examples'][
    gifts_results['high_confidence_examples']['amt_mean'] < -200  # Expensive gifts
]

print(f"\nGift card transactions: {len(gift_card_examples)}")
print(f"Luxury gift transactions: {len(luxury_gift_examples)}")

"""# Knowledge"""

class KnowledgeClassifier(CategoryClassifier):
    """Knowledge/Education classifier for books, courses, educational content"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("Knowledge", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_knowledge_thresholds()

        # Knowledge-specific anchors
        knowledge_anchors = [
            "education", "cours", "course", "formation", "livre", "book",
            "apprentissage", "learning", "ecole", "school", "universite", "university",
            "etude", "study", "certification", "diplome", "degree", "mooc",
            "tutorial", "masterclass", "workshop", "atelier", "seminaire"
        ]
        self.setup_anchors(knowledge_anchors, similarity_threshold=0.65)

    def _calculate_knowledge_thresholds(self) -> dict:
        """Calculate knowledge-specific thresholds based on user profile"""
        base_thresholds = {
            'min_amount': -10000,       # Professional degrees/bootcamps
            'max_amount': -5,           # Small educational apps
            'min_days_between': 30,     # At least monthly between purchases
            'max_days_between': 365,    # Up to yearly for major courses
            'min_frequency': 1,         # Single purchases acceptable
            'max_cv': 3.0,             # Very high variability expected
            'seasonal_bonus': True      # Sept/Jan seasonal patterns
        }

        # Adjust based on user profile and career stage
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': -20000,   # Executive education, MBAs
                    'max_amount': -10       # Higher threshold for apps
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': -3000,    # Community college, online courses
                    'max_amount': -3        # Very small educational purchases
                })

        return base_thresholds

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create knowledge/education-specific labeling functions"""

        def lf_knowledge_naf_codes(x):
            """NAF codes for educational institutions and bookstores"""
            if pd.isna(x.NAF_CODE):
                return self.ABSTAIN

            knowledge_naf_codes = [
                # Education
                "85.11Z",  # Pre-primary education
                "85.12Z",  # Primary education
                "85.20Z",  # Secondary education
                "85.31Z",  # General secondary education
                "85.32Z",  # Technical and vocational secondary education
                "85.41Z",  # Post-secondary non-tertiary education
                "85.42Z",  # Tertiary education
                "85.51Z",  # Sports and recreation education
                "85.52Z",  # Cultural education
                "85.53Z",  # Driving school activities
                "85.59A",  # Other education n.e.c.
                "85.59B",  # Other education
                "85.60Z",  # Educational support services

                # Publishing and bookstores
                "47.61Z",  # Retail sale of books
                "47.62Z",  # Retail sale of newspapers and stationery
                "58.11Z",  # Book publishing
                "58.13Z",  # Publishing of newspapers
                "58.14Z",  # Publishing of journals and periodicals
                "58.19Z",  # Other publishing activities

                # Research and professional training
                "72.11Z",  # Research and experimental development on biotechnology
                "72.19Z",  # Other research and experimental development
                "74.90Z",  # Other professional, scientific and technical activities
                "85.31Z",  # General secondary education
            ]

            if str(x.NAF_CODE).strip() in knowledge_naf_codes:
                if (x.amt_mean < 0 and
                    self.thresholds['min_amount'] <= x.amt_mean <= self.thresholds['max_amount']):
                    return self.POSITIVE
            return self.ABSTAIN

        def lf_knowledge_major_platforms_high_confidence(x):
            """HIGH CONFIDENCE: Major educational platforms"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Top educational platforms - almost exclusively educational
            top_educational_platforms = [
                # Online learning platforms
                "COURSERA", "UDEMY", "EDUREKA", "PLURALSIGHT", "LYNDA",
                "UDACITY", "EDX", "FUTURELEARN", "KHAN ACADEMY", "SKILLSHARE",
                "MASTERCLASS", "TREEHOUSE", "CODECADEMY", "DATACAMP",

                # Language learning
                "DUOLINGO", "BABBEL", "ROSETTA STONE", "BUSUU",

                # Professional certifications
                "MICROSOFT LEARN", "AWS TRAINING", "GOOGLE CLOUD", "CISCO",
                "COMPTIA", "PMI", "SCRUM",

                # Academic institutions (common abbreviations)
                "UNIVERSITE", "UNIVERSITY", "COLLEGE", "ECOLE", "SCHOOL",
                "SORBONNE", "SCIENCES PO", "ESSEC", "HEC", "INSEAD",

                # French educational institutions
                "CNED", "AFPA", "GRETA", "CCI FORMATION"
            ]

            # For these platforms, very relaxed criteria
            for platform in top_educational_platforms:
                if platform in merchant_text:
                    # Only requirement: expense within reasonable range
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_bookstores_publishers(x):
            """Bookstores and publishers"""
            if pd.isna(x.MERCHANT):
                return self.ABSTAIN

            merchant_text = str(x.MERCHANT).strip().upper()

            # Bookstores and publishers
            book_retailers = [
                # Physical bookstores
                "FNAC", "CULTURA", "GIBERT", "MOLLAT", "DECITRE", "FURET DU NORD",
                "WATERSTONES", "BARNES NOBLE", "BLACKWELL", "WHY SMITH",

                # Online book retailers
                "AMAZON BOOKS", "KINDLE", "AUDIBLE", "KOBO", "GOOGLE BOOKS",
                "APPLE BOOKS", "SCRIBD",

                # Publishers
                "PEARSON", "MCGRAW HILL", "WILEY", "SPRINGER", "ELSEVIER",
                "CAMBRIDGE", "OXFORD", "DUNOD", "EYROLLES", "ENI",

                # Academic bookstores
                "UNIVERSITY BOOKSTORE", "CAMPUS STORE", "LIBRAIRIE"
            ]

            for retailer in book_retailers:
                if retailer in merchant_text:
                    if (x.amt_mean < 0 and
                        x.amt_mean >= self.thresholds['min_amount']):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_comprehensive_keywords(x):
            """Comprehensive education keywords detection"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            knowledge_keywords = {
                # Education/Learning
                'education': ['education', 'formation', 'apprentissage', 'learning', 'study',
                             'etude', 'cours', 'course', 'classe', 'lesson', 'lecon',
                             'tutorial', 'tutoriel', 'guide', 'manuel', 'handbook'],

                # Institutions
                'institutions': ['ecole', 'school', 'universite', 'university', 'college',
                               'institut', 'institute', 'academie', 'academy', 'campus',
                               'faculte', 'faculty', 'department', 'cned', 'afpa'],

                # Books and content
                'books': ['livre', 'book', 'ebook', 'kindle', 'audible', 'audiobook',
                         'magazine', 'journal', 'revue', 'publication', 'edition',
                         'bibliotheque', 'library', 'librairie', 'bookstore'],

                # Online learning
                'online': ['mooc', 'webinar', 'webinaire', 'online', 'digital', 'numerique',
                          'elearning', 'e-learning', 'distance', 'virtual', 'virtuel',
                          'masterclass', 'workshop', 'atelier', 'seminaire', 'seminar'],

                # Certifications
                'certifications': ['certification', 'diplome', 'degree', 'certificate',
                                 'licence', 'master', 'bachelor', 'phd', 'doctorat',
                                 'qualification', 'accreditation', 'exam', 'examen'],

                # Skills/Subjects
                'subjects': ['informatique', 'programming', 'programmation', 'coding',
                           'data', 'analytics', 'marketing', 'management', 'langue',
                           'language', 'anglais', 'english', 'mathematics', 'science',
                           'design', 'art', 'music', 'musique', 'histoire', 'history'],

                # Professional development
                'professional': ['training', 'professional', 'professionnel', 'career',
                               'carriere', 'skill', 'competence', 'development',
                               'perfectionnement', 'conference', 'congres']
            }

            # Count matches across categories
            category_matches = {}
            for category, keywords in knowledge_keywords.items():
                matches = sum(1 for keyword in keywords if keyword in text_to_check)
                if matches > 0:
                    category_matches[category] = matches

            # Strong signal requirements
            total_matches = sum(category_matches.values())
            has_strong_signal = (
                total_matches >= 2 or  # Multiple keyword matches
                'institutions' in category_matches or  # Educational institution
                'certifications' in category_matches or  # Certification/degree
                category_matches.get('online', 0) >= 1 or  # Online learning
                category_matches.get('books', 0) >= 1  # Books/content
            )

            if has_strong_signal:
                if (x.amt_mean < 0 and
                    x.amt_mean >= self.thresholds['min_amount']):
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_text_anchor(x):
            """FastText similarity for knowledge/education terms"""
            if pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            if (similarity >= 0.65 and
                x.amt_mean < 0 and
                x.amt_mean >= self.thresholds['min_amount']):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_subscription_pattern(x):
            """Educational subscriptions (monthly/yearly)"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Monthly educational subscriptions (10-100 EUR range)
            is_monthly_sub = (
                25 <= x.mean_delta_days <= 35 and  # Monthly pattern
                -100 <= x.amt_mean <= -10 and      # Subscription-like amounts
                x.amt_cv <= 0.2                    # Very consistent
            )

            # Yearly educational subscriptions
            is_yearly_sub = (
                350 <= x.mean_delta_days <= 380 and  # Yearly pattern
                -500 <= x.amt_mean <= -50 and        # Annual subscription amounts
                x.amt_cv <= 0.3
            )

            if is_monthly_sub or is_yearly_sub:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_semester_pattern(x):
            """Semester-based educational payments"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            # Semester payments (every 4-6 months)
            is_semester = (
                120 <= x.mean_delta_days <= 180 and  # 4-6 months
                x.amt_mean <= -200 and               # Substantial amounts
                x.amt_cv <= 1.0                      # Some variability allowed
            )

            if is_semester:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_knowledge_single_course_purchase(x):
            """Single course or book purchases"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Single purchases of reasonable educational amounts
            is_single_course = (
                x.amt_count == 1 and                # Single purchase
                -2000 <= x.amt_mean <= -20 and      # Reasonable course/book range
                x.amt_mean >= self.thresholds['min_amount']
            )

            # Only positive if we have some text indication
            if is_single_course:
                # Need some educational context in text
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                educational_hints = [
                    'cours', 'course', 'formation', 'livre', 'book', 'education',
                    'learning', 'study', 'certification', 'training'
                ]

                if any(hint in text_to_check for hint in educational_hints):
                    return self.POSITIVE

            return self.ABSTAIN

        # Negative labeling functions (exclusions)

        def lf_not_knowledge_entertainment_streaming(x):
            """Exclude entertainment streaming (not educational)"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            entertainment_indicators = [
                'netflix', 'amazon prime', 'disney', 'hbo', 'spotify', 'deezer',
                'youtube premium', 'twitch', 'gaming', 'game', 'jeu',
                'entertainment', 'divertissement', 'cinema', 'film', 'movie'
            ]

            if any(indicator in text_to_check for indicator in entertainment_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_knowledge_groceries_pattern(x):
            """Exclude grocery-like frequent purchases"""
            if (x.amt_count >= 8 and  # Very frequent
                x.mean_delta_days <= 14 and  # More than bi-weekly
                -100 <= x.amt_mean <= -5):  # Small frequent amounts
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_knowledge_transport_indicators(x):
            """Exclude transport-related transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            transport_indicators = [
                'essence', 'fuel', 'station', 'peage', 'toll', 'parking',
                'metro', 'bus', 'train', 'sncf', 'ratp', 'uber', 'taxi'
            ]

            if any(indicator in text_to_check for indicator in transport_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_knowledge_restaurant_indicators(x):
            """Exclude restaurant/food transactions"""
            if pd.isna(x.MERCHANT) and pd.isna(x.CLEANED_TEXT):
                return self.ABSTAIN

            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += str(x.MERCHANT).lower()
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += " " + str(x.CLEANED_TEXT).lower()

            restaurant_indicators = [
                'restaurant', 'resto', 'cafe', 'bar', 'brasserie', 'fast food',
                'delivery', 'livraison', 'mcdo', 'burger', 'pizza'
            ]

            if any(indicator in text_to_check for indicator in restaurant_indicators):
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_knowledge_positive_amounts(x):
            """Positive amounts are income"""
            if x.amt_mean > 0:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_knowledge_very_large_amounts(x):
            """Very large amounts (likely real estate, cars)"""
            # Use income-adjusted threshold
            max_reasonable = self.thresholds['min_amount'] * 2
            if x.amt_mean < max_reasonable:
                return self.NEGATIVE
            return self.ABSTAIN

        def lf_not_knowledge_utilities_pattern(x):
            """Exclude utility-like monthly consistent patterns"""
            if (x.amt_count >= 6 and
                25 <= x.mean_delta_days <= 35 and  # Monthly
                x.amt_cv <= 0.2 and  # Very consistent
                -150 <= x.amt_mean <= -15):  # Utility-like amounts

                # Unless it's clearly educational subscription
                text_to_check = ""
                if not pd.isna(x.MERCHANT):
                    text_to_check += str(x.MERCHANT).lower()
                if not pd.isna(x.CLEANED_TEXT):
                    text_to_check += " " + str(x.CLEANED_TEXT).lower()

                educational_subs = ['coursera', 'udemy', 'skillshare', 'learning', 'education']
                is_educational_sub = any(sub in text_to_check for sub in educational_subs)

                if not is_educational_sub:
                    return self.NEGATIVE

            return self.ABSTAIN

        return [
            LabelingFunction(name="lf_knowledge_naf_codes", f=lf_knowledge_naf_codes),
            LabelingFunction(name="lf_knowledge_major_platforms_high_confidence", f=lf_knowledge_major_platforms_high_confidence),
            LabelingFunction(name="lf_knowledge_bookstores_publishers", f=lf_knowledge_bookstores_publishers),
            LabelingFunction(name="lf_knowledge_comprehensive_keywords", f=lf_knowledge_comprehensive_keywords),
            LabelingFunction(name="lf_knowledge_text_anchor", f=lf_knowledge_text_anchor),
            LabelingFunction(name="lf_knowledge_subscription_pattern", f=lf_knowledge_subscription_pattern),
            LabelingFunction(name="lf_knowledge_semester_pattern", f=lf_knowledge_semester_pattern),
            LabelingFunction(name="lf_knowledge_single_course_purchase", f=lf_knowledge_single_course_purchase),
            LabelingFunction(name="lf_not_knowledge_entertainment_streaming", f=lf_not_knowledge_entertainment_streaming),
            LabelingFunction(name="lf_not_knowledge_groceries_pattern", f=lf_not_knowledge_groceries_pattern),
            LabelingFunction(name="lf_not_knowledge_transport_indicators", f=lf_not_knowledge_transport_indicators),
            LabelingFunction(name="lf_not_knowledge_restaurant_indicators", f=lf_not_knowledge_restaurant_indicators),
            LabelingFunction(name="lf_not_knowledge_positive_amounts", f=lf_not_knowledge_positive_amounts),
            LabelingFunction(name="lf_not_knowledge_very_large_amounts", f=lf_not_knowledge_very_large_amounts),
            LabelingFunction(name="lf_not_knowledge_utilities_pattern", f=lf_not_knowledge_utilities_pattern),
        ]


# Usage function
def create_knowledge_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run knowledge classifier"""

    # Create classifier instance
    classifier = KnowledgeClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
knowledge_classifier = KnowledgeClassifier(ft, merchant_agg_df, user_profile)
knowledge_results = knowledge_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
knowledge_excel = extract_lf_results_to_excel(
    knowledge_classifier, merchant_agg_df, "knowledge_lf_detailed_results.xlsx"
)

print(f"Knowledge Results:")
print(f"- Total predicted: {knowledge_results['predicted_positive']}")
print(f"- High confidence: {knowledge_results['high_confidence_positive']}")
"""

knowledge_classifier = KnowledgeClassifier(ft, merchant_agg_df, user_profile)
knowledge_results = knowledge_classifier.run_full_pipeline(confidence_threshold=0.7)

# Export results
knowledge_excel = extract_lf_results_to_excel(
    knowledge_classifier, merchant_agg_df, "knowledge_lf_detailed_results.xlsx"
)

print(f"Knowledge Results:")
print(f"- Total predicted: {knowledge_results['predicted_positive']}")
print(f"- High confidence: {knowledge_results['high_confidence_positive']}")

"""# Transfer

External

Internal

# Investment
"""

"""
Investment Outflow Classifier using the reusable CategoryClassifier framework
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class InvestmentOutflowClassifier(CategoryClassifier):
    """Investment outflow classifier using weak supervision framework"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("InvestmentOutflow", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_investment_outflow_thresholds()

        # Investment outflow-specific anchor words for FastText expansion
        self.investment_outflow_anchor_terms = [
            "achat", "souscription", "versement", "placement", "invest",
            "purchase", "buy", "subscription", "contribution", "depot",
            "virement", "pea", "assurance", "vie", "per"
        ]

        # Comprehensive investment outflow terms organized by category
        self.investment_outflow_terms = {
            # Purchase/acquisition terms
            "purchase": ["achat", "achats", "souscription", "souscriptions", "acquisition",
                        "purchase", "buy", "buying", "acquired"],

            # Contribution/deposit terms
            "contributions": ["versement", "versements", "contribution", "contributions",
                             "depot", "dépôt", "depots", "dépôts", "apport", "cotisation"],

            # Investment/placement terms
            "placement": ["placement", "placements", "investissement", "investissements",
                         "invest", "investing", "investment", "investments"],

            # French investment accounts
            "accounts": ["pea", "plan epargne action", "plan d epargne action",
                        "assurance vie", "per", "plan epargne retraite",
                        "livret", "cto", "compte titre"],

            # Investment platforms/brokers (same as income but for outflows)
            "brokers": ["degiro", "interactive brokers", "saxo", "binck", "boursorama",
                       "fortuneo", "credit agricole titres", "bnp paribas securities",
                       "lyxor", "amundi", "blackrock"],

            # Investment instruments (buying context)
            "instruments": ["action", "actions", "obligation", "obligations", "part", "parts",
                           "fonds", "fond", "etf", "sicav", "fcpi", "scpi", "opc",
                           "tracker", "warrant", "option"]
        }

        # Known investment-related merchants/institutions
        self.investment_institutions = [
            "amundi", "lyxor", "blackrock", "vanguard", "ishares", "bnp paribas am",
            "credit agricole am", "natixis", "axa im", "carmignac", "lazard freres"
        ]

        # Flatten all terms for easy searching
        self.all_outflow_terms = []
        for category_terms in self.investment_outflow_terms.values():
            self.all_outflow_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.investment_outflow_anchor_terms, similarity_threshold=0.65)

    def _calculate_investment_outflow_thresholds(self) -> dict:
        """Calculate thresholds for investment outflow detection"""
        base_thresholds = {
            'min_amount': 50,         # Higher minimum for investments
            'max_amount': 100000,     # Higher ceiling for large investments
            'monthly_min': 100,       # Systematic monthly investing
            'quarterly_min': 500,     # Quarterly investments
            'annual_min': 1000,       # Annual investments
            'max_cv': 1.5,           # Higher variability tolerance
            'min_transactions': 1,    # Single transactions can be investments
            'round_amount_threshold': 50,  # Consider amounts ending in 0 or 00
            'large_lump_sum': 5000    # Threshold for large one-time investments
        }

        # Adjust based on user's income level if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 100,
                    'monthly_min': 300,
                    'quarterly_min': 1000,
                    'large_lump_sum': 10000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': 25,
                    'monthly_min': 50,
                    'quarterly_min': 200,
                    'large_lump_sum': 2000
                })

        return base_thresholds

    def _is_round_amount(self, amount: float) -> bool:
        """Check if amount is 'round' (common for investment contributions)"""
        if amount < self.thresholds['round_amount_threshold']:
            return False

        amount_int = int(abs(amount))

        # Ends in 00 (e.g., 500, 1000, 2500)
        if amount_int % 100 == 0:
            return True

        # Ends in 50 (e.g., 150, 250, 350)
        if amount_int % 50 == 0:
            return True

        # Common investment amounts
        common_amounts = [25, 75, 125, 175, 225, 275, 325, 375, 425, 475]
        if amount_int in common_amounts:
            return True

        return False

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create investment outflow-specific labeling functions"""

        def lf_investment_purchase_terms(x):
            """Detect investment outflow based on purchase/contribution terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be outgoing (negative amount)
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check for explicit investment purchase terms
            for term in self.all_outflow_terms:
                if "?" in term or "[" in term:  # Handle regex patterns
                    if re.search(term, text_lower):
                        if amount >= self.thresholds['min_amount']:
                            return self.POSITIVE
                else:
                    if re.search(rf"\b{re.escape(term)}\b", text_lower):
                        if amount >= self.thresholds['min_amount']:
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_fasttext_similarity(x):
            """Detect investment outflow using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            # Must be outgoing
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)
            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # High similarity with minimum amount
            if similarity >= 0.7 and amount >= self.thresholds['min_amount']:
                return self.POSITIVE
            # Lower similarity but higher amount threshold
            elif similarity >= 0.6 and amount >= self.thresholds['monthly_min']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_systematic_monthly_investment(x):
            """Detect monthly systematic investment patterns"""
            if x.amt_mean >= 0 or x.amt_count < 2:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Monthly pattern: ~28-32 days
            is_monthly = 26 <= x.mean_delta_days <= 35
            has_reasonable_amount = amount >= self.thresholds['monthly_min']
            moderate_consistency = x.amt_cv <= 0.4  # Systematic investing is fairly consistent

            if is_monthly and has_reasonable_amount and moderate_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_systematic_quarterly_investment(x):
            """Detect quarterly investment patterns"""
            if x.amt_mean >= 0 or x.amt_count < 2:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Quarterly pattern: ~90 days
            is_quarterly = 80 <= x.mean_delta_days <= 100
            has_reasonable_amount = amount >= self.thresholds['quarterly_min']
            moderate_consistency = x.amt_cv <= 0.5

            if is_quarterly and has_reasonable_amount and moderate_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_large_round_investment(x):
            """Detect large, round investment amounts"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Large amounts that are round numbers
            is_large = amount >= self.thresholds['quarterly_min']
            is_round = self._is_round_amount(amount)
            not_too_frequent = x.amt_count <= 12  # Not daily/weekly transactions

            if is_large and is_round and not_too_frequent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_broker_outflow(x):
            """Detect payments TO known investment brokers"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check both merchant name and transaction text
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Check for known investment brokers
            for broker in self.investment_outflow_terms["brokers"]:
                if broker in text_to_check:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            # Check for investment institutions
            for institution in self.investment_institutions:
                if institution in text_to_check:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_investment_account_contributions(x):
            """Detect contributions to specific investment accounts (PEA, Assurance Vie, etc.)"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()
            amount = abs(x.amt_mean)

            # Check for French investment account types
            for account_term in self.investment_outflow_terms["accounts"]:
                if account_term in text_lower:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_large_lump_sum_investment(x):
            """Detect large one-time investments"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very large amounts, infrequent
            is_very_large = amount >= self.thresholds['large_lump_sum']
            is_infrequent = x.amt_count <= 4  # Few transactions
            is_round = self._is_round_amount(amount)

            if is_very_large and is_infrequent:
                return self.POSITIVE
            elif is_very_large and is_round:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_investment_salary_outgoing(x):
            """Negative LF: Regular salary-like outgoing payments are not investments"""
            if x.amt_mean >= 0:  # Only check outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very regular patterns that look like salary/rent payments
            is_very_regular = (
                (28 <= x.mean_delta_days <= 32) or  # Monthly
                (13 <= x.mean_delta_days <= 16)     # Bi-weekly
            )

            is_very_consistent = x.amt_cv < 0.05
            is_not_round = not self._is_round_amount(amount)

            if is_very_regular and is_very_consistent and is_not_round:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_investment_small_frequent(x):
            """Negative LF: Small, very frequent payments unlikely to be investments"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            if amount < 25 and x.amt_count > 20:  # Very small, very frequent
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_investment_daily_spending(x):
            """Negative LF: Daily/weekly spending patterns are not investments"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Very frequent, small amounts (daily spending)
            is_very_frequent = x.mean_delta_days <= 7
            is_small_amount = abs(x.amt_mean) < 100
            is_many_transactions = x.amt_count > 15

            if is_very_frequent and is_small_amount and is_many_transactions:
                return self.NEGATIVE

            return self.ABSTAIN

        # Return list of labeling functions
        return [
            LabelingFunction(name="lf_investment_purchase_terms", f=lf_investment_purchase_terms),
            LabelingFunction(name="lf_investment_fasttext_similarity", f=lf_investment_fasttext_similarity),
            LabelingFunction(name="lf_systematic_monthly_investment", f=lf_systematic_monthly_investment),
            LabelingFunction(name="lf_systematic_quarterly_investment", f=lf_systematic_quarterly_investment),
            LabelingFunction(name="lf_large_round_investment", f=lf_large_round_investment),
            LabelingFunction(name="lf_investment_broker_outflow", f=lf_investment_broker_outflow),
            LabelingFunction(name="lf_investment_account_contributions", f=lf_investment_account_contributions),
            LabelingFunction(name="lf_large_lump_sum_investment", f=lf_large_lump_sum_investment),
            LabelingFunction(name="lf_not_investment_salary_outgoing", f=lf_not_investment_salary_outgoing),
            LabelingFunction(name="lf_not_investment_small_frequent", f=lf_not_investment_small_frequent),
            LabelingFunction(name="lf_not_investment_daily_spending", f=lf_not_investment_daily_spending),
        ]


# Usage example
def create_investment_outflow_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run investment outflow classifier"""

    # Create classifier instance
    classifier = InvestmentOutflowClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Assuming you have ft_model, merchant_agg_df, and user_profile ready
investment_outflow_classifier, results = create_investment_outflow_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

# Access results
print(f"Investment outflow transactions found: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Access the updated dataframe with predictions
updated_df = investment_outflow_classifier.df
print(updated_df[['CLEANED_TEXT', 'is_investmentoutflow_weak_label', 'investmentoutflow_confidence']].head())

# Compare with investment income results if available
# You could run both classifiers and analyze the patterns
"""

"""# Savings"""

"""
Savings Outflow Classifier using the reusable CategoryClassifier framework
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class SavingsOutflowClassifier(CategoryClassifier):
    """Savings outflow classifier using weak supervision framework"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("SavingsOutflow", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_savings_outflow_thresholds()

        # Savings outflow-specific anchor words for FastText expansion
        self.savings_outflow_anchor_terms = [
            "epargne", "livret", "savings", "save", "economie", "virement",
            "alimentation", "depot", "transfert", "provision"
        ]

        # Comprehensive savings outflow terms organized by category
        self.savings_outflow_terms = {
            # French savings accounts
            "savings_accounts": [
                "livret a", "livret", "ldd", "pel", "cel", "ldds",
                "compte epargne", "epargne", "savings", "livret plus",
                "livret orange", "livret bleu", "super livret",
                "compte sur livret", "compte a terme", "cat"
            ],

            # Goal-based savings
            "goal_savings": [
                "epargne logement", "epargne projet", "epargne vacances",
                "epargne enfant", "epargne retraite", "epargne precaution",
                "fonds d urgence", "emergency fund", "rainy day"
            ],

            # Transfer/deposit terms
            "transfer_terms": [
                "virement", "transfer", "transfert", "versement",
                "alimentation", "depot", "dépôt", "mise de cote",
                "provision", "save", "saving", "economie", "économie"
            ],

            # Savings purposes
            "purposes": [
                "urgence", "emergency", "precaution", "projet", "project",
                "vacances", "vacation", "voiture", "car", "maison", "house",
                "enfant", "enfants", "children", "retraite", "retirement"
            ],

            # Common savings banks/neo-banks
            "savings_banks": [
                "boursorama", "fortuneo", "hello bank", "orange bank",
                "revolut", "n26", "qonto", "shine", "compte nickel"
            ]
        }

        # Flatten all terms for easy searching
        self.all_savings_terms = []
        for category_terms in self.savings_outflow_terms.values():
            self.all_savings_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.savings_outflow_anchor_terms, similarity_threshold=0.65)

    def _calculate_savings_outflow_thresholds(self) -> dict:
        """Calculate thresholds for savings outflow detection"""
        base_thresholds = {
            'min_amount': 20,         # Lower minimum for savings
            'max_amount': 10000,      # Lower ceiling than investments
            'monthly_min': 50,        # Regular monthly saving
            'weekly_min': 25,         # Weekly saving
            'max_cv': 0.8,           # More consistent than investments
            'min_transactions': 1,    # Single transfers can be savings
            'small_round_threshold': 20,  # For small round amounts
            'medium_round_threshold': 100, # For medium round amounts
            'emergency_fund_min': 1000    # Larger irregular savings
        }

        # Adjust based on user's income level if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'min_amount': 50,
                    'monthly_min': 200,
                    'emergency_fund_min': 3000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'min_amount': 10,
                    'monthly_min': 25,
                    'emergency_fund_min': 300
                })

        return base_thresholds

    def _is_savings_round_amount(self, amount: float) -> bool:
        """Check if amount is 'round' for savings (smaller increments than investments)"""
        if amount < self.thresholds['small_round_threshold']:
            return False

        amount_int = int(abs(amount))

        # Common small savings amounts
        small_rounds = [20, 25, 30, 40, 50, 75]
        if amount_int in small_rounds:
            return True

        # Medium savings amounts (ends in 0 or 00)
        if amount_int >= self.thresholds['medium_round_threshold']:
            if amount_int % 100 == 0:  # €100, €200, €300, etc.
                return True
            if amount_int % 50 == 0:   # €150, €250, €350, etc.
                return True

        # Percentage-like amounts (suggesting % of salary)
        percentage_amounts = [83, 167, 250, 333, 417, 500, 583, 667, 750, 833]  # 5%, 10%, 15%, 20%, 25%, 30%, 35%, 40%, 45%, 50% of €1666
        if amount_int in percentage_amounts:
            return True

        return False

    def _detect_percentage_pattern(self, x) -> bool:
        """Detect if savings amount might be percentage-based (e.g., 10% of salary)"""
        amount = abs(x.amt_mean)

        # Common percentage amounts suggesting % of salary
        # Based on typical French net salaries
        common_percentages = {
            # 10% of common salaries
            150: "10% of €1500", 200: "10% of €2000", 250: "10% of €2500",
            300: "10% of €3000", 350: "10% of €3500", 400: "10% of €4000",
            # 15% of common salaries
            225: "15% of €1500", 300: "15% of €2000", 375: "15% of €2500",
            # 20% of common salaries
            300: "20% of €1500", 400: "20% of €2000", 500: "20% of €2500"
        }

        # Check if amount matches common percentage patterns (with tolerance)
        for target_amount in common_percentages.keys():
            if abs(amount - target_amount) <= 25:  # 25€ tolerance
                return True

        return False

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create savings outflow-specific labeling functions"""

        def lf_savings_account_explicit(x):
            """Detect explicit transfers to savings accounts"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be outgoing (negative amount)
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check for explicit savings account terms
            for term in self.savings_outflow_terms["savings_accounts"]:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_transfer_terms(x):
            """Detect savings using transfer/deposit terminology"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be outgoing
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Look for transfer terms combined with savings context
            has_transfer_term = any(term in text_lower for term in self.savings_outflow_terms["transfer_terms"])
            has_savings_context = any(term in text_lower for term in ["epargne", "savings", "livret", "save"])

            if has_transfer_term and has_savings_context:
                if amount >= self.thresholds['min_amount']:
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_fasttext_similarity(x):
            """Detect savings outflow using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            # Must be outgoing
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)
            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # High similarity with minimum amount
            if similarity >= 0.7 and amount >= self.thresholds['min_amount']:
                return self.POSITIVE
            # Medium similarity with higher amount
            elif similarity >= 0.6 and amount >= self.thresholds['monthly_min']:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_regular_monthly_savings(x):
            """Detect regular monthly savings patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:  # Must be outgoing, need pattern
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Monthly pattern: ~28-32 days
            is_monthly = 26 <= x.mean_delta_days <= 35
            has_reasonable_amount = amount >= self.thresholds['monthly_min']
            is_consistent = x.amt_cv <= self.thresholds['max_cv']

            if is_monthly and has_reasonable_amount and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_regular_weekly_savings(x):
            """Detect weekly savings patterns"""
            if x.amt_mean >= 0 or x.amt_count < 4:  # Must be outgoing, need pattern
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Weekly pattern: ~7 days
            is_weekly = 6 <= x.mean_delta_days <= 9
            has_reasonable_amount = amount >= self.thresholds['weekly_min']
            is_consistent = x.amt_cv <= 0.4  # Weekly savings should be very consistent

            if is_weekly and has_reasonable_amount and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_round_savings_amounts(x):
            """Detect round savings amounts"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Round amounts common for savings
            is_savings_round = self._is_savings_round_amount(amount)
            reasonable_frequency = x.amt_count <= 52  # Max weekly for a year
            not_too_large = amount <= self.thresholds['max_amount']

            if is_savings_round and reasonable_frequency and not_too_large:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_percentage_based_savings(x):
            """Detect percentage-based savings (like 10% of salary)"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            # Check if amount suggests percentage of typical salary
            is_percentage_pattern = self._detect_percentage_pattern(x)
            is_regular = x.amt_count >= 3
            is_consistent = x.amt_cv <= 0.3  # Percentage-based should be consistent

            if is_percentage_pattern and is_regular and is_consistent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_emergency_fund_pattern(x):
            """Detect emergency fund / large irregular savings"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Large amounts, infrequent (emergency fund building)
            is_large = amount >= self.thresholds['emergency_fund_min']
            is_infrequent = x.amt_count <= 6  # Few large transfers
            is_round = self._is_savings_round_amount(amount) or amount % 500 == 0

            if is_large and is_infrequent:
                return self.POSITIVE
            elif is_large and is_round:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_savings_banks_outflow(x):
            """Detect transfers to savings-focused banks/neo-banks"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check both merchant name and transaction text
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Check for savings-focused banks
            for bank in self.savings_outflow_terms["savings_banks"]:
                if bank in text_to_check:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_goal_based_savings(x):
            """Detect goal-based savings (vacation, car, house, etc.)"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()
            amount = abs(x.amt_mean)

            # Check for goal-based savings terms
            for purpose in self.savings_outflow_terms["purposes"]:
                if purpose in text_lower:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            # Check for explicit goal savings
            for goal_term in self.savings_outflow_terms["goal_savings"]:
                if goal_term in text_lower:
                    if amount >= self.thresholds['min_amount']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_not_savings_investment_size(x):
            """Negative LF: Very large amounts likely investments, not savings"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very large amounts more likely investments
            is_very_large = amount > 5000
            is_infrequent = x.amt_count <= 2

            if is_very_large and is_infrequent:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_savings_bills_utilities(x):
            """Negative LF: Regular bills/utilities are not savings"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Common bill/utility terms
            bill_terms = ["edf", "gdf", "engie", "eau", "water", "electricity", "gas",
                         "internet", "mobile", "phone", "assurance", "insurance",
                         "loyer", "rent", "credit", "pret", "loan"]

            has_bill_term = any(term in text_lower for term in bill_terms)
            is_regular = x.amt_count >= 6
            is_consistent = x.amt_cv < 0.2

            if has_bill_term and is_regular and is_consistent:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_savings_daily_spending(x):
            """Negative LF: Daily spending patterns are not savings"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            # Very frequent, small amounts (daily spending)
            is_very_frequent = x.mean_delta_days <= 3
            is_small_amount = abs(x.amt_mean) < 50
            is_many_transactions = x.amt_count > 30

            if is_very_frequent and is_small_amount and is_many_transactions:
                return self.NEGATIVE

            return self.ABSTAIN

        # Return list of labeling functions
        return [
            LabelingFunction(name="lf_savings_account_explicit", f=lf_savings_account_explicit),
            LabelingFunction(name="lf_savings_transfer_terms", f=lf_savings_transfer_terms),
            LabelingFunction(name="lf_savings_fasttext_similarity", f=lf_savings_fasttext_similarity),
            LabelingFunction(name="lf_regular_monthly_savings", f=lf_regular_monthly_savings),
            LabelingFunction(name="lf_regular_weekly_savings", f=lf_regular_weekly_savings),
            LabelingFunction(name="lf_round_savings_amounts", f=lf_round_savings_amounts),
            LabelingFunction(name="lf_percentage_based_savings", f=lf_percentage_based_savings),
            LabelingFunction(name="lf_emergency_fund_pattern", f=lf_emergency_fund_pattern),
            LabelingFunction(name="lf_savings_banks_outflow", f=lf_savings_banks_outflow),
            LabelingFunction(name="lf_goal_based_savings", f=lf_goal_based_savings),
            LabelingFunction(name="lf_not_savings_investment_size", f=lf_not_savings_investment_size),
            LabelingFunction(name="lf_not_savings_bills_utilities", f=lf_not_savings_bills_utilities),
            LabelingFunction(name="lf_not_savings_daily_spending", f=lf_not_savings_daily_spending),
        ]


# Usage example
def create_savings_outflow_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run savings outflow classifier"""

    # Create classifier instance
    classifier = SavingsOutflowClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    return classifier, results


# Example usage:
"""
# Assuming you have ft_model, merchant_agg_df, and user_profile ready
savings_outflow_classifier, results = create_savings_outflow_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

# Access results
print(f"Savings outflow transactions found: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Access the updated dataframe with predictions
updated_df = savings_outflow_classifier.df
print(updated_df[['CLEANED_TEXT', 'is_savingsoutflow_weak_label', 'savingsoutflow_confidence']].head())

# Compare different outflow types
# You could run investment outflow, savings outflow, and regular spending classifiers
# to get a comprehensive view of where money is going
"""

"""# Loan principal

Given and taken
"""

"""
Loan Transaction Classifier using the reusable CategoryClassifier framework
Handles both loan receipts (inflows) and loan payments (outflows)
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class LoanTransactionClassifier(CategoryClassifier):
    """Loan transaction classifier for both receipts and payments using weak supervision framework"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("LoanTransaction", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_loan_thresholds()

        # Loan-specific anchor words for FastText expansion
        self.loan_anchor_terms = [
            "pret", "credit", "loan", "emprunt", "financement", "echeance",
            "mensualite", "remboursement", "deblocage", "amortissement"
        ]

        # Comprehensive loan terms organized by category
        self.loan_terms = {
            # Loan types
            "personal_loans": [
                "pret personnel", "credit conso", "credit consommation",
                "pret consommation", "personal loan", "consumer credit"
            ],

            "mortgage": [
                "pret immobilier", "credit immobilier", "hypotheque",
                "mortgage", "home loan", "real estate loan", "pret habitat"
            ],

            "auto_loans": [
                "pret auto", "credit auto", "financement vehicule",
                "car loan", "auto loan", "pret voiture", "credit voiture"
            ],

            "student_loans": [
                "pret etudiant", "credit etudiant", "student loan",
                "pret formation", "aide etudiant"
            ],

            "business_loans": [
                "pret entreprise", "credit entreprise", "business loan",
                "financement professionnel", "pret pro"
            ],

            # Loan receipt terms
            "loan_receipt": [
                "deblocage", "déblocage", "versement pret", "versement crédit",
                "mise a disposition", "mise à disposition", "octroi",
                "disbursement", "loan proceeds", "advance"
            ],

            # Loan payment terms
            "loan_payment": [
                "echeance", "échéance", "mensualite", "mensualité",
                "remboursement", "amortissement", "payment", "installment",
                "repayment", "monthly payment", "loan payment"
            ],

            # Financial institutions
            "lenders": [
                "bnp paribas", "credit agricole", "societe generale", "lcl",
                "credit mutuel", "banque populaire", "caisse epargne",
                "credit lyonnais", "hsbc", "ing", "hello bank",
                "cetelem", "cofidis", "sofinco", "franfinance",
                "cofinoga", "oney", "floa bank"
            ]
        }

        # Flatten all terms for easy searching
        self.all_loan_terms = []
        for category_terms in self.loan_terms.values():
            self.all_loan_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.loan_anchor_terms, similarity_threshold=0.65)

    def _calculate_loan_thresholds(self) -> dict:
        """Calculate thresholds for loan transaction detection"""
        base_thresholds = {
            # Loan receipt thresholds
            'min_loan_receipt': 1000,      # Minimum loan amount
            'max_loan_receipt': 1000000,   # Maximum reasonable loan
            'mortgage_min': 50000,         # Minimum mortgage
            'auto_loan_min': 3000,         # Minimum auto loan
            'personal_loan_min': 1000,     # Minimum personal loan

            # Loan payment thresholds
            'min_monthly_payment': 50,     # Minimum monthly payment
            'max_monthly_payment': 5000,   # Maximum reasonable monthly payment
            'mortgage_payment_min': 300,   # Typical mortgage payment
            'auto_payment_min': 100,       # Typical auto loan payment

            # Pattern thresholds
            'max_payment_cv': 0.05,        # Very consistent payments
            'min_payment_count': 3,        # Need pattern for payments
            'loan_receipt_max_count': 3,   # Few loan receipts expected
        }

        # Adjust based on user's income level if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'mortgage_min': 100000,
                    'mortgage_payment_min': 800,
                    'max_monthly_payment': 8000
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'mortgage_min': 30000,
                    'mortgage_payment_min': 200,
                    'min_monthly_payment': 25
                })

        return base_thresholds

    def _is_loan_amount(self, amount: float, loan_type: str = "general") -> bool:
        """Check if amount is typical for loan receipts"""
        amount = abs(amount)

        if loan_type == "mortgage":
            return self.thresholds['mortgage_min'] <= amount <= self.thresholds['max_loan_receipt']
        elif loan_type == "auto":
            return self.thresholds['auto_loan_min'] <= amount <= 100000
        elif loan_type == "personal":
            return self.thresholds['personal_loan_min'] <= amount <= 75000
        else:
            return self.thresholds['min_loan_receipt'] <= amount <= self.thresholds['max_loan_receipt']

    def _is_loan_payment_amount(self, amount: float) -> bool:
        """Check if amount is typical for loan payments"""
        amount = abs(amount)
        return self.thresholds['min_monthly_payment'] <= amount <= self.thresholds['max_monthly_payment']

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create loan transaction-specific labeling functions"""

        def lf_loan_receipt_explicit(x):
            """Detect explicit loan receipt terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be incoming (positive amount)
            if x.amt_mean <= 0:
                return self.ABSTAIN

            amount = x.amt_mean

            # Check for explicit loan receipt terms
            for term in self.loan_terms["loan_receipt"]:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if self._is_loan_amount(amount):
                        return self.POSITIVE

            # Check for loan types in receipt context
            for loan_type_category in ["personal_loans", "mortgage", "auto_loans", "student_loans"]:
                for term in self.loan_terms[loan_type_category]:
                    if term in text_lower:
                        if self._is_loan_amount(amount, loan_type_category.split('_')[0]):
                            return self.POSITIVE

            return self.ABSTAIN

        def lf_loan_payment_explicit(x):
            """Detect explicit loan payment terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be outgoing (negative amount)
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check for explicit loan payment terms
            for term in self.loan_terms["loan_payment"]:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if self._is_loan_payment_amount(amount):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_loan_fasttext_similarity(x):
            """Detect loan transactions using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)
            amount = abs(x.amt_mean)

            # High similarity with appropriate amounts
            if similarity >= 0.7:
                if x.amt_mean > 0 and self._is_loan_amount(amount):  # Receipt
                    return self.POSITIVE
                elif x.amt_mean < 0 and self._is_loan_payment_amount(amount):  # Payment
                    return self.POSITIVE
            elif similarity >= 0.6:
                if x.amt_mean > 0 and amount >= self.thresholds['mortgage_min']:  # Large receipt
                    return self.POSITIVE
                elif x.amt_mean < 0 and self._is_loan_payment_amount(amount) and x.amt_count >= 3:  # Regular payment
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_large_single_inflow(x):
            """Detect large single inflows that could be loan receipts"""
            if x.amt_mean <= 0:  # Must be incoming
                return self.ABSTAIN

            amount = x.amt_mean

            # Large amount, few transactions (typical loan receipt pattern)
            is_large = amount >= self.thresholds['min_loan_receipt']
            is_infrequent = x.amt_count <= self.thresholds['loan_receipt_max_count']
            is_round = amount % 1000 == 0 or amount % 500 == 0  # Loans often in round amounts

            if is_large and is_infrequent:
                return self.POSITIVE
            elif amount >= self.thresholds['mortgage_min'] and is_round:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_very_regular_monthly_payments(x):
            """Detect very regular monthly loan payments"""
            if x.amt_mean >= 0 or x.amt_count < self.thresholds['min_payment_count']:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very regular monthly pattern (loans are extremely consistent)
            is_monthly = 28 <= x.mean_delta_days <= 32
            is_very_consistent = x.amt_cv <= self.thresholds['max_payment_cv']
            is_reasonable_amount = self._is_loan_payment_amount(amount)
            has_enough_payments = x.amt_count >= 6  # At least 6 months of payments

            if is_monthly and is_very_consistent and is_reasonable_amount and has_enough_payments:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_lender_institution(x):
            """Detect transactions from/to known lending institutions"""
            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check both merchant name and transaction text
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Check for known lenders
            for lender in self.loan_terms["lenders"]:
                if lender in text_to_check:
                    if x.amt_mean > 0 and self._is_loan_amount(amount):  # Receipt from lender
                        return self.POSITIVE
                    elif x.amt_mean < 0 and self._is_loan_payment_amount(amount):  # Payment to lender
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_mortgage_pattern(x):
            """Detect mortgage-specific patterns"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()
            amount = abs(x.amt_mean)

            # Check for mortgage terms
            has_mortgage_term = any(term in text_lower for term in self.loan_terms["mortgage"])

            if has_mortgage_term:
                if x.amt_mean > 0 and self._is_loan_amount(amount, "mortgage"):  # Mortgage receipt
                    return self.POSITIVE
                elif x.amt_mean < 0 and amount >= self.thresholds['mortgage_payment_min']:  # Mortgage payment
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_auto_loan_pattern(x):
            """Detect auto loan-specific patterns"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()
            amount = abs(x.amt_mean)

            # Check for auto loan terms
            has_auto_term = any(term in text_lower for term in self.loan_terms["auto_loans"])

            if has_auto_term:
                if x.amt_mean > 0 and self._is_loan_amount(amount, "auto"):  # Auto loan receipt
                    return self.POSITIVE
                elif x.amt_mean < 0 and amount >= self.thresholds['auto_payment_min']:  # Auto loan payment
                    return self.POSITIVE

            return self.ABSTAIN

        def lf_bi_weekly_loan_payments(x):
            """Detect bi-weekly loan payment patterns"""
            if x.amt_mean >= 0 or x.amt_count < 6:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Bi-weekly pattern (some loans are paid bi-weekly)
            is_bi_weekly = 13 <= x.mean_delta_days <= 16
            is_very_consistent = x.amt_cv <= self.thresholds['max_payment_cv']
            is_reasonable_amount = self._is_loan_payment_amount(amount)

            if is_bi_weekly and is_very_consistent and is_reasonable_amount:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_not_loan_salary_like(x):
            """Negative LF: Salary-like patterns are not loans"""
            if x.amt_mean <= 0:  # Only check incoming for salary
                return self.ABSTAIN

            amount = x.amt_mean

            # Regular monthly income that's too consistent and wrong amount for loans
            is_monthly = 28 <= x.mean_delta_days <= 32
            is_very_consistent = x.amt_cv < 0.1
            is_salary_range = 1000 <= amount <= 8000  # Typical salary range
            has_many_payments = x.amt_count > 6

            if is_monthly and is_very_consistent and is_salary_range and has_many_payments:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_loan_investment_like(x):
            """Negative LF: Investment-like patterns are not loans"""
            if x.amt_mean >= 0:  # Only check outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Investment-like patterns (quarterly, high CV, etc.)
            is_quarterly = 80 <= x.mean_delta_days <= 100
            is_variable = x.amt_cv > 0.3
            is_investment_amount = 500 <= amount <= 5000

            if (is_quarterly or is_variable) and is_investment_amount:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_loan_small_frequent(x):
            """Negative LF: Small frequent transactions are not loans"""
            amount = abs(x.amt_mean)

            # Very small, very frequent transactions
            is_very_small = amount < 50
            is_very_frequent = x.mean_delta_days <= 7
            is_many_transactions = x.amt_count > 20

            if is_very_small and is_very_frequent and is_many_transactions:
                return self.NEGATIVE

            return self.ABSTAIN

        # Return list of labeling functions
        return [
            LabelingFunction(name="lf_loan_receipt_explicit", f=lf_loan_receipt_explicit),
            LabelingFunction(name="lf_loan_payment_explicit", f=lf_loan_payment_explicit),
            LabelingFunction(name="lf_loan_fasttext_similarity", f=lf_loan_fasttext_similarity),
            LabelingFunction(name="lf_large_single_inflow", f=lf_large_single_inflow),
            LabelingFunction(name="lf_very_regular_monthly_payments", f=lf_very_regular_monthly_payments),
            LabelingFunction(name="lf_lender_institution", f=lf_lender_institution),
            LabelingFunction(name="lf_mortgage_pattern", f=lf_mortgage_pattern),
            LabelingFunction(name="lf_auto_loan_pattern", f=lf_auto_loan_pattern),
            LabelingFunction(name="lf_bi_weekly_loan_payments", f=lf_bi_weekly_loan_payments),
            LabelingFunction(name="lf_not_loan_salary_like", f=lf_not_loan_salary_like),
            LabelingFunction(name="lf_not_loan_investment_like", f=lf_not_loan_investment_like),
            LabelingFunction(name="lf_not_loan_small_frequent", f=lf_not_loan_small_frequent),
        ]

    def get_loan_breakdown(self):
        """Get breakdown of loan receipts vs payments"""
        if not hasattr(self.df, 'is_loantransaction_weak_label'):
            raise ValueError("Must run classifier first")

        loan_transactions = self.df[self.df['is_loantransaction_weak_label'] == self.POSITIVE]

        receipts = loan_transactions[loan_transactions['amt_mean'] > 0]
        payments = loan_transactions[loan_transactions['amt_mean'] < 0]

        breakdown = {
            'total_loan_transactions': len(loan_transactions),
            'loan_receipts': len(receipts),
            'loan_payments': len(payments),
            'total_loan_amount_received': receipts['amt_mean'].sum() if len(receipts) > 0 else 0,
            'total_loan_payments_made': abs(payments['amt_mean'].sum()) if len(payments) > 0 else 0,
            'avg_loan_receipt': receipts['amt_mean'].mean() if len(receipts) > 0 else 0,
            'avg_loan_payment': abs(payments['amt_mean'].mean()) if len(payments) > 0 else 0
        }

        return breakdown


# Usage example
def create_loan_transaction_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run loan transaction classifier"""

    # Create classifier instance
    classifier = LoanTransactionClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    # Get loan breakdown
    breakdown = classifier.get_loan_breakdown()

    return classifier, results, breakdown


# Example usage:
"""
# Assuming you have ft_model, merchant_agg_df, and user_profile ready
loan_classifier, results, breakdown = create_loan_transaction_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

# Access results
print(f"Loan transactions found: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Access loan breakdown
print(f"Loan receipts: {breakdown['loan_receipts']}")
print(f"Loan payments: {breakdown['loan_payments']}")
print(f"Total amount borrowed: €{breakdown['total_loan_amount_received']:,.2f}")
print(f"Total payments made: €{breakdown['total_loan_payments_made']:,.2f}")

# Access the updated dataframe with predictions
updated_df = loan_classifier.df
loan_examples = updated_df[updated_df['is_loantransaction_weak_label'] == 1]
print(loan_examples[['CLEANED_TEXT', 'amt_mean', 'amt_count', 'loantransaction_confidence']].head())
"""

"""# Withdrawal"""

"""
Cash Withdrawal Classifier using the reusable CategoryClassifier framework
"""

import pandas as pd
import numpy as np
import re
from snorkel.labeling import LabelingFunction
from typing import List

class CashWithdrawalClassifier(CategoryClassifier):
    """Cash withdrawal classifier using weak supervision framework"""

    def __init__(self, ft_model, dataframe: pd.DataFrame, user_profile=None):
        super().__init__("CashWithdrawal", ft_model, dataframe)
        self.user_profile = user_profile
        self.thresholds = self._calculate_cash_withdrawal_thresholds()

        # Cash withdrawal-specific anchor words for FastText expansion
        self.cash_withdrawal_anchor_terms = [
            "retrait", "distributeur", "dab", "gab", "atm", "cash",
            "especes", "liquide", "billets", "withdrawal"
        ]

        # Comprehensive cash withdrawal terms organized by category
        self.cash_withdrawal_terms = {
            # ATM/withdrawal terminology
            "atm_terms": [
                "retrait", "retraits", "distributeur", "distributeurs",
                "dab", "gab", "atm", "cash", "especes", "espèces",
                "liquide", "billets", "withdrawal", "cashout"
            ],

            # Bank ATM networks and locations
            "bank_atms": [
                "credit agricole", "crédit agricole", "bnp paribas", "bnp",
                "societe generale", "société générale", "sg", "lcl",
                "credit mutuel", "crédit mutuel", "banque populaire",
                "caisse epargne", "caisse d epargne", "cic", "hsbc",
                "la banque postale", "banque postale"
            ],

            # ATM location types
            "location_types": [
                "agence", "bureau", "centre", "gare", "aeroport", "aéroport",
                "station", "supermarche", "supermarché", "centre commercial",
                "galerie", "mall", "parking", "hotel", "hôtel"
            ],

            # ATM network operators
            "atm_operators": [
                "euronet", "cardpoint", "moneybox", "cash group",
                "note machine", "cashzone", "link", "pulse"
            ],

            # International/travel ATMs
            "international": [
                "foreign", "etranger", "étranger", "abroad", "overseas",
                "international", "visa", "mastercard", "cirrus", "plus"
            ]
        }

        # Common ATM bill denominations (in euros)
        self.atm_denominations = [10, 20, 50, 100, 200]

        # Common withdrawal amounts
        self.common_withdrawal_amounts = [
            20, 30, 40, 50, 60, 80, 100, 120, 150, 200, 250, 300, 400, 500
        ]

        # Flatten all terms for easy searching
        self.all_cash_terms = []
        for category_terms in self.cash_withdrawal_terms.values():
            self.all_cash_terms.extend(category_terms)

        # Setup FastText anchors
        self.setup_anchors(self.cash_withdrawal_anchor_terms, similarity_threshold=0.65)

    def _calculate_cash_withdrawal_thresholds(self) -> dict:
        """Calculate thresholds for cash withdrawal detection"""
        base_thresholds = {
            'min_withdrawal': 10,       # Minimum ATM withdrawal
            'max_withdrawal': 1000,     # Maximum reasonable cash withdrawal
            'common_min': 20,           # Most common minimum
            'common_max': 300,          # Most common maximum
            'daily_limit': 500,         # Typical daily ATM limit
            'max_cv': 1.2,             # Higher variability than bills/loans
            'min_transactions': 1,      # Single withdrawals are normal
            'max_frequency_days': 1,    # Can withdraw multiple times per day
            'min_frequency_days': 365   # But not more than daily over long term
        }

        # Adjust based on user's income level if available
        if self.user_profile and hasattr(self.user_profile, 'monthly_income_range'):
            if self.user_profile.monthly_income_range == "4000_plus":
                base_thresholds.update({
                    'common_max': 500,
                    'daily_limit': 800,
                    'max_withdrawal': 1500
                })
            elif self.user_profile.monthly_income_range == "under_1500":
                base_thresholds.update({
                    'common_max': 150,
                    'daily_limit': 300,
                    'max_withdrawal': 400
                })

        return base_thresholds

    def _is_atm_amount(self, amount: float) -> bool:
        """Check if amount matches ATM bill denominations"""
        amount = abs(amount)

        # Must be within reasonable ATM range
        if not (self.thresholds['min_withdrawal'] <= amount <= self.thresholds['max_withdrawal']):
            return False

        # Must be multiple of 10 (ATM bills are €10, €20, €50, €100, €200)
        if amount % 10 != 0:
            return False

        # Prefer common withdrawal amounts
        if int(amount) in self.common_withdrawal_amounts:
            return True

        # Or multiples of ATM denominations
        for denom in self.atm_denominations:
            if amount % denom == 0:
                return True

        return False

    def _detect_location_code(self, text: str) -> bool:
        """Detect if transaction text contains location/ATM codes"""
        if not text:
            return False

        text_upper = text.upper()

        # Common patterns for ATM location codes
        patterns = [
            r'\b[A-Z]{2,4}\d{2,6}\b',      # Location codes like "PAR123456"
            r'\b\d{4,6}[A-Z]{2,4}\b',      # Reverse pattern
            r'\bATM\d{3,6}\b',             # ATM followed by numbers
            r'\bDAB\d{3,6}\b',             # DAB followed by numbers
            r'\b[A-Z]{3,}\s+\d{3,}\b',     # Letters followed by numbers
            r'\bAGENCE\s+\d+\b',           # French agency codes
            r'\bCENTRE\s+\d+\b'            # Center codes
        ]

        for pattern in patterns:
            if re.search(pattern, text_upper):
                return True

        return False

    def _is_vacation_withdrawal_pattern(self, x) -> bool:
        """Detect vacation/travel withdrawal patterns"""
        amount = abs(x.amt_mean)

        # Larger amounts, less frequent (vacation cash)
        is_larger = amount >= 200
        is_infrequent = x.amt_count <= 10  # Not regular daily cash
        has_location_indicators = self._detect_location_code(x.CLEANED_TEXT) if not pd.isna(x.CLEANED_TEXT) else False

        return is_larger and (is_infrequent or has_location_indicators)

    def create_labeling_functions(self) -> List[LabelingFunction]:
        """Create cash withdrawal-specific labeling functions"""

        def lf_explicit_withdrawal_terms(x):
            """Detect explicit cash withdrawal terms"""
            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Must be outgoing (negative amount)
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check for explicit ATM/withdrawal terms
            for term in self.cash_withdrawal_terms["atm_terms"]:
                if re.search(rf"\b{re.escape(term)}\b", text_lower):
                    if self.thresholds['min_withdrawal'] <= amount <= self.thresholds['max_withdrawal']:
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_atm_round_amounts(x):
            """Detect ATM-typical round amounts"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check if amount is typical for ATM withdrawals
            is_atm_amount = self._is_atm_amount(amount)
            reasonable_frequency = x.amt_count <= 365  # Not more than daily

            if is_atm_amount and reasonable_frequency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_cash_withdrawal_fasttext_similarity(x):
            """Detect cash withdrawals using FastText similarity"""
            if not self.anchor_system or pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            # Must be outgoing
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)
            similarity = self.anchor_system.get_text_similarity(x.CLEANED_TEXT)

            # High similarity with reasonable amount
            if similarity >= 0.7 and self._is_atm_amount(amount):
                return self.POSITIVE
            # Lower similarity but with ATM-like patterns
            elif similarity >= 0.6 and self._is_atm_amount(amount) and self._detect_location_code(x.CLEANED_TEXT):
                return self.POSITIVE

            return self.ABSTAIN

        def lf_bank_atm_networks(x):
            """Detect withdrawals from bank ATM networks"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.MERCHANT) and (pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == ""):
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check both merchant name and transaction text
            text_to_check = ""
            if not pd.isna(x.MERCHANT):
                text_to_check += x.MERCHANT.lower() + " "
            if not pd.isna(x.CLEANED_TEXT):
                text_to_check += x.CLEANED_TEXT.lower()

            # Check for bank ATM networks
            for bank in self.cash_withdrawal_terms["bank_atms"]:
                if bank in text_to_check:
                    if self._is_atm_amount(amount):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_atm_location_codes(x):
            """Detect ATM withdrawals with location codes"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Check for location codes in transaction text
            has_location_code = self._detect_location_code(x.CLEANED_TEXT)
            is_reasonable_amount = self.thresholds['min_withdrawal'] <= amount <= self.thresholds['max_withdrawal']

            if has_location_code and is_reasonable_amount:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_frequent_small_cash_pattern(x):
            """Detect frequent small cash withdrawal patterns"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Small, frequent cash withdrawals
            is_small_amount = self.thresholds['common_min'] <= amount <= 100
            is_frequent = 3 <= x.mean_delta_days <= 14  # Every few days to bi-weekly
            is_round = self._is_atm_amount(amount)
            moderate_consistency = 0.2 <= x.amt_cv <= self.thresholds['max_cv']

            if is_small_amount and is_frequent and is_round and moderate_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_weekly_cash_needs(x):
            """Detect weekly cash withdrawal patterns"""
            if x.amt_mean >= 0 or x.amt_count < 3:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Weekly cash pattern
            is_weekly = 5 <= x.mean_delta_days <= 9
            is_reasonable_amount = self.thresholds['common_min'] <= amount <= self.thresholds['common_max']
            is_atm_amount = self._is_atm_amount(amount)
            moderate_consistency = x.amt_cv <= 0.8  # Some variability in cash needs

            if is_weekly and is_reasonable_amount and is_atm_amount and moderate_consistency:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_vacation_travel_cash(x):
            """Detect vacation/travel cash withdrawal patterns"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            # Check for vacation withdrawal patterns
            is_vacation_pattern = self._is_vacation_withdrawal_pattern(x)

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                if is_vacation_pattern:
                    return self.POSITIVE
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Check for international/travel indicators
            has_travel_term = any(term in text_lower for term in self.cash_withdrawal_terms["international"])
            has_location_term = any(term in text_lower for term in self.cash_withdrawal_terms["location_types"])

            if is_vacation_pattern or has_travel_term or has_location_term:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_maximum_daily_withdrawals(x):
            """Detect maximum daily limit withdrawals"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Amounts near daily limits (suggests ATM)
            is_near_limit = (
                amount >= 300 and amount % 50 == 0  # €300, €350, €400, €450, €500
            ) or amount in [250, 300, 400, 500, 600]  # Common daily limits

            is_infrequent = x.amt_count <= 30  # Not too frequent

            if is_near_limit and is_infrequent:
                return self.POSITIVE

            return self.ABSTAIN

        def lf_atm_operator_networks(x):
            """Detect third-party ATM operators"""
            if x.amt_mean >= 0:  # Must be outgoing
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()
            amount = abs(x.amt_mean)

            # Check for ATM operator networks
            for operator in self.cash_withdrawal_terms["atm_operators"]:
                if operator in text_lower:
                    if self._is_atm_amount(amount):
                        return self.POSITIVE

            return self.ABSTAIN

        def lf_not_cash_large_non_round(x):
            """Negative LF: Large non-round amounts unlikely to be cash"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very large amounts that are not ATM-typical
            is_very_large = amount > 800
            is_non_round = not self._is_atm_amount(amount)

            if is_very_large and is_non_round:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_cash_too_regular_bills(x):
            """Negative LF: Too regular payments are bills/loans, not cash"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # Very regular monthly patterns with low CV (bills/loans)
            is_monthly = 28 <= x.mean_delta_days <= 32
            is_very_consistent = x.amt_cv < 0.1
            has_many_payments = x.amt_count >= 6

            if is_monthly and is_very_consistent and has_many_payments:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_cash_merchant_payments(x):
            """Negative LF: Payments to merchants are not cash withdrawals"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            if pd.isna(x.CLEANED_TEXT) or x.CLEANED_TEXT == "":
                return self.ABSTAIN

            text_lower = x.CLEANED_TEXT.lower()

            # Common merchant/service terms
            merchant_terms = [
                "amazon", "paypal", "uber", "spotify", "netflix",
                "supermarche", "restaurant", "cafe", "hotel",
                "essence", "carburant", "pharmacie", "boulangerie"
            ]

            has_merchant_term = any(term in text_lower for term in merchant_terms)

            if has_merchant_term:
                return self.NEGATIVE

            return self.ABSTAIN

        def lf_not_cash_decimal_amounts(x):
            """Negative LF: Amounts with cents are not ATM withdrawals"""
            if x.amt_mean >= 0:
                return self.ABSTAIN

            amount = abs(x.amt_mean)

            # ATMs don't dispense cents
            has_cents = (amount % 1) != 0

            if has_cents:
                return self.NEGATIVE

            return self.ABSTAIN

        # Return list of labeling functions
        return [
            LabelingFunction(name="lf_explicit_withdrawal_terms", f=lf_explicit_withdrawal_terms),
            LabelingFunction(name="lf_atm_round_amounts", f=lf_atm_round_amounts),
            LabelingFunction(name="lf_cash_withdrawal_fasttext_similarity", f=lf_cash_withdrawal_fasttext_similarity),
            LabelingFunction(name="lf_bank_atm_networks", f=lf_bank_atm_networks),
            LabelingFunction(name="lf_atm_location_codes", f=lf_atm_location_codes),
            LabelingFunction(name="lf_frequent_small_cash_pattern", f=lf_frequent_small_cash_pattern),
            LabelingFunction(name="lf_weekly_cash_needs", f=lf_weekly_cash_needs),
            LabelingFunction(name="lf_vacation_travel_cash", f=lf_vacation_travel_cash),
            LabelingFunction(name="lf_maximum_daily_withdrawals", f=lf_maximum_daily_withdrawals),
            LabelingFunction(name="lf_atm_operator_networks", f=lf_atm_operator_networks),
            LabelingFunction(name="lf_not_cash_large_non_round", f=lf_not_cash_large_non_round),
            LabelingFunction(name="lf_not_cash_too_regular_bills", f=lf_not_cash_too_regular_bills),
            LabelingFunction(name="lf_not_cash_merchant_payments", f=lf_not_cash_merchant_payments),
            LabelingFunction(name="lf_not_cash_decimal_amounts", f=lf_not_cash_decimal_amounts),
        ]

    def get_cash_usage_analysis(self):
        """Get analysis of cash usage patterns"""
        if not hasattr(self.df, 'is_cashwithdrawal_weak_label'):
            raise ValueError("Must run classifier first")

        cash_withdrawals = self.df[self.df['is_cashwithdrawal_weak_label'] == self.POSITIVE]

        if len(cash_withdrawals) == 0:
            return {"total_cash_withdrawals": 0}

        analysis = {
            'total_cash_withdrawals': len(cash_withdrawals),
            'total_cash_withdrawn': abs(cash_withdrawals['amt_mean'].sum()),
            'avg_withdrawal_amount': abs(cash_withdrawals['amt_mean'].mean()),
            'median_withdrawal_amount': abs(cash_withdrawals['amt_mean'].median()),
            'most_common_amounts': cash_withdrawals['amt_mean'].abs().value_counts().head().to_dict(),
            'avg_frequency_days': cash_withdrawals['mean_delta_days'].mean(),
            'cash_usage_variability': cash_withdrawals['amt_cv'].mean(),
        }

        # Categorize by withdrawal size
        small_withdrawals = cash_withdrawals[abs(cash_withdrawals['amt_mean']) <= 50]
        medium_withdrawals = cash_withdrawals[(abs(cash_withdrawals['amt_mean']) > 50) &
                                            (abs(cash_withdrawals['amt_mean']) <= 200)]
        large_withdrawals = cash_withdrawals[abs(cash_withdrawals['amt_mean']) > 200]

        analysis.update({
            'small_withdrawals_count': len(small_withdrawals),
            'medium_withdrawals_count': len(medium_withdrawals),
            'large_withdrawals_count': len(large_withdrawals),
        })

        return analysis


# Usage example
def create_cash_withdrawal_classifier(ft_model, merchant_agg_df, user_profile=None):
    """Create and run cash withdrawal classifier"""

    # Create classifier instance
    classifier = CashWithdrawalClassifier(ft_model, merchant_agg_df, user_profile)

    # Run full pipeline
    results = classifier.run_full_pipeline(confidence_threshold=0.7)

    # Get cash usage analysis
    cash_analysis = classifier.get_cash_usage_analysis()

    return classifier, results, cash_analysis


# Example usage:
"""
# Assuming you have ft_model, merchant_agg_df, and user_profile ready
cash_classifier, results, cash_analysis = create_cash_withdrawal_classifier(
    ft_model=ft,
    merchant_agg_df=merchant_agg_df,
    user_profile=user_profile
)

# Access results
print(f"Cash withdrawal transactions found: {results['predicted_positive']}")
print(f"High confidence: {results['high_confidence_positive']}")

# Access cash usage analysis
print(f"Total cash withdrawn: €{cash_analysis['total_cash_withdrawn']:,.2f}")
print(f"Average withdrawal: €{cash_analysis['avg_withdrawal_amount']:.2f}")
print(f"Withdrawal frequency: every {cash_analysis['avg_frequency_days']:.1f} days")

# Access the updated dataframe with predictions
updated_df = cash_classifier.df
cash_examples = updated_df[updated_df['is_cashwithdrawal_weak_label'] == 1]
print(cash_examples[['CLEANED_TEXT', 'amt_mean', 'amt_count', 'cashwithdrawal_confidence']].head())
"""